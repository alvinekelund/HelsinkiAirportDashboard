2024.03.24 10:02:23 INFO  Started: Metals version 1.2.2 in folders '/Users/alvin/VScode/OS2Projekti' for client Visual Studio Code 1.87.2.
10:02:24.983 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
10:02:24.990 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
10:02:24.990 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
10:02:24.993 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
10:02:24.993 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@531d72ca ...
10:02:24.993 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
10:02:24.993 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
10:02:24.993 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@531d72ca ...
10:02:24.998 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
10:02:25.002 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
10:02:25.003 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
10:02:25.003 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
10:02:25.003 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
10:02:25.003 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
10:02:25.004 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
10:02:25.011 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:02:25.011 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
10:02:25.012 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
10:02:25.013 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
10:02:25.013 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
10:02:25.137 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:/Users/alvin/VScode/OS2Projekti/.metals/metals (H2 2.2)
10:02:25.138 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
10:02:25.138 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
10:02:25.139 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
10:02:25.139 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
10:02:25.144 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
10:02:25.145 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
10:02:25.145 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:02:25.154 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
10:02:25.159 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:02:25.171 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:02:25.171 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:02:25.171 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:02:25.171 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:02:25.171 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:02:25.172 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:02:25.172 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:02:25.172 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:02:25.172 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:02:25.172 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:02:25.189 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.033s)
10:02:25.191 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
10:02:25.201 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
10:02:25.205 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
10:02:25.559 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 60 of 200M
2024.03.24 10:02:26 INFO  skipping build import with status 'Installed'
2024.03.24 10:02:26 INFO  Attempting to connect to the build server...
2024.03.24 10:02:26 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.03.24 10:02:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.03.24 10:02:27 INFO  Attempting to connect to the build server...
2024.03.24 10:02:27 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.03.24 10:02:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/project/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.03.24 10:02:27 INFO  time: Connected to build server in 1.8s
2024.03.24 10:02:27 INFO  Connected to Build server: Bloop v1.5.15
2024.03.24 10:02:28 INFO  time: Imported build in 0.55s
2024.03.24 10:02:44 INFO  time: indexed workspace in 15s
Mar 24, 2024 10:11:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 261
2024.03.24 10:11:27 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 8m 59.982s)
2024.03.24 10:11:27 INFO  compiling root (1 scala source)
2024.03.24 10:11:27 INFO  compiling root (1 scala source)
2024.03.24 10:11:30 INFO  time: compiled root in 2.95s
2024.03.24 10:11:30 INFO  compiling root (1 scala source)
2024.03.24 10:11:33 INFO  time: compiled root in 2.27s
2024.03.24 10:11:33 INFO  {
  "jsonrpc": "2.0",
  "id": "30",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.03.24 10:11:33 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 10:12:17 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:206: error: unclosed character literal
      val vcVbox = new VBox(vie')
                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 10:12:31 INFO  compiling root (1 scala source)
2024.03.24 10:12:31 INFO  time: compiled root in 0.9s
2024.03.24 10:12:31 INFO  compiling root (1 scala source)
2024.03.24 10:12:34 INFO  time: compiled root in 2.2s
2024.03.24 10:12:42 INFO  compiling root (1 scala source)
2024.03.24 10:12:45 INFO  time: compiled root in 2.5s
2024.03.24 10:12:45 INFO  compiling root (1 scala source)
Mar 24, 2024 10:12:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 633
2024.03.24 10:12:48 INFO  time: compiled root in 3.27s
2024.03.24 10:12:52 INFO  compiling root (1 scala source)
2024.03.24 10:12:54 INFO  time: compiled root in 2.44s
2024.03.24 10:12:54 INFO  compiling root (1 scala source)
2024.03.24 10:12:57 INFO  time: compiled root in 2.18s
2024.03.24 10:13:14 INFO  compiling root (1 scala source)
2024.03.24 10:13:16 INFO  time: compiled root in 1.97s
2024.03.24 10:13:16 INFO  compiling root (1 scala source)
2024.03.24 10:13:18 INFO  time: compiled root in 1.48s
2024.03.24 10:14:08 INFO  compiling root (1 scala source)
2024.03.24 10:14:09 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:14:09 INFO  time: compiled root in 1.65s
2024.03.24 10:17:36 INFO  compiling root (1 scala source)
2024.03.24 10:17:38 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:17:38 INFO  time: compiled root in 1.26s
2024.03.24 10:18:12 INFO  compiling root (1 scala source)
2024.03.24 10:18:12 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 15m 44.663s)
2024.03.24 10:18:12 INFO  compiling root (1 scala source)
2024.03.24 10:18:13 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:18:13 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:18:13 INFO  time: compiled root in 1.18s
2024.03.24 10:18:13 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.24 10:18:13 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.24 10:18:13 INFO  Starting debug proxy for [Dashboard]
2024.03.24 10:18:13 INFO  Loaded expression compiler in 9 milliseconds
2024.03.24 10:18:13 INFO  Loaded step filter in 0 milliseconds
2024.03.24 10:18:13 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.24 10:18:16 INFO  Loaded all sources and classes in 2 seconds
2024.03.24 10:18:17 INFO  Trying to attach to remote debuggee VM localhost:50625 .
2024.03.24 10:18:17 INFO  Attaching to debuggee VM succeeded.
2024.03.24 10:20:50 INFO  Closing debug server tcp://0.0.0.0:50622
2024.03.24 10:20:50 INFO  Canceling debug proxy for [Dashboard]
Mar 24, 2024 10:21:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 861
2024.03.24 10:21:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:34 INFO  compiling root (1 scala source)
2024.03.24 10:21:34 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 19m 7.168s)
2024.03.24 10:21:34 INFO  compiling root (1 scala source)
2024.03.24 10:21:34 INFO  time: compiled root in 0.94s
2024.03.24 10:21:34 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 19m 8.132s)
2024.03.24 10:21:34 INFO  compiling root (1 scala source)
2024.03.24 10:21:34 INFO  compiling root (1 scala source)
2024.03.24 10:21:36 INFO  time: compiled root in 0.71s
2024.03.24 10:21:36 INFO  {
  "jsonrpc": "2.0",
  "id": "103",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.03.24 10:21:36 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 10:21:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:38 INFO  compiling root (1 scala source)
2024.03.24 10:21:40 INFO  time: compiled root in 1.54s
2024.03.24 10:21:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:50 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:53 INFO  compiling root (1 scala source)
2024.03.24 10:21:53 INFO  time: compiled root in 0.77s
2024.03.24 10:21:53 INFO  compiling root (1 scala source)
2024.03.24 10:21:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:55 INFO  time: compiled root in 1.16s
2024.03.24 10:21:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.03.24 10:21:58 INFO  compiling root (1 scala source)
2024.03.24 10:21:59 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:21:59 INFO  time: compiled root in 1.14s
2024.03.24 10:33:58 INFO  compiling root (1 scala source)
2024.03.24 10:33:59 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:33:59 INFO  time: compiled root in 1.25s
2024.03.24 10:38:06 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:210: error: illegal character '\u00a7'
  §
  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 10:38:11 INFO  compiling root (1 scala source)
2024.03.24 10:38:13 INFO  time: compiled root in 1.93s
2024.03.24 10:38:56 INFO  compiling root (1 scala source)
2024.03.24 10:38:58 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:38:58 INFO  time: compiled root in 1.2s
2024.03.24 10:40:27 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 38m 0.077s)
2024.03.24 10:40:27 INFO  compiling root (1 scala source)
2024.03.24 10:40:27 INFO  compiling root (1 scala source)
2024.03.24 10:40:28 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:40:28 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:40:28 INFO  time: compiled root in 1.24s
2024.03.24 10:40:28 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 38m 1.413s)
2024.03.24 10:40:29 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.24 10:40:29 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.24 10:40:29 INFO  Starting debug proxy for [Dashboard]
2024.03.24 10:40:28 INFO  Loaded expression compiler in 3 milliseconds
2024.03.24 10:40:28 INFO  Loaded step filter in 0 milliseconds
2024.03.24 10:40:28 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.24 10:40:31 INFO  Loaded all sources and classes in 2 seconds
2024.03.24 10:40:33 INFO  Trying to attach to remote debuggee VM localhost:50708 .
2024.03.24 10:40:33 INFO  Attaching to debuggee VM succeeded.
2024.03.24 10:41:58 INFO  compiling root (1 scala source)
2024.03.24 10:42:01 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 10:42:01 INFO  time: compiled root in 2.68s
2024.03.24 10:42:54 INFO  Closing debug server tcp://0.0.0.0:50705
2024.03.24 10:42:54 INFO  Canceling debug proxy for [Dashboard]
Mar 24, 2024 10:44:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1465
Mar 24, 2024 10:50:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1819
Mar 24, 2024 10:52:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2097
Mar 24, 2024 10:52:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2102
Mar 24, 2024 10:52:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2103
Mar 24, 2024 10:53:15 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-03-24/r_compiler-error_(root)_10-53-15-729.md
2024.03.24 10:53:16 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:217: error: malformed xml literal, expected:
Expected ("\"" | "'" | "{"):217:26, found "Pos.Center"
      vcHbox.alignment = Pos.CenterRight
                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getXml(LegacyScanner.scala:937)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchLT$1(LegacyScanner.scala:295)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:303)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Mar 24, 2024 10:57:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3029
2024.03.24 10:58:48 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 56m 21.35s)
2024.03.24 10:58:48 INFO  compiling root (1 scala source)
2024.03.24 10:58:48 INFO  compiling root (1 scala source)
2024.03.24 10:58:50 INFO  time: compiled root in 1.1s
2024.03.24 10:58:50 INFO  compiling root (1 scala source)
2024.03.24 10:58:51 INFO  time: compiled root in 1s
2024.03.24 10:58:51 INFO  {
  "jsonrpc": "2.0",
  "id": "196",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.03.24 10:58:51 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 10:58:51 INFO  compiling root (1 scala source)
2024.03.24 10:58:52 INFO  time: compiled root in 1.07s
Mar 24, 2024 10:59:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3308
Mar 24, 2024 10:59:17 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3337
2024.03.24 10:59:33 INFO  compiling root (1 scala source)
2024.03.24 10:59:33 INFO  time: compiled root in 0.87s
2024.03.24 10:59:33 INFO  compiling root (1 scala source)
2024.03.24 10:59:34 INFO  time: compiled root in 0.94s
2024.03.24 11:00:15 INFO  compiling root (1 scala source)
2024.03.24 11:00:15 INFO  time: compiled root in 0.9s
2024.03.24 11:00:15 INFO  compiling root (1 scala source)
2024.03.24 11:00:16 INFO  time: compiled root in 0.8s
2024.03.24 11:00:19 INFO  compiling root (1 scala source)
2024.03.24 11:00:19 INFO  time: compiled root in 0.84s
2024.03.24 11:02:05 INFO  compiling root (1 scala source)
2024.03.24 11:02:05 INFO  time: compiled root in 0.88s
2024.03.24 11:02:05 INFO  compiling root (1 scala source)
2024.03.24 11:02:07 INFO  time: compiled root in 0.91s
2024.03.24 11:02:35 INFO  compiling root (1 scala source)
2024.03.24 11:02:37 INFO  time: compiled root in 2.12s
2024.03.24 11:02:37 INFO  compiling root (1 scala source)
2024.03.24 11:02:40 INFO  time: compiled root in 2.1s
2024.03.24 11:02:40 INFO  compiling root (1 scala source)
2024.03.24 11:02:42 INFO  time: compiled root in 2.34s
2024.03.24 11:04:02 INFO  compiling root (1 scala source)
2024.03.24 11:04:03 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 11:04:03 INFO  time: compiled root in 1.48s
2024.03.24 11:04:03 INFO  compiling root (1 scala source)
2024.03.24 11:04:04 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 11:04:04 INFO  time: compiled root in 1s
2024.03.24 11:04:07 INFO  compiling root (1 scala source)
2024.03.24 11:04:08 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 11:04:08 INFO  time: compiled root in 1.02s
2024.03.24 11:04:25 INFO  compiling root (1 scala source)
2024.03.24 11:04:27 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 11:04:27 INFO  time: compiled root in 1.02s
2024.03.24 11:04:27 INFO  compiling root (1 scala source)
2024.03.24 11:04:28 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 11:04:28 INFO  time: compiled root in 0.92s
2024.03.24 11:04:39 INFO  compiling root (1 scala source)
2024.03.24 11:04:40 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 11:04:40 INFO  time: compiled root in 1.37s
2024.03.24 11:06:09 INFO  compiling root (1 scala source)
2024.03.24 11:06:10 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 11:06:10 INFO  time: compiled root in 1.18s
2024.03.24 11:17:21 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 14m 54.077s)
2024.03.24 11:17:21 INFO  compiling root (1 scala source)
2024.03.24 11:17:21 INFO  compiling root (1 scala source)
2024.03.24 11:17:21 INFO  time: compiled root in 0.98s
2024.03.24 11:17:22 INFO  compiling root (1 scala source)
2024.03.24 11:17:22 INFO  time: compiled root in 0.77s
2024.03.24 11:17:22 INFO  compiling root (1 scala source)
2024.03.24 11:17:24 INFO  time: compiled root in 0.79s
2024.03.24 11:17:24 INFO  {
  "jsonrpc": "2.0",
  "id": "299",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.03.24 11:17:24 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 11:25:03 INFO  compiling root (1 scala source)
2024.03.24 11:25:04 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 11:25:04 INFO  time: compiled root in 1.34s
2024.03.24 11:30:20 INFO  compiling root (1 scala source)
2024.03.24 11:30:20 INFO  time: compiled root in 0.98s
2024.03.24 11:30:36 INFO  compiling root (1 scala source)
2024.03.24 11:30:38 INFO  time: compiled root in 1.59s
2024.03.24 11:32:11 INFO  compiling root (1 scala source)
2024.03.24 11:32:12 INFO  time: compiled root in 1.56s
2024.03.24 11:32:12 INFO  compiling root (1 scala source)
2024.03.24 11:32:13 INFO  time: compiled root in 1.13s
2024.03.24 11:32:36 INFO  compiling root (1 scala source)
2024.03.24 11:32:38 INFO  time: compiled root in 1.9s
2024.03.24 11:32:38 INFO  compiling root (1 scala source)
2024.03.24 11:32:39 INFO  time: compiled root in 1.53s
2024.03.24 11:32:47 INFO  compiling root (1 scala source)
2024.03.24 11:32:49 INFO  time: compiled root in 1.85s
2024.03.24 11:34:01 INFO  compiling root (1 scala source)
2024.03.24 11:34:01 INFO  time: compiled root in 0.86s
2024.03.24 11:34:01 INFO  compiling root (1 scala source)
2024.03.24 11:34:02 INFO  time: compiled root in 0.7s
2024.03.24 11:34:39 INFO  compiling root (1 scala source)
2024.03.24 11:34:41 INFO  time: compiled root in 1.45s
2024.03.24 11:34:41 INFO  compiling root (1 scala source)
2024.03.24 11:34:42 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 11:34:42 INFO  time: compiled root in 1.85s
2024.03.24 11:58:31 INFO  compiling root (1 scala source)
2024.03.24 11:58:33 INFO  time: compiled root in 1.11s
2024.03.24 11:58:33 INFO  compiling root (1 scala source)
2024.03.24 11:58:33 INFO  time: compiled root in 0.92s
2024.03.24 11:58:52 INFO  compiling root (1 scala source)
2024.03.24 11:58:52 INFO  time: compiled root in 0.85s
2024.03.24 11:58:52 INFO  compiling root (1 scala source)
2024.03.24 11:58:54 INFO  time: compiled root in 1.05s
Mar 24, 2024 11:59:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5441
2024.03.24 11:59:15 INFO  compiling root (1 scala source)
2024.03.24 11:59:16 INFO  time: compiled root in 1.7s
2024.03.24 12:02:24 INFO  compiling root (1 scala source)
2024.03.24 12:02:26 INFO  time: compiled root in 1.53s
2024.03.24 12:09:48 INFO  compiling root (1 scala source)
2024.03.24 12:09:50 INFO  time: compiled root in 1.9s
2024.03.24 12:09:50 INFO  compiling root (1 scala source)
2024.03.24 12:09:51 INFO  time: compiled root in 1.42s
2024.03.24 12:10:26 INFO  compiling root (1 scala source)
2024.03.24 12:10:28 INFO  time: compiled root in 1.6s
2024.03.24 12:10:28 INFO  compiling root (1 scala source)
2024.03.24 12:10:29 INFO  time: compiled root in 1.39s
2024.03.24 12:10:38 INFO  compiling root (1 scala source)
2024.03.24 12:10:40 INFO  time: compiled root in 1.45s
2024.03.24 12:10:40 INFO  compiling root (1 scala source)
2024.03.24 12:10:41 INFO  time: compiled root in 1.42s
2024.03.24 12:11:01 INFO  compiling root (1 scala source)
2024.03.24 12:11:02 INFO  time: compiled root in 1.5s
2024.03.24 12:11:34 INFO  compiling root (1 scala source)
2024.03.24 12:11:36 INFO  time: compiled root in 1.53s
2024.03.24 12:11:36 INFO  compiling root (1 scala source)
2024.03.24 12:11:37 INFO  time: compiled root in 1.28s
2024.03.24 12:11:59 INFO  compiling root (1 scala source)
2024.03.24 12:12:00 INFO  time: compiled root in 1.2s
2024.03.24 12:13:12 INFO  compiling root (1 scala source)
2024.03.24 12:13:13 INFO  time: compiled root in 1.03s
2024.03.24 12:15:36 INFO  compiling root (1 scala source)
2024.03.24 12:15:38 INFO  time: compiled root in 1.4s
2024.03.24 12:16:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:29 INFO  compiling root (1 scala source)
2024.03.24 12:16:31 INFO  time: compiled root in 1.3s
2024.03.24 12:16:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:41 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:47 INFO  compiling root (1 scala source)
2024.03.24 12:16:48 INFO  time: compiled root in 1.28s
2024.03.24 12:16:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:54 INFO  compiling root (1 scala source)
2024.03.24 12:16:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:55 INFO  time: compiled root in 1.15s
2024.03.24 12:16:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:16:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:17:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:17:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:17:08 INFO  compiling root (1 scala source)
2024.03.24 12:17:09 INFO  time: compiled root in 1.27s
2024.03.24 12:17:09 INFO  compiling root (1 scala source)
2024.03.24 12:17:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:17:10 INFO  time: compiled root in 1.15s
2024.03.24 12:17:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:17:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:18:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Mar 24, 2024 12:19:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6217
2024.03.24 12:19:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:41 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Mar 24, 2024 12:19:55 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-03-24/r_compiler-error_(root)_12-19-55-764.md
2024.03.24 12:19:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:19:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:00 INFO  compiling root (1 scala source)
2024.03.24 12:20:00 INFO  time: compiled root in 0.36s
2024.03.24 12:20:00 INFO  compiling root (1 scala source)
2024.03.24 12:20:00 INFO  time: compiled root in 0.29s
2024.03.24 12:20:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:24 INFO  compiling root (1 scala source)
2024.03.24 12:20:26 INFO  time: compiled root in 1.21s
2024.03.24 12:20:26 INFO  compiling root (1 scala source)
2024.03.24 12:20:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:27 INFO  time: compiled root in 1.12s
2024.03.24 12:20:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:20:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:21:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:21:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Mar 24, 2024 12:21:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6476
2024.03.24 12:21:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:21:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:52 INFO  compiling root (1 scala source)
2024.03.24 12:22:53 INFO  time: compiled root in 1.19s
2024.03.24 12:22:53 INFO  compiling root (1 scala source)
2024.03.24 12:22:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:22:54 INFO  time: compiled root in 1.14s
2024.03.24 12:22:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:23:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:23:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:23:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:23:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:23:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:23:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:23:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:23:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:23:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:16 INFO  compiling root (1 scala source)
2024.03.24 12:24:17 INFO  time: compiled root in 1.61s
2024.03.24 12:24:17 INFO  compiling root (1 scala source)
2024.03.24 12:24:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:19 INFO  time: compiled root in 1.22s
2024.03.24 12:24:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:28 INFO  compiling root (1 scala source)
2024.03.24 12:24:30 INFO  time: compiled root in 1.34s
2024.03.24 12:24:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:37 INFO  compiling root (1 scala source)
2024.03.24 12:24:38 INFO  time: compiled root in 1.22s
2024.03.24 12:24:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:41 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:43 INFO  compiling root (1 scala source)
2024.03.24 12:24:44 INFO  time: compiled root in 1.11s
2024.03.24 12:24:44 INFO  compiling root (1 scala source)
2024.03.24 12:24:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:45 INFO  time: compiled root in 1.01s
2024.03.24 12:24:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:57 INFO  compiling root (1 scala source)
2024.03.24 12:24:59 INFO  time: compiled root in 1.11s
2024.03.24 12:24:59 INFO  compiling root (1 scala source)
2024.03.24 12:24:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:24:59 INFO  time: compiled root in 0.89s
2024.03.24 12:25:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Mar 24, 2024 12:26:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6830
2024.03.24 12:26:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:26:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:26:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:26:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:26:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:26:55 INFO  compiling root (1 scala source)
2024.03.24 12:26:56 INFO  time: compiled root in 1.34s
2024.03.24 12:26:56 INFO  compiling root (1 scala source)
2024.03.24 12:26:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:26:57 INFO  time: compiled root in 1.06s
2024.03.24 12:26:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:20 INFO  compiling root (1 scala source)
2024.03.24 12:27:21 INFO  time: compiled root in 1.32s
2024.03.24 12:27:21 INFO  compiling root (1 scala source)
2024.03.24 12:27:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:22 INFO  time: compiled root in 1.04s
2024.03.24 12:27:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:40 INFO  compiling root (1 scala source)
2024.03.24 12:27:41 INFO  time: compiled root in 1.2s
2024.03.24 12:27:41 INFO  compiling root (1 scala source)
2024.03.24 12:27:41 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:42 INFO  time: compiled root in 0.98s
2024.03.24 12:27:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:27:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:28:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:28:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Mar 24, 2024 12:28:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7106
2024.03.24 12:28:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:28:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:28:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:28:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:31:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:02 INFO  compiling root (1 scala source)
2024.03.24 12:32:04 INFO  time: compiled root in 1.1s
2024.03.24 12:32:04 INFO  compiling root (1 scala source)
2024.03.24 12:32:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:05 INFO  time: compiled root in 1.02s
2024.03.24 12:32:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:12 INFO  compiling root (1 scala source)
2024.03.24 12:32:14 INFO  time: compiled root in 1.23s
2024.03.24 12:32:14 INFO  compiling root (1 scala source)
2024.03.24 12:32:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:14 INFO  time: compiled root in 0.95s
2024.03.24 12:32:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:32:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:33:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:33:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:33:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:33:07 INFO  compiling root (1 scala source)
2024.03.24 12:33:08 INFO  time: compiled root in 1.05s
2024.03.24 12:33:08 INFO  compiling root (1 scala source)
2024.03.24 12:33:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:33:09 INFO  time: compiled root in 1.02s
2024.03.24 12:33:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:33:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:33:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:33:50 INFO  compiling root (1 scala source)
2024.03.24 12:33:51 INFO  time: compiled root in 1.04s
2024.03.24 12:33:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:09 INFO  compiling root (1 scala source)
2024.03.24 12:34:10 INFO  time: compiled root in 1.08s
2024.03.24 12:34:10 INFO  compiling root (1 scala source)
2024.03.24 12:34:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:10 INFO  time: compiled root in 0.9s
2024.03.24 12:34:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:13 INFO  compiling root (1 scala source)
2024.03.24 12:34:13 INFO  time: compiled root in 0.82s
2024.03.24 12:34:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:25 INFO  compiling root (1 scala source)
2024.03.24 12:34:25 INFO  time: compiled root in 0.97s
2024.03.24 12:34:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:34:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:11 INFO  compiling root (1 scala source)
2024.03.24 12:35:11 INFO  time: compiled root in 0.34s
2024.03.24 12:35:11 INFO  compiling root (1 scala source)
2024.03.24 12:35:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:11 INFO  time: compiled root in 0.48s
2024.03.24 12:35:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:22 INFO  compiling root (1 scala source)
2024.03.24 12:35:22 INFO  time: compiled root in 0.46s
2024.03.24 12:35:22 INFO  compiling root (1 scala source)
2024.03.24 12:35:22 INFO  time: compiled root in 0.28s
2024.03.24 12:35:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 12:35:37 INFO  compiling root (1 scala source)
2024.03.24 12:35:37 INFO  time: compiled root in 0.95s
2024.03.24 12:38:04 INFO  compiling root (1 scala source)
2024.03.24 12:38:05 INFO  time: compiled root in 1.17s
2024.03.24 12:38:05 INFO  compiling root (1 scala source)
2024.03.24 12:38:06 INFO  time: compiled root in 1.09s
2024.03.24 12:38:36 INFO  compiling root (1 scala source)
2024.03.24 12:38:36 INFO  time: compiled root in 0.99s
2024.03.24 12:38:37 INFO  compiling root (1 scala source)
2024.03.24 12:38:38 INFO  time: compiled root in 1.03s
2024.03.24 12:38:48 INFO  compiling root (1 scala source)
2024.03.24 12:38:48 INFO  time: compiled root in 0.99s
2024.03.24 12:39:22 INFO  compiling root (1 scala source)
2024.03.24 12:39:23 INFO  time: compiled root in 1.12s
2024.03.24 12:39:23 INFO  compiling root (1 scala source)
2024.03.24 12:39:23 INFO  time: compiled root in 0.92s
2024.03.24 12:39:27 INFO  compiling root (1 scala source)
2024.03.24 12:39:27 INFO  time: compiled root in 0.79s
2024.03.24 12:39:27 INFO  compiling root (1 scala source)
2024.03.24 12:39:29 INFO  time: compiled root in 1.21s
2024.03.24 12:39:29 INFO  compiling root (1 scala source)
2024.03.24 12:39:30 INFO  time: compiled root in 1.29s
2024.03.24 12:40:28 INFO  compiling root (1 scala source)
2024.03.24 12:40:29 INFO  time: compiled root in 1.19s
2024.03.24 12:40:29 INFO  compiling root (1 scala source)
2024.03.24 12:40:29 INFO  time: compiled root in 0.91s
2024.03.24 12:40:37 INFO  compiling root (1 scala source)
2024.03.24 12:40:38 INFO  time: compiled root in 1.1s
2024.03.24 12:40:38 INFO  compiling root (1 scala source)
2024.03.24 12:40:38 INFO  time: compiled root in 0.83s
2024.03.24 12:42:52 INFO  compiling root (1 scala source)
2024.03.24 12:42:53 INFO  time: compiled root in 1.12s
2024.03.24 12:42:53 INFO  compiling root (1 scala source)
2024.03.24 12:42:53 INFO  time: compiled root in 0.94s
2024.03.24 12:43:18 INFO  compiling root (1 scala source)
2024.03.24 12:43:19 INFO  time: compiled root in 1.07s
2024.03.24 12:43:19 INFO  compiling root (1 scala source)
2024.03.24 12:43:21 INFO  time: compiled root in 0.98s
2024.03.24 12:43:25 INFO  compiling root (1 scala source)
2024.03.24 12:43:26 INFO  time: compiled root in 1.09s
2024.03.24 12:43:26 INFO  compiling root (1 scala source)
2024.03.24 12:43:26 INFO  time: compiled root in 0.94s
2024.03.24 12:43:28 INFO  compiling root (1 scala source)
2024.03.24 12:43:28 INFO  time: compiled root in 0.69s
Mar 24, 2024 12:50:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8044
2024.03.24 12:50:56 INFO  compiling root (1 scala source)
2024.03.24 12:50:56 INFO  time: compiled root in 0.7s
Mar 24, 2024 12:55:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8233
2024.03.24 13:00:03 INFO  compiling root (1 scala source)
2024.03.24 13:00:03 INFO  time: compiled root in 0.52s
2024.03.24 13:00:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Mar 24, 2024 1:00:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8679
2024.03.24 13:00:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:50 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:00:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Mar 24, 2024 1:01:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8794
2024.03.24 13:01:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:15 INFO  compiling root (1 scala source)
2024.03.24 13:01:16 INFO  time: compiled root in 1.5s
2024.03.24 13:01:16 INFO  compiling root (1 scala source)
2024.03.24 13:01:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:17 INFO  time: compiled root in 0.99s
2024.03.24 13:01:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:01:26 INFO  compiling root (1 scala source)
2024.03.24 13:01:26 INFO  time: compiled root in 0.71s
Mar 24, 2024 1:04:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9004
Mar 24, 2024 1:05:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9138
2024.03.24 13:05:23 INFO  compiling root (1 scala source)
2024.03.24 13:05:23 INFO  time: compiled root in 0.7s
Mar 24, 2024 1:06:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9230
2024.03.24 13:09:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:09:23 INFO  compiling root (1 scala source)
2024.03.24 13:09:24 INFO  time: compiled root in 1.18s
2024.03.24 13:09:24 INFO  compiling root (1 scala source)
2024.03.24 13:09:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:09:25 INFO  time: compiled root in 1s
2024.03.24 13:09:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:09:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:09:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Mar 24, 2024 1:10:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9446
2024.03.24 13:10:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:24 INFO  compiling root (1 scala source)
2024.03.24 13:10:24 INFO  time: compiled root in 0.98s
2024.03.24 13:10:25 INFO  compiling root (1 scala source)
2024.03.24 13:10:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:25 INFO  time: compiled root in 0.97s
2024.03.24 13:10:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:10:32 INFO  compiling root (1 scala source)
2024.03.24 13:10:32 INFO  time: compiled root in 0.54s
2024.03.24 13:10:39 INFO  compiling root (1 scala source)
2024.03.24 13:10:39 INFO  time: compiled root in 0.49s
Mar 24, 2024 1:10:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9607
2024.03.24 13:11:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:11:27 INFO  compiling root (1 scala source)
2024.03.24 13:11:27 INFO  time: compiled root in 0.66s
Mar 24, 2024 1:11:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9659
Mar 24, 2024 1:11:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9660
Mar 24, 2024 1:11:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9661
2024.03.24 13:11:58 INFO  compiling root (1 scala source)
2024.03.24 13:11:58 INFO  time: compiled root in 0.57s
Mar 24, 2024 1:16:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10027
2024.03.24 13:17:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:17:23 INFO  compiling root (1 scala source)
2024.03.24 13:17:23 INFO  time: compiled root in 0.4s
2024.03.24 13:17:23 INFO  compiling root (1 scala source)
2024.03.24 13:17:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:17:23 INFO  time: compiled root in 0.42s
2024.03.24 13:17:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:17:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:17:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:17:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:17:50 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:46: error: illegal character '\u00b4'
        card.layoutX = event.getSceneX - (card.getBoundsInLocal.getWidth * (event.getSceneX - card.layoutX.´)/card.getBoundsInLocal.getWidth)
                                                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Mar 24, 2024 1:17:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10331
2024.03.24 13:17:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:18:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:18:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:18:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:18:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:18:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:18:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:18:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 13:18:12 INFO  compiling root (1 scala source)
2024.03.24 13:18:12 INFO  time: compiled root in 0.56s
2024.03.24 13:19:02 INFO  compiling root (1 scala source)
2024.03.24 13:19:02 INFO  time: compiled root in 0.63s
2024.03.24 13:21:30 INFO  compiling root (1 scala source)
2024.03.24 13:21:31 INFO  time: compiled root in 1.06s
2024.03.24 13:21:31 INFO  compiling root (1 scala source)
2024.03.24 13:21:32 INFO  time: compiled root in 1.09s
2024.03.24 13:22:19 INFO  file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala:48:27: stale bloop error: Found:    scalafx.scene.input.MouseEvent => Unit
Required: javafx.event.EventHandler[? >: javafx.scene².input².MouseEvent²]

where:    MouseEvent  is a class in package scalafx.scene.input
          MouseEvent² is a class in package javafx.scene².input²
          input       is a package in package scalafx.scene
          input²      is a package in package javafx.scene²
          scene       is a package in package scalafx
          scene²      is a package in package javafx


One of the following imports might make progress towards fixing the problem:

  import scalafx.Includes.eventClosureWrapperWithParam
  import scalafx.event.EventIncludes.eventClosureWrapperWithParam


> (event: MouseEvent) => {
>       xOffset = event.sceneX - card.layoutX()
>       yOffset = event.sceneY - card.layoutY()
>     }
2024.03.24 13:22:21 INFO  compiling root (1 scala source)
2024.03.24 13:22:22 INFO  time: compiled root in 1.23s
2024.03.24 13:22:22 INFO  compiling root (1 scala source)
2024.03.24 13:22:24 INFO  time: compiled root in 1.18s
2024.03.24 13:22:26 INFO  compiling root (1 scala source)
2024.03.24 13:22:26 INFO  time: compiled root in 0.96s
2024.03.24 13:24:35 INFO  compiling root (1 scala source)
2024.03.24 13:24:36 INFO  time: compiled root in 1.59s
2024.03.24 13:24:36 INFO  compiling root (1 scala source)
2024.03.24 13:24:38 INFO  time: compiled root in 1.34s
2024.03.24 13:25:38 INFO  compiling root (1 scala source)
2024.03.24 13:25:40 INFO  time: compiled root in 1.58s
2024.03.24 13:25:40 INFO  compiling root (1 scala source)
2024.03.24 13:25:41 INFO  time: compiled root in 1.33s
2024.03.24 13:26:40 INFO  compiling root (1 scala source)
2024.03.24 13:26:40 INFO  time: compiled root in 0.63s
2024.03.24 13:26:50 INFO  compiling root (1 scala source)
2024.03.24 13:26:50 INFO  time: compiled root in 0.68s
Mar 24, 2024 2:48:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11282
Mar 24, 2024 2:48:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11289
Mar 24, 2024 2:53:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11419
Exception in thread "pool-6-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Mar 24, 2024 2:53:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11424
Mar 24, 2024 2:53:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11425
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11427
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11428
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11430
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11435
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11436
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11438
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11439
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11440
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11441
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11442
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11443
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11444
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11445
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11446
Mar 24, 2024 2:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11447
2024.03.24 14:53:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 14:53:35 INFO  compiling root (1 scala source)
2024.03.24 14:53:35 INFO  time: compiled root in 0.71s
Mar 24, 2024 2:53:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11473
Mar 24, 2024 2:53:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11489
Mar 24, 2024 2:55:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11588
2024.03.24 14:55:41 INFO  compiling root (1 scala source)
2024.03.24 14:55:41 INFO  time: compiled root in 0.65s
Mar 24, 2024 3:10:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11657
2024.03.24 15:14:29 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:45: error: unclosed character literal
        card.layoutX = event.getScreenX - (card.width.toDouble '')
                                                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 15:14:29 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:45: error: unclosed character literal
        card.layoutX = event.getScreenX - (card.width.toDouble '')
                                                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 15:14:29 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:45: error: unclosed character literal
        card.layoutX = event.getScreenX - (card.width.toDouble '')
                                                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Mar 24, 2024 3:15:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11954
2024.03.24 15:16:32 INFO  compiling root (1 scala source)
2024.03.24 15:16:32 INFO  time: compiled root in 0.39s
2024.03.24 15:16:55 INFO  compiling root (1 scala source)
2024.03.24 15:16:55 INFO  time: compiled root in 0.55s
Mar 24, 2024 3:16:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12165
Mar 24, 2024 3:17:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12178
Mar 24, 2024 3:17:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12179
2024.03.24 15:18:45 INFO  compiling root (1 scala source)
2024.03.24 15:18:46 INFO  time: compiled root in 1.52s
2024.03.24 15:18:46 INFO  compiling root (1 scala source)
2024.03.24 15:18:48 INFO  time: compiled root in 1.78s
2024.03.24 15:20:53 INFO  compiling root (1 scala source)
2024.03.24 15:20:53 INFO  time: compiled root in 0.91s
2024.03.24 15:21:14 INFO  compiling root (1 scala source)
2024.03.24 15:21:14 INFO  time: compiled root in 0.65s
2024.03.24 15:22:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 15:22:27 INFO  compiling root (1 scala source)
2024.03.24 15:22:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.24 15:22:27 INFO  time: compiled root in 0.59s
2024.03.24 15:24:18 INFO  compiling root (1 scala source)
2024.03.24 15:24:18 INFO  time: compiled root in 0.43s
2024.03.24 15:24:18 INFO  compiling root (1 scala source)
2024.03.24 15:24:18 INFO  time: compiled root in 0.31s
2024.03.24 15:24:46 INFO  compiling root (1 scala source)
2024.03.24 15:24:46 INFO  time: compiled root in 0.67s
Mar 24, 2024 3:24:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12609
Mar 24, 2024 3:24:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12614
Mar 24, 2024 3:24:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12615
Mar 24, 2024 3:25:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12625
2024.03.24 15:26:46 INFO  compiling root (1 scala source)
2024.03.24 15:26:46 INFO  time: compiled root in 0.61s
Mar 24, 2024 3:26:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12673
Mar 24, 2024 3:27:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12690
Mar 24, 2024 3:28:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12740
2024.03.24 15:28:08 INFO  compiling root (1 scala source)
2024.03.24 15:28:08 INFO  time: compiled root in 0.72s
Mar 24, 2024 3:28:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12751
2024.03.24 15:34:59 INFO  compiling root (1 scala source)
2024.03.24 15:35:00 INFO  time: compiled root in 1.33s
Mar 24, 2024 3:35:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13530
2024.03.24 15:35:16 INFO  compiling root (1 scala source)
2024.03.24 15:35:16 INFO  time: compiled root in 0.58s
Mar 24, 2024 3:37:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13652
2024.03.24 15:37:36 INFO  compiling root (1 scala source)
2024.03.24 15:37:36 INFO  time: compiled root in 0.59s
2024.03.24 15:42:59 INFO  compiling root (1 scala source)
2024.03.24 15:42:59 INFO  time: compiled root in 0.74s
Mar 24, 2024 3:44:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13920
2024.03.24 15:44:52 INFO  compiling root (1 scala source)
2024.03.24 15:44:52 INFO  time: compiled root in 0.62s
Mar 24, 2024 3:46:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13964
2024.03.24 15:47:28 INFO  compiling root (1 scala source)
2024.03.24 15:47:29 INFO  time: compiled root in 1.25s
Mar 24, 2024 3:48:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14030
Mar 24, 2024 3:52:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14093
2024.03.24 15:52:14 INFO  compiling root (1 scala source)
2024.03.24 15:52:14 INFO  time: compiled root in 0.57s
Mar 24, 2024 3:52:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14104
2024.03.24 15:53:30 INFO  compiling root (1 scala source)
2024.03.24 15:53:30 INFO  time: compiled root in 0.58s
Mar 24, 2024 5:38:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14222
2024.03.24 17:39:36 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:50: error: illegal character '\u00a7'
        card.setLayoutY((offsetY - y§))
                                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 17:39:39 INFO  compiling root (1 scala source)
2024.03.24 17:39:39 INFO  time: compiled root in 0.83s
Mar 24, 2024 5:40:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14381
2024.03.24 17:42:01 INFO  compiling root (1 scala source)
2024.03.24 17:42:01 INFO  time: compiled root in 0.58s
Mar 24, 2024 5:42:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14525
2024.03.24 17:44:27 INFO  compiling root (1 scala source)
2024.03.24 17:44:29 INFO  time: compiled root in 1.16s
Mar 24, 2024 5:45:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14647
Mar 24, 2024 5:46:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14659
Mar 24, 2024 5:46:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14660
Mar 24, 2024 5:46:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14661
Mar 24, 2024 5:49:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14810
2024.03.24 17:50:00 INFO  compiling root (1 scala source)
2024.03.24 17:50:00 INFO  time: compiled root in 0.66s
Mar 24, 2024 5:50:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14822
Mar 24, 2024 5:50:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14840
2024.03.24 17:52:29 INFO  compiling root (1 scala source)
2024.03.24 17:52:30 INFO  time: compiled root in 1.24s
2024.03.24 17:52:30 INFO  compiling root (1 scala source)
2024.03.24 17:52:31 INFO  time: compiled root in 0.98s
2024.03.24 17:52:38 INFO  compiling root (1 scala source)
2024.03.24 17:52:40 INFO  time: compiled root in 1.25s
2024.03.24 17:52:40 INFO  compiling root (1 scala source)
2024.03.24 17:52:41 INFO  time: compiled root in 1s
2024.03.24 17:53:34 INFO  compiling root (1 scala source)
2024.03.24 17:53:36 INFO  time: compiled root in 1.42s
2024.03.24 17:53:36 INFO  compiling root (1 scala source)
2024.03.24 17:53:37 INFO  time: compiled root in 0.97s
2024.03.24 17:53:37 INFO  compiling root (1 scala source)
2024.03.24 17:53:38 INFO  time: compiled root in 1.12s
2024.03.24 17:53:57 INFO  compiling root (1 scala source)
2024.03.24 17:53:58 INFO  time: compiled root in 1s
2024.03.24 17:53:58 INFO  compiling root (1 scala source)
2024.03.24 17:53:59 INFO  time: compiled root in 1.07s
2024.03.24 17:54:00 INFO  compiling root (1 scala source)
2024.03.24 17:54:00 INFO  time: compiled root in 0.87s
2024.03.24 17:54:14 INFO  compiling root (1 scala source)
2024.03.24 17:54:15 INFO  time: compiled root in 1.34s
2024.03.24 17:54:15 INFO  compiling root (1 scala source)
2024.03.24 17:54:16 INFO  time: compiled root in 1.04s
2024.03.24 17:55:29 INFO  compiling root (1 scala source)
2024.03.24 17:55:29 INFO  time: compiled root in 0.36s
2024.03.24 17:55:29 INFO  compiling root (1 scala source)
2024.03.24 17:55:31 INFO  time: compiled root in 1.57s
2024.03.24 17:55:39 INFO  compiling root (1 scala source)
2024.03.24 17:55:39 INFO  time: compiled root in 0.52s
2024.03.24 17:55:39 INFO  compiling root (1 scala source)
2024.03.24 17:55:41 INFO  time: compiled root in 0.57s
2024.03.24 17:55:48 INFO  compiling root (1 scala source)
2024.03.24 17:55:48 INFO  time: compiled root in 0.39s
2024.03.24 17:55:48 INFO  compiling root (1 scala source)
2024.03.24 17:55:48 INFO  time: compiled root in 0.29s
2024.03.24 17:55:56 INFO  compiling root (1 scala source)
2024.03.24 17:55:56 INFO  time: compiled root in 0.31s
2024.03.24 17:55:56 INFO  compiling root (1 scala source)
2024.03.24 17:55:56 INFO  time: compiled root in 0.45s
2024.03.24 17:56:07 INFO  compiling root (1 scala source)
2024.03.24 17:56:07 INFO  time: compiled root in 0.3s
2024.03.24 17:56:07 INFO  compiling root (1 scala source)
2024.03.24 17:56:07 INFO  time: compiled root in 0.33s
2024.03.24 17:56:11 INFO  compiling root (1 scala source)
2024.03.24 17:56:11 INFO  time: compiled root in 0.28s
2024.03.24 17:56:17 INFO  compiling root (1 scala source)
2024.03.24 17:56:17 INFO  time: compiled root in 0.29s
2024.03.24 17:56:57 INFO  compiling root (1 scala source)
2024.03.24 17:56:57 INFO  time: compiled root in 0.29s
2024.03.24 17:56:57 INFO  compiling root (1 scala source)
2024.03.24 17:56:57 INFO  time: compiled root in 0.28s
Mar 24, 2024 5:57:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.UnsupportedOperationException: tail of empty list
java.util.concurrent.CompletionException: java.lang.UnsupportedOperationException: tail of empty list
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.UnsupportedOperationException: tail of empty list
	at scala.collection.immutable.Nil$.tail(List.scala:664)
	at scala.collection.immutable.Nil$.tail(List.scala:661)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$endPosOfTree$1(CreateCompanionObjectCodeAction.scala:77)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.endPosOfTree(CreateCompanionObjectCodeAction.scala:75)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$5(CreateCompanionObjectCodeAction.scala:61)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$4(CreateCompanionObjectCodeAction.scala:58)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$2(CreateCompanionObjectCodeAction.scala:56)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$1(CreateCompanionObjectCodeAction.scala:55)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.03.24 17:57:04 INFO  compiling root (1 scala source)
2024.03.24 17:57:05 INFO  time: compiled root in 1.33s
2024.03.24 17:57:05 INFO  compiling root (1 scala source)
2024.03.24 17:57:06 INFO  time: compiled root in 0.98s
Mar 24, 2024 5:57:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15453
2024.03.24 17:57:33 INFO  compiling root (1 scala source)
2024.03.24 17:57:35 INFO  time: compiled root in 1.46s
2024.03.24 17:57:35 INFO  compiling root (1 scala source)
2024.03.24 17:57:36 INFO  time: compiled root in 1.19s
2024.03.24 17:58:29 INFO  compiling root (1 scala source)
2024.03.24 17:58:29 INFO  time: compiled root in 0.38s
2024.03.24 17:58:29 INFO  compiling root (1 scala source)
2024.03.24 17:58:29 INFO  time: compiled root in 0.28s
2024.03.24 17:58:33 INFO  compiling root (1 scala source)
2024.03.24 17:58:33 INFO  time: compiled root in 0.79s
Mar 24, 2024 5:58:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15735
Mar 24, 2024 6:01:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15750
2024.03.24 18:02:30 INFO  compiling root (1 scala source)
2024.03.24 18:02:31 INFO  time: compiled root in 1.18s
2024.03.24 18:02:31 INFO  compiling root (1 scala source)
2024.03.24 18:02:31 INFO  time: compiled root in 0.93s
2024.03.24 18:03:03 INFO  compiling root (1 scala source)
2024.03.24 18:03:04 INFO  time: compiled root in 1.3s
2024.03.24 18:03:04 INFO  compiling root (1 scala source)
2024.03.24 18:03:04 INFO  time: compiled root in 0.93s
2024.03.24 18:04:22 INFO  compiling root (1 scala source)
2024.03.24 18:04:23 INFO  time: compiled root in 1.49s
2024.03.24 18:04:23 INFO  compiling root (1 scala source)
2024.03.24 18:04:24 INFO  time: compiled root in 1.19s
2024.03.24 18:04:24 INFO  compiling root (1 scala source)
2024.03.24 18:04:27 INFO  time: compiled root in 1.27s
2024.03.24 18:04:51 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:66: error: illegal character '\u00a8'
      reez¨¨onMouseDragged: EventHandler[javafx.scene.input.MouseEvent] = (event: MouseEvent) => {
          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:04:51 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:66: error: illegal character '\u00a8'
      reez¨¨z¨onMouseDragged: EventHandler[javafx.scene.input.MouseEvent] = (event: MouseEvent) => {
          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:05:38 INFO  compiling root (1 scala source)
2024.03.24 18:05:40 INFO  time: compiled root in 1.61s
2024.03.24 18:05:40 INFO  compiling root (1 scala source)
2024.03.24 18:05:41 INFO  time: compiled root in 1.15s
2024.03.24 18:07:26 INFO  compiling root (1 scala source)
2024.03.24 18:07:27 INFO  time: compiled root in 1.24s
2024.03.24 18:07:27 INFO  compiling root (1 scala source)
2024.03.24 18:07:28 INFO  time: compiled root in 1.08s
2024.03.24 18:07:38 INFO  compiling root (1 scala source)
2024.03.24 18:07:39 INFO  time: compiled root in 1.24s
2024.03.24 18:07:39 INFO  compiling root (1 scala source)
2024.03.24 18:07:40 INFO  time: compiled root in 1.08s
2024.03.24 18:07:59 INFO  compiling root (1 scala source)
2024.03.24 18:08:01 INFO  time: compiled root in 1.29s
2024.03.24 18:08:01 INFO  compiling root (1 scala source)
2024.03.24 18:08:02 INFO  time: compiled root in 1.07s
2024.03.24 18:08:56 INFO  compiling root (1 scala source)
2024.03.24 18:08:57 INFO  time: compiled root in 1.37s
2024.03.24 18:08:57 INFO  compiling root (1 scala source)
2024.03.24 18:08:59 INFO  time: compiled root in 1.19s
2024.03.24 18:09:19 INFO  compiling root (1 scala source)
2024.03.24 18:09:21 INFO  time: compiled root in 1.51s
2024.03.24 18:09:21 INFO  compiling root (1 scala source)
2024.03.24 18:09:22 INFO  time: compiled root in 1.11s
2024.03.24 18:10:00 INFO  compiling root (1 scala source)
2024.03.24 18:10:01 INFO  time: compiled root in 1.35s
2024.03.24 18:10:01 INFO  compiling root (1 scala source)
2024.03.24 18:10:03 INFO  time: compiled root in 1.31s
2024.03.24 18:11:53 INFO  compiling root (1 scala source)
2024.03.24 18:11:55 INFO  time: compiled root in 1.36s
2024.03.24 18:11:55 INFO  compiling root (1 scala source)
2024.03.24 18:11:56 INFO  time: compiled root in 1.14s
2024.03.24 18:12:15 INFO  compiling root (1 scala source)
2024.03.24 18:12:16 INFO  time: compiled root in 1.17s
2024.03.24 18:12:16 INFO  compiling root (1 scala source)
2024.03.24 18:12:17 INFO  time: compiled root in 1.06s
2024.03.24 18:12:41 INFO  compiling root (1 scala source)
2024.03.24 18:12:43 INFO  time: compiled root in 1.56s
2024.03.24 18:12:43 INFO  compiling root (1 scala source)
2024.03.24 18:12:44 INFO  time: compiled root in 1.4s
Mar 24, 2024 6:12:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16628
Mar 24, 2024 6:13:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16675
2024.03.24 18:13:40 INFO  compiling root (1 scala source)
2024.03.24 18:13:40 INFO  time: compiled root in 0.72s
Mar 24, 2024 6:13:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16837
2024.03.24 18:17:04 INFO  compiling root (2 scala sources)
2024.03.24 18:17:05 INFO  time: compiled root in 1.05s
2024.03.24 18:17:05 INFO  compiling root (2 scala sources)
2024.03.24 18:17:06 INFO  time: compiled root in 1.07s
2024.03.24 18:21:27 INFO  compiling root (2 scala sources)
Mar 24, 2024 6:21:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17017
2024.03.24 18:21:30 INFO  time: compiled root in 3.56s
2024.03.24 18:21:30 INFO  compiling root (2 scala sources)
2024.03.24 18:21:35 INFO  time: compiled root in 4.7s
2024.03.24 18:23:22 INFO  compiling root (2 scala sources)
2024.03.24 18:23:25 INFO  time: compiled root in 3.23s
2024.03.24 18:23:25 INFO  compiling root (2 scala sources)
2024.03.24 18:23:28 INFO  time: compiled root in 3.49s
2024.03.24 18:23:44 INFO  compiling root (2 scala sources)
2024.03.24 18:23:47 INFO  time: compiled root in 2.75s
2024.03.24 18:23:47 INFO  compiling root (2 scala sources)
2024.03.24 18:23:49 INFO  time: compiled root in 2.02s
2024.03.24 18:23:59 INFO  compiling root (2 scala sources)
2024.03.24 18:23:59 INFO  time: compiled root in 0.9s
2024.03.24 18:24:00 INFO  compiling root (2 scala sources)
2024.03.24 18:24:00 INFO  time: compiled root in 0.86s
2024.03.24 18:24:04 INFO  compiling root (2 scala sources)
2024.03.24 18:24:06 INFO  time: compiled root in 2.36s
2024.03.24 18:24:12 INFO  compiling root (2 scala sources)
2024.03.24 18:24:13 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 18:24:13 INFO  time: compiled root in 1.87s
Mar 24, 2024 6:25:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17426
2024.03.24 18:26:43 INFO  compiling root (1 scala source)
Mar 24, 2024 6:26:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17480
2024.03.24 18:26:44 INFO  time: compiled root in 1.1s
Mar 24, 2024 6:26:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17489
2024.03.24 18:27:28 INFO  compiling root (1 scala source)
2024.03.24 18:27:30 INFO  time: compiled root in 1.41s
Mar 24, 2024 6:28:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17587
2024.03.24 18:29:55 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = s"-fx-font-weight: bold; -fx-font-size: "px"
                                                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:29:56 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = s"-fx-font-weight: bold; -fx-font-size: "repx"
                                                                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:29:56 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = s"-fx-font-weight: bold; -fx-font-size: "recpx"
                                                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:29:57 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = s"-fx-font-weight: bold; -fx-font-size: "rect.px"
                                                                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:00 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = "-fx-font-weight: bold; -fx-font-size: "rect.px"
                                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:02 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = "-fx-font-weight: bold; -fx-font-size: " + rect.px"
                                                                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:06 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = "-fx-font-weight: bold; -fx-font-size: " + rect.wipx"
                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Mar 24, 2024 6:30:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17721
2024.03.24 18:30:06 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = "-fx-font-weight: bold; -fx-font-size: " + rect.widpx"
                                                                            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:07 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = "-fx-font-weight: bold; -fx-font-size: " + rect.widthpx"
                                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:08 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = "-fx-font-weight: bold; -fx-font-size: " + rect.width *px"
                                                                                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:09 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = "-fx-font-weight: bold; -fx-font-size: " + rect.width * px"
                                                                                 ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:12 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: unclosed string interpolation
    nameLabel.style = "-fx-font-weight: bold; -fx-font-size: " + rect.width * 0.px"
                                                                                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:12 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:33: error: Invalid literal number
    nameLabel.style = "-fx-font-weight: bold; -fx-font-size: " + rect.width * 0.1px"
                                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.getFraction(LegacyScanner.scala:814)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfNumber$1(LegacyScanner.scala:844)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:904)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:30 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: Invalid literal number
    valueLabel.style = "-fx-font-size: "100px"
                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:31 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: Invalid literal number
    valueLabel.style = "-fx-font-size: " + 100px"
                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:32 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: unclosed string interpolation
    valueLabel.style = "-fx-font-size: " + rec100px"
                                                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:32 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: unclosed string interpolation
    valueLabel.style = "-fx-font-size: " + rect100px"
                                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:33 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: unclosed string interpolation
    valueLabel.style = "-fx-font-size: " + rect.w100px"
                                                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:34 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: unclosed string interpolation
    valueLabel.style = "-fx-font-size: " + rect.wo100px"
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:34 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: unclosed string interpolation
    valueLabel.style = "-fx-font-size: " + rect.wid100px"
                                                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:34 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: unclosed string interpolation
    valueLabel.style = "-fx-font-size: " + rect.widthe100px"
                                                            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:36 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: unclosed string interpolation
    valueLabel.style = "-fx-font-size: " + rect.width100px"
                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:40 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: Invalid literal number
    valueLabel.style = "-fx-font-size: " + rect.width * 100px"
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:41 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: Invalid literal number
    valueLabel.style = "-fx-font-size: " + rect.width * 0.2100px"
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.getFraction(LegacyScanner.scala:814)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfNumber$1(LegacyScanner.scala:844)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:904)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:41 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: Invalid literal number
    valueLabel.style = "-fx-font-size: " + rect.width * 0.3100px"
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.getFraction(LegacyScanner.scala:814)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfNumber$1(LegacyScanner.scala:844)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:904)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:44 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: Invalid literal number
    valueLabel.style = "-fx-font-size: " + rect.width * 0.3 100px"
                                                            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:30:49 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: illegal character '\u00b4'
    valueLabel.style = "-fx-font-size: " + rect.width * 0.3 ´"100px"
                                                            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Mar 24, 2024 6:30:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17908
2024.03.24 18:30:58 INFO  compiling root (1 scala source)
2024.03.24 18:30:58 INFO  time: compiled root in 0.81s
Mar 24, 2024 6:31:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17927
Mar 24, 2024 6:31:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17940
2024.03.24 18:33:19 INFO  compiling root (1 scala source)
2024.03.24 18:33:19 INFO  time: compiled root in 0.65s
Mar 24, 2024 6:33:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17982
Mar 24, 2024 6:34:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18022
2024.03.24 18:34:34 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:82: error: illegal character '\u00a7'
    §valueLabel.style = "-fx-font-size: " + rect.width * 0.3 + "px"
    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:34:35 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:82: error: illegal character '\u00a7'
    §§§valueLabel.style = "-fx-font-size: " + rect.width * 0.3 + "px"
    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:34:46 INFO  compiling root (1 scala source)
2024.03.24 18:34:46 INFO  time: compiled root in 0.79s
Mar 24, 2024 6:34:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18119
Mar 24, 2024 6:34:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18132
Mar 24, 2024 6:38:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18595
2024.03.24 18:38:44 INFO  compiling root (1 scala source)
2024.03.24 18:38:44 INFO  time: compiled root in 0.67s
Mar 24, 2024 6:40:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18730
2024.03.24 18:40:22 INFO  compiling root (1 scala source)
2024.03.24 18:40:22 INFO  time: compiled root in 0.63s
2024.03.24 18:42:44 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.24 18:42:44 INFO  compiling root (1 scala source)
2024.03.24 18:42:44 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.24 18:42:44 INFO  Starting debug proxy for [Dashboard]
2024.03.24 18:42:44 INFO  Loaded expression compiler in 18 milliseconds
2024.03.24 18:42:44 INFO  Loaded step filter in 0 milliseconds
2024.03.24 18:42:44 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.24 18:42:45 INFO  time: compiled root in 1.74s
2024.03.24 18:42:48 INFO  Loaded all sources and classes in 3 seconds
2024.03.24 18:42:49 INFO  Trying to attach to remote debuggee VM localhost:52460 .
2024.03.24 18:42:49 INFO  Attaching to debuggee VM succeeded.
2024.03.24 18:45:50 INFO  compiling root (1 scala source)
2024.03.24 18:45:51 INFO  time: compiled root in 1.66s
Mar 24, 2024 6:46:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19047
2024.03.24 18:46:48 INFO  compiling root (1 scala source)
2024.03.24 18:46:48 INFO  time: compiled root in 0.47s
2024.03.24 18:47:04 INFO  compiling root (1 scala source)
2024.03.24 18:47:07 INFO  time: compiled root in 2.7s
2024.03.24 18:47:09 INFO  Canceling debug proxy for [Dashboard]
2024.03.24 18:47:09 INFO  Closing debug server tcp://0.0.0.0:52457
Mar 24, 2024 6:49:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19225
2024.03.24 18:49:54 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 8h 47m 27.338s)
2024.03.24 18:49:55 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.24 18:49:54 INFO  compiling root (1 scala source)
2024.03.24 18:49:55 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.24 18:49:55 INFO  Starting debug proxy for [Dashboard]
2024.03.24 18:49:54 INFO  Loaded expression compiler in 16 milliseconds
2024.03.24 18:49:54 INFO  Loaded step filter in 0 milliseconds
2024.03.24 18:49:54 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.24 18:49:57 INFO  time: compiled root in 1.94s
2024.03.24 18:49:58 INFO  Loaded all sources and classes in 3 seconds
2024.03.24 18:50:00 INFO  Trying to attach to remote debuggee VM localhost:52539 .
2024.03.24 18:50:00 INFO  Attaching to debuggee VM succeeded.
2024.03.24 18:53:46 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:90: error: illegal character '\u2026'
    resizableCard….
                 ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.24 18:54:16 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 8h 51m 48.952s)
2024.03.24 18:54:16 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.24 18:54:16 INFO  compiling root (1 scala source)
2024.03.24 18:54:16 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.24 18:54:16 INFO  Starting debug proxy for [Dashboard]
2024.03.24 18:54:16 INFO  Loaded expression compiler in 2 milliseconds
2024.03.24 18:54:16 INFO  Loaded step filter in 0 milliseconds
2024.03.24 18:54:16 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.24 18:54:20 INFO  time: compiled root in 3.32s
2024.03.24 18:54:20 INFO  Loaded all sources and classes in 3 seconds
2024.03.24 18:54:21 INFO  Trying to attach to remote debuggee VM localhost:52576 .
2024.03.24 18:54:21 INFO  Attaching to debuggee VM succeeded.
2024.03.24 18:54:52 INFO  Closing debug server tcp://0.0.0.0:52537
2024.03.24 18:54:52 INFO  Canceling debug proxy for [Dashboard]
2024.03.24 18:54:53 INFO  Canceling debug proxy for [Dashboard]
2024.03.24 18:54:53 INFO  Closing debug server tcp://0.0.0.0:52573
2024.03.24 18:54:57 INFO  compiling root (1 scala source)
2024.03.24 18:54:59 INFO  time: compiled root in 1.28s
2024.03.24 18:55:16 INFO  compiling root (1 scala source)
2024.03.24 18:55:16 INFO  time: compiled root in 0.8s
Mar 24, 2024 6:55:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19793
2024.03.24 18:56:01 INFO  compiling root (1 scala source)
2024.03.24 18:56:02 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.24 18:56:02 INFO  time: compiled root in 1.26s
2024.03.24 18:56:15 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 8h 53m 48.4s)
2024.03.24 18:56:16 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.24 18:56:16 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.24 18:56:16 INFO  Starting debug proxy for [Dashboard]
2024.03.24 18:56:15 INFO  Loaded expression compiler in 6 milliseconds
2024.03.24 18:56:15 INFO  Loaded step filter in 0 milliseconds
2024.03.24 18:56:15 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.24 18:56:19 INFO  Loaded all sources and classes in 3 seconds
2024.03.24 18:56:20 INFO  Trying to attach to remote debuggee VM localhost:52596 .
2024.03.24 18:56:20 INFO  Attaching to debuggee VM succeeded.
Mar 24, 2024 6:57:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19891
2024.03.25 10:17:48 INFO  Canceling debug proxy for [Dashboard]
2024.03.25 10:17:48 INFO  Closing debug server tcp://0.0.0.0:52593
2024.03.25 10:19:50 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:19:50 INFO  compiling root (1 scala source)
2024.03.25 10:19:52 INFO  time: compiled root in 1.1s
2024.03.25 10:19:52 INFO  compiling root (1 scala source)
2024.03.25 10:19:52 INFO  time: compiled root in 0.33s
2024.03.25 10:19:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:34 INFO  compiling root (1 scala source)
2024.03.25 10:20:34 INFO  time: compiled root in 0.38s
2024.03.25 10:20:34 INFO  compiling root (1 scala source)
2024.03.25 10:20:34 INFO  time: compiled root in 0.45s
2024.03.25 10:20:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 10:20:39 INFO  compiling root (1 scala source)
2024.03.25 10:20:39 INFO  time: compiled root in 0.91s
Mar 25, 2024 10:20:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20362
Mar 25, 2024 10:20:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20374
Mar 25, 2024 10:20:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20375
2024.03.25 10:24:52 INFO  compiling root (1 scala source)
2024.03.25 10:24:52 INFO  time: compiled root in 0.95s
2024.03.25 13:59:24 INFO  compiling root (1 scala source)
2024.03.25 13:59:25 INFO  time: compiled root in 1.46s
2024.03.25 14:08:39 INFO  compiling root (1 scala source)
2024.03.25 14:08:39 INFO  time: compiled root in 0.59s
2024.03.25 14:08:39 INFO  compiling root (1 scala source)
2024.03.25 14:08:40 INFO  time: compiled root in 0.39s
2024.03.25 14:09:07 INFO  compiling root (1 scala source)
2024.03.25 14:09:07 INFO  time: compiled root in 0.56s
Mar 25, 2024 2:09:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20570
Mar 25, 2024 2:09:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20571
2024.03.25 14:10:42 INFO  compiling root (1 scala source)
2024.03.25 14:10:42 INFO  time: compiled root in 0.54s
Mar 25, 2024 2:10:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20734
Mar 25, 2024 2:48:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20831
2024.03.25 14:49:27 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:64: error: illegal character '\u00b4'
´
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.25 14:49:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:31 INFO  compiling root (1 scala source)
2024.03.25 14:49:31 INFO  time: compiled root in 0.44s
2024.03.25 14:49:31 INFO  compiling root (1 scala source)
2024.03.25 14:49:31 INFO  time: compiled root in 0.27s
2024.03.25 14:49:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:41 INFO  compiling root (1 scala source)
2024.03.25 14:49:43 INFO  time: compiled root in 1.47s
2024.03.25 14:49:43 INFO  compiling root (1 scala source)
2024.03.25 14:49:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:43 INFO  time: compiled root in 0.89s
2024.03.25 14:49:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:49:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:50:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:50:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:50:18 INFO  compiling root (1 scala source)
2024.03.25 14:50:18 INFO  time: compiled root in 0.27s
2024.03.25 14:50:18 INFO  compiling root (1 scala source)
2024.03.25 14:50:18 INFO  time: compiled root in 0.2s
2024.03.25 14:50:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:50:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:50:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:23 INFO  compiling root (1 scala source)
2024.03.25 14:51:24 INFO  time: compiled root in 1.12s
2024.03.25 14:51:24 INFO  compiling root (1 scala source)
2024.03.25 14:51:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:25 INFO  time: compiled root in 0.96s
2024.03.25 14:51:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 14:51:39 INFO  compiling root (1 scala source)
2024.03.25 14:51:39 INFO  time: compiled root in 0.62s
Mar 25, 2024 2:51:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21087
Mar 25, 2024 2:51:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21099
2024.03.25 14:53:47 INFO  compiling root (1 scala source)
2024.03.25 14:53:48 INFO  time: compiled root in 1.18s
2024.03.25 14:53:48 INFO  compiling root (1 scala source)
2024.03.25 14:53:49 INFO  time: compiled root in 0.96s
2024.03.25 14:53:58 INFO  compiling root (1 scala source)
2024.03.25 14:53:58 INFO  time: compiled root in 0.93s
2024.03.25 14:53:58 INFO  compiling root (1 scala source)
2024.03.25 14:54:00 INFO  time: compiled root in 0.84s
2024.03.25 14:54:40 INFO  compiling root (1 scala source)
2024.03.25 14:54:40 INFO  time: compiled root in 0.72s
2024.03.25 14:57:27 INFO  compiling root (1 scala source)
2024.03.25 14:57:27 INFO  time: compiled root in 0.57s
2024.03.25 15:02:37 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:55: error: unclosed string literal
      println(")
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.25 15:02:47 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 29h 19.859s)
2024.03.25 15:02:47 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.25 15:02:47 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.25 15:02:47 INFO  Starting debug proxy for [Dashboard]
2024.03.25 15:02:47 INFO  compiling root (1 scala source)
2024.03.25 15:02:47 INFO  Loaded expression compiler in 37 milliseconds
2024.03.25 15:02:47 INFO  Loaded step filter in 0 milliseconds
2024.03.25 15:02:47 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.25 15:02:50 INFO  time: compiled root in 2.63s
2024.03.25 15:02:51 INFO  Loaded all sources and classes in 3 seconds
2024.03.25 15:02:51 INFO  Trying to attach to remote debuggee VM localhost:59372 .
2024.03.25 15:02:51 INFO  Attaching to debuggee VM succeeded.
2024.03.25 15:06:16 INFO  Closing debug server tcp://0.0.0.0:59369
2024.03.25 15:06:16 INFO  Canceling debug proxy for [Dashboard]
2024.03.25 15:06:19 INFO  compiling root (1 scala source)
2024.03.25 15:06:19 INFO  time: compiled root in 0.93s
2024.03.25 15:11:06 INFO  compiling root (1 scala source)
2024.03.25 15:11:08 INFO  time: compiled root in 1.42s
2024.03.25 15:11:08 INFO  compiling root (1 scala source)
2024.03.25 15:11:08 INFO  time: compiled root in 0.75s
Mar 25, 2024 3:12:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.UnsupportedOperationException: tail of empty list
java.util.concurrent.CompletionException: java.lang.UnsupportedOperationException: tail of empty list
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.UnsupportedOperationException: tail of empty list
	at scala.collection.immutable.Nil$.tail(List.scala:664)
	at scala.collection.immutable.Nil$.tail(List.scala:661)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$endPosOfTree$1(CreateCompanionObjectCodeAction.scala:77)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.endPosOfTree(CreateCompanionObjectCodeAction.scala:75)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$5(CreateCompanionObjectCodeAction.scala:61)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$4(CreateCompanionObjectCodeAction.scala:58)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$2(CreateCompanionObjectCodeAction.scala:56)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$1(CreateCompanionObjectCodeAction.scala:55)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.03.25 15:12:53 INFO  compiling root (1 scala source)
2024.03.25 15:12:53 INFO  time: compiled root in 0.88s
2024.03.25 15:12:53 INFO  compiling root (1 scala source)
2024.03.25 15:12:55 INFO  time: compiled root in 0.85s
2024.03.25 15:13:10 INFO  compiling root (1 scala source)
2024.03.25 15:13:10 INFO  time: compiled root in 0.9s
2024.03.25 15:13:10 INFO  compiling root (1 scala source)
2024.03.25 15:13:12 INFO  time: compiled root in 0.89s
Mar 25, 2024 3:13:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22228
Mar 25, 2024 3:15:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22359
2024.03.25 15:15:38 INFO  compiling root (1 scala source)
2024.03.25 15:15:38 INFO  time: compiled root in 0.28s
2024.03.25 15:15:38 INFO  compiling root (1 scala source)
2024.03.25 15:15:38 INFO  time: compiled root in 0.32s
2024.03.25 15:15:50 INFO  compiling root (1 scala source)
2024.03.25 15:15:50 INFO  time: compiled root in 0.52s
Mar 25, 2024 3:15:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22446
Mar 25, 2024 3:15:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22458
Mar 25, 2024 3:17:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22695
2024.03.25 15:17:23 INFO  compiling root (1 scala source)
2024.03.25 15:17:23 INFO  time: compiled root in 0.64s
2024.03.25 15:18:26 INFO  compiling root (1 scala source)
2024.03.25 15:18:27 INFO  time: compiled root in 1.3s
2024.03.25 15:19:39 INFO  compiling root (1 scala source)
2024.03.25 15:19:39 INFO  time: compiled root in 0.45s
2024.03.25 15:21:11 INFO  compiling root (1 scala source)
2024.03.25 15:21:11 INFO  time: compiled root in 0.45s
2024.03.25 15:22:44 INFO  compiling root (1 scala source)
2024.03.25 15:22:44 INFO  time: compiled root in 0.51s
Mar 25, 2024 3:22:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23217
Mar 25, 2024 3:22:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23226
2024.03.25 15:24:28 INFO  compiling root (1 scala source)
2024.03.25 15:24:28 INFO  time: compiled root in 0.28s
2024.03.25 15:24:28 INFO  compiling root (1 scala source)
2024.03.25 15:24:28 INFO  time: compiled root in 0.25s
Mar 25, 2024 3:24:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23306
2024.03.25 15:24:57 INFO  compiling root (1 scala source)
2024.03.25 15:24:57 INFO  time: compiled root in 0.49s
Mar 25, 2024 3:25:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23402
Mar 25, 2024 3:25:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23441
2024.03.25 15:25:16 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.25 15:25:16 INFO  compiling root (1 scala source)
2024.03.25 15:25:16 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.25 15:25:16 INFO  Starting debug proxy for [Dashboard]
2024.03.25 15:25:16 INFO  Loaded expression compiler in 6 milliseconds
2024.03.25 15:25:16 INFO  Loaded step filter in 0 milliseconds
2024.03.25 15:25:16 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.25 15:25:16 INFO  time: compiled root in 0.92s
2024.03.25 15:25:18 INFO  Loaded all sources and classes in 2 seconds
2024.03.25 15:25:20 INFO  Canceling debug proxy for [Dashboard]
2024.03.25 15:25:20 INFO  Closing debug server tcp://0.0.0.0:59753
2024.03.25 15:26:52 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 29h 24m 25.17s)
2024.03.25 15:26:52 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.25 15:26:52 INFO  compiling root (1 scala source)
2024.03.25 15:26:52 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.25 15:26:52 INFO  Starting debug proxy for [Dashboard]
2024.03.25 15:26:52 INFO  Loaded expression compiler in 6 milliseconds
2024.03.25 15:26:52 INFO  Loaded step filter in 0 milliseconds
2024.03.25 15:26:52 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.25 15:26:54 INFO  time: compiled root in 1.51s
2024.03.25 15:26:54 INFO  Loaded all sources and classes in 2 seconds
2024.03.25 15:26:55 INFO  Trying to attach to remote debuggee VM localhost:59783 .
2024.03.25 15:26:55 INFO  Attaching to debuggee VM succeeded.
2024.03.25 15:27:40 INFO  Closing debug server tcp://0.0.0.0:59779
2024.03.25 15:27:40 INFO  Canceling debug proxy for [Dashboard]
2024.03.25 15:28:21 INFO  compiling root (1 scala source)
2024.03.25 15:28:21 INFO  time: compiled root in 0.41s
2024.03.25 15:29:19 INFO  compiling root (1 scala source)
2024.03.25 15:29:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 15:29:19 INFO  time: compiled root in 0.46s
2024.03.25 15:30:21 INFO  compiling root (1 scala source)
2024.03.25 15:30:22 INFO  time: compiled root in 1.12s
2024.03.25 15:32:40 INFO  compiling root (1 scala source)
2024.03.25 15:32:40 INFO  time: compiled root in 0.98s
2024.03.25 15:40:23 INFO  compiling root (1 scala source)
2024.03.25 15:40:23 INFO  time: compiled root in 0.86s
2024.03.25 15:40:23 INFO  compiling root (1 scala source)
2024.03.25 15:40:25 INFO  time: compiled root in 1.1s
2024.03.25 15:40:28 INFO  compiling root (1 scala source)
2024.03.25 15:40:28 INFO  time: compiled root in 0.69s
2024.03.25 15:40:46 INFO  compiling root (1 scala source)
2024.03.25 15:40:46 INFO  time: compiled root in 0.56s
2024.03.25 15:40:56 INFO  compiling root (1 scala source)
2024.03.25 15:40:56 INFO  time: compiled root in 0.44s
2024.03.25 15:41:00 INFO  compiling root (1 scala source)
2024.03.25 15:41:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 15:41:00 INFO  time: compiled root in 0.48s
2024.03.25 15:42:37 INFO  compiling root (1 scala source)
2024.03.25 15:42:37 INFO  time: compiled root in 0.48s
2024.03.25 15:43:32 INFO  compiling root (1 scala source)
2024.03.25 15:43:32 INFO  time: compiled root in 0.51s
2024.03.25 15:44:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 15:44:57 INFO  compiling root (1 scala source)
2024.03.25 15:44:57 INFO  time: compiled root in 0.5s
2024.03.25 15:46:06 INFO  compiling root (1 scala source)
2024.03.25 15:46:06 INFO  time: compiled root in 0.52s
2024.03.25 15:48:48 INFO  compiling root (1 scala source)
2024.03.25 15:48:48 INFO  time: compiled root in 0.71s
2024.03.25 15:50:10 INFO  compiling root (1 scala source)
2024.03.25 15:50:10 INFO  time: compiled root in 0.47s
2024.03.25 15:50:10 INFO  compiling root (1 scala source)
2024.03.25 15:50:10 INFO  time: compiled root in 0.23s
2024.03.25 15:50:22 INFO  compiling root (1 scala source)
2024.03.25 15:50:22 INFO  time: compiled root in 0.63s
Mar 25, 2024 3:50:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 24564
Mar 25, 2024 3:50:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 24576
Mar 25, 2024 4:00:23 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.03.25 16:00:37 INFO  compiling root (1 scala source)
2024.03.25 16:00:37 INFO  time: compiled root in 0.37s
2024.03.25 16:02:14 INFO  compiling root (1 scala source)
2024.03.25 16:02:14 INFO  time: compiled root in 0.36s
2024.03.25 16:02:14 INFO  compiling root (1 scala source)
2024.03.25 16:02:14 INFO  time: compiled root in 0.24s
Mar 25, 2024 4:02:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25153
Mar 25, 2024 4:05:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25262
2024.03.25 16:05:18 INFO  compiling root (1 scala source)
2024.03.25 16:05:18 INFO  time: compiled root in 0.67s
2024.03.25 16:05:23 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 30h 2m 56.047s)
2024.03.25 16:05:23 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.25 16:05:23 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.25 16:05:24 INFO  Starting debug proxy for [Dashboard]
2024.03.25 16:05:23 INFO  Loaded expression compiler in 7 milliseconds
2024.03.25 16:05:23 INFO  Loaded step filter in 0 milliseconds
2024.03.25 16:05:23 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.25 16:05:26 INFO  Loaded all sources and classes in 2 seconds
2024.03.25 16:05:26 INFO  Trying to attach to remote debuggee VM localhost:60133 .
2024.03.25 16:05:26 INFO  Attaching to debuggee VM succeeded.
2024.03.25 16:05:53 INFO  Canceling debug proxy for [Dashboard]
2024.03.25 16:05:53 INFO  Closing debug server tcp://0.0.0.0:60130
2024.03.25 16:08:00 INFO  compiling root (1 scala source)
2024.03.25 16:08:00 INFO  time: compiled root in 0.57s
2024.03.25 16:12:16 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:37: error: Invalid literal number
    valueLabel.style = ("-fx-font-size: "100px")
                                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Mar 25, 2024 4:13:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25556
2024.03.25 16:13:20 INFO  compiling root (1 scala source)
2024.03.25 16:13:20 INFO  time: compiled root in 0.44s
Mar 25, 2024 4:13:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25605
Mar 25, 2024 4:15:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25833
Mar 25, 2024 4:15:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25978
Mar 25, 2024 4:15:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26024
2024.03.25 16:16:02 INFO  compiling root (1 scala source)
2024.03.25 16:16:02 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 30h 13m 35.261s)
2024.03.25 16:16:02 INFO  compiling root (1 scala source)
2024.03.25 16:16:04 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.25 16:16:04 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.25 16:16:04 INFO  time: compiled root in 1.84s
2024.03.25 16:16:04 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.25 16:16:04 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.25 16:16:04 INFO  Starting debug proxy for [Dashboard]
2024.03.25 16:16:04 INFO  Loaded expression compiler in 1 millisecond
2024.03.25 16:16:04 INFO  Loaded step filter in 0 milliseconds
2024.03.25 16:16:04 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.25 16:16:08 INFO  Loaded all sources and classes in 3 seconds
2024.03.25 16:16:08 INFO  Trying to attach to remote debuggee VM localhost:60232 .
2024.03.25 16:16:08 INFO  Attaching to debuggee VM succeeded.
2024.03.25 16:17:02 INFO  Canceling debug proxy for [Dashboard]
2024.03.25 16:17:02 INFO  Closing debug server tcp://0.0.0.0:60230
Mar 25, 2024 4:17:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26133
Mar 25, 2024 4:18:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26182
Mar 25, 2024 4:20:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26321
Mar 25, 2024 4:21:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26329
Mar 25, 2024 4:22:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26465
Mar 25, 2024 4:22:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26489
2024.03.25 16:22:16 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 30h 19m 48.81s)
2024.03.25 16:22:16 INFO  compiling root (1 scala source)
2024.03.25 16:22:16 INFO  compiling root (1 scala source)
2024.03.25 16:22:18 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.25 16:22:18 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.25 16:22:18 INFO  time: compiled root in 1.81s
2024.03.25 16:22:18 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.03.25 16:22:18 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.03.25 16:22:18 INFO  Starting debug proxy for [Dashboard]
2024.03.25 16:22:18 INFO  Loaded expression compiler in 8 milliseconds
2024.03.25 16:22:18 INFO  Loaded step filter in 0 milliseconds
2024.03.25 16:22:18 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.03.25 16:22:21 INFO  Loaded all sources and classes in 2 seconds
2024.03.25 16:22:22 INFO  Trying to attach to remote debuggee VM localhost:60287 .
2024.03.25 16:22:22 INFO  Attaching to debuggee VM succeeded.
Mar 25, 2024 4:23:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26518
2024.03.25 16:23:42 INFO  Canceling debug proxy for [Dashboard]
2024.03.25 16:23:42 INFO  Closing debug server tcp://0.0.0.0:60284
Mar 25, 2024 4:37:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26572
Mar 25, 2024 4:43:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26676
2024.03.25 16:45:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:45:21 INFO  compiling root (1 scala source)
2024.03.25 16:45:24 INFO  time: compiled root in 2.52s
2024.03.25 16:45:24 INFO  compiling root (1 scala source)
2024.03.25 16:45:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:45:26 INFO  time: compiled root in 1.99s
2024.03.25 16:45:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:45:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:31 INFO  compiling root (1 scala source)
2024.03.25 16:46:33 INFO  time: compiled root in 1.48s
2024.03.25 16:46:33 INFO  compiling root (1 scala source)
2024.03.25 16:46:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:34 INFO  time: compiled root in 1.22s
2024.03.25 16:46:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:42 INFO  compiling root (1 scala source)
2024.03.25 16:46:43 INFO  time: compiled root in 1.16s
2024.03.25 16:46:43 INFO  compiling root (1 scala source)
2024.03.25 16:46:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:46:44 INFO  time: compiled root in 1.31s
2024.03.25 16:46:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:47:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:47:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:47:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:47:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:47:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:47:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:47:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:47:44 INFO  compiling root (1 scala source)
2024.03.25 16:47:45 INFO  time: compiled root in 1.21s
2024.03.25 16:47:45 INFO  compiling root (1 scala source)
2024.03.25 16:47:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:47:46 INFO  time: compiled root in 1.08s
2024.03.25 16:47:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:48:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:48:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:48:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:07 INFO  compiling root (1 scala source)
2024.03.25 16:49:08 INFO  time: compiled root in 1.19s
2024.03.25 16:49:08 INFO  compiling root (1 scala source)
2024.03.25 16:49:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:09 INFO  time: compiled root in 1.07s
2024.03.25 16:49:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:24 INFO  compiling root (1 scala source)
2024.03.25 16:49:26 INFO  time: compiled root in 1.51s
2024.03.25 16:49:26 INFO  compiling root (1 scala source)
2024.03.25 16:49:27 INFO  time: compiled root in 1.34s
2024.03.25 16:49:27 INFO  compiling root (1 scala source)
2024.03.25 16:49:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:27 INFO  time: compiled root in 0.75s
2024.03.25 16:49:27 INFO  compiling root (1 scala source)
2024.03.25 16:49:29 INFO  time: compiled root in 0.85s
2024.03.25 16:49:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:51 INFO  compiling root (1 scala source)
2024.03.25 16:49:51 INFO  time: compiled root in 0.43s
2024.03.25 16:49:51 INFO  compiling root (1 scala source)
2024.03.25 16:49:51 INFO  time: compiled root in 0.36s
2024.03.25 16:49:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:49:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:50:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:50:04 INFO  compiling root (1 scala source)
2024.03.25 16:50:04 INFO  time: compiled root in 0.48s
2024.03.25 16:50:04 INFO  compiling root (1 scala source)
2024.03.25 16:50:04 INFO  time: compiled root in 0.36s
2024.03.25 16:50:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:50:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:50:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:50:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:50:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 16:50:12 INFO  compiling root (1 scala source)
2024.03.25 16:50:12 INFO  time: compiled root in 0.72s
2024.03.25 17:06:20 INFO  compiling root (1 scala source)
2024.03.25 17:06:20 INFO  time: compiled root in 0.8s
2024.03.25 17:11:34 INFO  compiling root (1 scala source)
2024.03.25 17:11:34 INFO  time: compiled root in 0.83s
2024.03.25 17:13:24 INFO  compiling root (1 scala source)
2024.03.25 17:13:24 INFO  time: compiled root in 0.68s
2024.03.25 17:14:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 17:14:51 INFO  compiling root (1 scala source)
2024.03.25 17:14:51 INFO  time: compiled root in 0.78s
Mar 25, 2024 5:16:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27808
2024.03.25 17:17:33 INFO  compiling root (2 scala sources)
2024.03.25 17:17:34 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 31h 15m 7.123s)
2024.03.25 17:17:34 INFO  compiling root (2 scala sources)
2024.03.25 17:17:34 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.25 17:17:34 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.25 17:17:34 INFO  time: compiled root in 0.91s
Mar 25, 2024 5:18:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27902
2024.03.25 17:18:14 INFO  compiling root (1 scala source)
2024.03.25 17:18:15 INFO  time: compiled root in 1.11s
2024.03.25 17:19:50 INFO  compiling root (1 scala source)
2024.03.25 17:19:50 INFO  time: compiled root in 0.76s
2024.03.25 17:22:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.03.25 17:22:17 INFO  compiling root (1 scala source)
Mar 25, 2024 5:22:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28140
2024.03.25 17:22:17 INFO  time: compiled root in 0.79s
2024.03.25 17:30:41 INFO  compiling root (1 scala source)
2024.03.25 17:30:41 INFO  time: compiled root in 0.69s
Mar 25, 2024 5:30:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28389
Mar 25, 2024 5:30:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28390
2024.03.25 17:32:20 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:55: error: unclosed character literal
      println(rect.layoutX.toDouble)''
                                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Mar 25, 2024 5:32:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28447
2024.03.25 17:32:35 INFO  compiling root (1 scala source)
2024.03.25 17:32:35 INFO  time: compiled root in 0.64s
2024.03.25 18:04:20 INFO  compiling root (1 scala source)
2024.03.25 18:04:20 INFO  time: compiled root in 0.68s
2024.03.25 18:04:20 INFO  compiling root (1 scala source)
2024.03.25 18:04:22 INFO  time: compiled root in 0.76s
2024.03.25 18:04:28 INFO  compiling root (1 scala source)
2024.03.25 18:04:29 INFO  time: compiled root in 1.3s
2024.03.25 18:04:29 INFO  compiling root (1 scala source)
2024.03.25 18:04:30 INFO  time: compiled root in 1.01s
2024.03.25 18:04:30 INFO  compiling root (1 scala source)
2024.03.25 18:04:32 INFO  time: compiled root in 1.15s
2024.03.25 18:04:46 INFO  compiling root (1 scala source)
2024.03.25 18:04:48 INFO  time: compiled root in 1.11s
2024.03.25 18:04:48 INFO  compiling root (1 scala source)
2024.03.25 18:04:49 INFO  time: compiled root in 1.11s
2024.03.25 18:05:00 INFO  compiling root (1 scala source)
2024.03.25 18:05:02 INFO  time: compiled root in 1.1s
2024.03.25 18:05:02 INFO  compiling root (1 scala source)
2024.03.25 18:05:03 INFO  time: compiled root in 1.11s
2024.03.25 18:05:13 INFO  compiling root (1 scala source)
2024.03.25 18:05:14 INFO  time: compiled root in 1.29s
2024.03.25 18:05:14 INFO  compiling root (1 scala source)
2024.03.25 18:05:15 INFO  time: compiled root in 1.12s
2024.03.25 18:05:19 INFO  compiling root (1 scala source)
2024.03.25 18:05:20 INFO  time: compiled root in 1.12s
2024.03.25 18:05:20 INFO  compiling root (1 scala source)
2024.03.25 18:05:21 INFO  time: compiled root in 1.25s
2024.03.25 18:05:21 INFO  compiling root (1 scala source)
2024.03.25 18:05:22 INFO  time: compiled root in 1.19s
2024.03.25 18:06:01 INFO  compiling root (1 scala source)
2024.03.25 18:06:03 INFO  time: compiled root in 1.25s
2024.03.25 18:06:03 INFO  compiling root (1 scala source)
2024.03.25 18:06:04 INFO  time: compiled root in 1.35s
2024.03.25 18:06:39 INFO  compiling root (1 scala source)
2024.03.25 18:06:40 INFO  time: compiled root in 1.28s
2024.03.25 18:06:40 INFO  compiling root (1 scala source)
2024.03.25 18:06:42 INFO  time: compiled root in 1.36s
2024.03.25 18:06:42 INFO  compiling root (1 scala source)
2024.03.25 18:06:43 INFO  time: compiled root in 0.93s
2024.03.25 18:07:11 INFO  compiling root (1 scala source)
2024.03.25 18:07:13 INFO  time: compiled root in 1.16s
2024.03.25 18:07:13 INFO  compiling root (1 scala source)
2024.03.25 18:07:14 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.25 18:07:14 INFO  time: compiled root in 1.22s
Mar 25, 2024 6:09:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29300
2024.03.25 18:09:05 INFO  compiling root (1 scala source)
2024.03.25 18:09:07 INFO  time: compiled root in 1.6s
Mar 25, 2024 6:10:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29357
2024.03.25 18:10:46 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:34: error: Non-zero integral values may not have a leading zero.
      layoutX = 00        
                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:856)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.03.25 18:11:00 INFO  compiling root (1 scala source)
2024.03.25 18:11:01 INFO  time: compiled root in 1.15s
Mar 25, 2024 6:11:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29596
Mar 25, 2024 6:11:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29597
Mar 25, 2024 6:11:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29599
2024.03.25 18:12:51 INFO  compiling root (1 scala source)
2024.03.25 18:12:52 INFO  time: compiled root in 1.14s
Mar 25, 2024 6:12:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29640
2024.03.31 19:05:16 INFO  time: code lens generation in 2.45s
2024.03.31 19:09:22 INFO  compiling root (2 scala sources)
2024.03.31 19:09:25 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 176h 6m 57.546s)
2024.03.31 19:09:25 INFO  compiling root (2 scala sources)
2024.03.31 19:09:27 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.31 19:09:27 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.31 19:09:27 INFO  time: compiled root in 3.25s
Mar 31, 2024 7:12:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29861
2024.03.31 19:16:52 INFO  compiling root (1 scala source)
2024.03.31 19:16:55 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.03.31 19:16:55 INFO  time: compiled root in 4.34s
Apr 02, 2024 10:15:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 30083
Apr 02, 2024 10:15:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 30097
2024.04.02 10:15:44 INFO  compiling root (1 scala source)
2024.04.02 10:15:47 INFO  time: compiled root in 2.52s
2024.04.02 10:16:20 INFO  compiling root (1 scala source)
2024.04.02 10:16:23 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 10:16:23 INFO  time: compiled root in 2.77s
Apr 02, 2024 10:25:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 30272
2024.04.02 10:25:52 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 215h 23m 24.567s)
2024.04.02 10:25:52 INFO  compiling root (1 scala source)
2024.04.02 10:25:52 INFO  compiling root (1 scala source)
2024.04.02 10:25:53 INFO  time: compiled root in 1.18s
2024.04.02 10:25:53 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 215h 23m 25.849s)
2024.04.02 10:25:53 INFO  compiling root (1 scala source)
2024.04.02 10:25:53 INFO  compiling root (1 scala source)
2024.04.02 10:25:53 INFO  time: compiled root in 0.92s
2024.04.02 10:25:54 INFO  {
  "jsonrpc": "2.0",
  "id": "2672",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.02 10:25:54 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 10:26:14 INFO  compiling root (1 scala source)
2024.04.02 10:26:14 INFO  time: compiled root in 0.87s
2024.04.02 10:26:14 INFO  compiling root (1 scala source)
2024.04.02 10:26:16 INFO  time: compiled root in 0.93s
2024.04.02 10:26:24 INFO  compiling root (1 scala source)
2024.04.02 10:26:27 INFO  time: compiled root in 2.27s
2024.04.02 10:26:27 INFO  compiling root (1 scala source)
2024.04.02 10:26:29 INFO  time: compiled root in 2.14s
2024.04.02 10:27:01 INFO  compiling root (1 scala source)
2024.04.02 10:27:05 INFO  time: compiled root in 3.79s
2024.04.02 10:27:05 INFO  compiling root (1 scala source)
2024.04.02 10:27:08 INFO  time: compiled root in 2.46s
Apr 02, 2024 10:27:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 30592
2024.04.02 10:30:49 INFO  compiling root (1 scala source)
2024.04.02 10:30:51 INFO  time: compiled root in 2.43s
2024.04.02 10:30:51 INFO  compiling root (1 scala source)
2024.04.02 10:30:55 INFO  time: compiled root in 3.5s
2024.04.02 10:33:29 INFO  compiling root (1 scala source)
2024.04.02 10:33:30 INFO  time: compiled root in 1.27s
2024.04.02 10:33:30 INFO  compiling root (1 scala source)
2024.04.02 10:33:32 INFO  time: compiled root in 1.32s
2024.04.02 10:33:34 INFO  compiling root (1 scala source)
2024.04.02 10:33:35 INFO  time: compiled root in 1.36s
Apr 02, 2024 10:34:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 30938
2024.04.02 10:35:23 INFO  compiling root (1 scala source)
2024.04.02 10:35:25 INFO  time: compiled root in 1.14s
2024.04.02 10:35:25 INFO  compiling root (1 scala source)
2024.04.02 10:35:25 INFO  time: compiled root in 0.86s
2024.04.02 10:35:43 INFO  compiling root (1 scala source)
2024.04.02 10:35:45 INFO  time: compiled root in 2.02s
2024.04.02 10:35:45 INFO  compiling root (1 scala source)
2024.04.02 10:35:47 INFO  time: compiled root in 2.21s
2024.04.02 10:36:11 INFO  compiling root (1 scala source)
2024.04.02 10:36:14 INFO  time: compiled root in 2.7s
2024.04.02 10:36:14 INFO  compiling root (1 scala source)
2024.04.02 10:36:16 INFO  time: compiled root in 2.47s
Apr 02, 2024 10:36:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31194
Apr 02, 2024 10:37:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31270
2024.04.02 10:37:13 INFO  compiling root (1 scala source)
2024.04.02 10:37:16 INFO  time: compiled root in 3.63s
2024.04.02 10:37:16 INFO  compiling root (1 scala source)
2024.04.02 10:37:20 INFO  time: compiled root in 3.28s
2024.04.02 10:37:27 INFO  compiling root (1 scala source)
2024.04.02 10:37:30 INFO  time: compiled root in 2.92s
2024.04.02 10:37:30 INFO  compiling root (1 scala source)
2024.04.02 10:37:33 INFO  time: compiled root in 2.43s
Apr 02, 2024 10:37:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31387
2024.04.02 10:38:42 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:259: error: illegal character '\u00a7'
§}
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 10:39:41 INFO  compiling root (1 scala source)
2024.04.02 10:39:45 INFO  time: compiled root in 3.62s
2024.04.02 10:39:45 INFO  compiling root (1 scala source)
2024.04.02 10:39:48 INFO  time: compiled root in 2.83s
Apr 02, 2024 10:39:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31547
2024.04.02 10:42:40 INFO  compiling root (1 scala source)
2024.04.02 10:42:44 INFO  time: compiled root in 3.25s
2024.04.02 10:42:44 INFO  compiling root (1 scala source)
2024.04.02 10:42:48 INFO  time: compiled root in 4.12s
2024.04.02 10:43:42 INFO  compiling root (1 scala source)
2024.04.02 10:43:44 INFO  time: compiled root in 2.31s
2024.04.02 10:43:44 INFO  compiling root (1 scala source)
2024.04.02 10:43:46 INFO  time: compiled root in 2.05s
Apr 02, 2024 10:44:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31861
Apr 02, 2024 10:44:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31871
2024.04.02 10:44:46 INFO  compiling root (1 scala source)
2024.04.02 10:44:48 INFO  time: compiled root in 2.08s
2024.04.02 10:44:48 INFO  compiling root (1 scala source)
2024.04.02 10:44:51 INFO  time: compiled root in 2.89s
2024.04.02 10:44:51 INFO  compiling root (1 scala source)
2024.04.02 10:44:53 INFO  time: compiled root in 2.37s
2024.04.02 10:45:25 INFO  compiling root (1 scala source)
2024.04.02 10:45:26 INFO  time: compiled root in 1.15s
2024.04.02 10:45:26 INFO  compiling root (1 scala source)
2024.04.02 10:45:26 INFO  time: compiled root in 0.92s
2024.04.02 10:47:31 INFO  compiling root (1 scala source)
2024.04.02 10:47:32 INFO  time: compiled root in 1.04s
2024.04.02 10:47:32 INFO  compiling root (1 scala source)
2024.04.02 10:47:32 INFO  time: compiled root in 0.87s
2024.04.02 10:47:46 INFO  compiling root (1 scala source)
2024.04.02 10:47:48 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 10:47:48 INFO  time: compiled root in 2.58s
2024.04.02 10:48:29 INFO  compiling root (1 scala source)
2024.04.02 10:48:29 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 215h 46m 1.875s)
2024.04.02 10:48:29 INFO  compiling root (1 scala source)
2024.04.02 10:48:31 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 10:48:31 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 10:48:31 INFO  time: compiled root in 2s
2024.04.02 10:48:31 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 10:48:31 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 10:48:31 INFO  Starting debug proxy for [Dashboard]
2024.04.02 10:48:31 INFO  Loaded expression compiler in 13 milliseconds
2024.04.02 10:48:31 INFO  Loaded step filter in 0 milliseconds
2024.04.02 10:48:31 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 10:48:35 INFO  Loaded all sources and classes in 3 seconds
2024.04.02 10:48:36 INFO  Trying to attach to remote debuggee VM localhost:53297 .
2024.04.02 10:48:36 INFO  Attaching to debuggee VM succeeded.
2024.04.02 10:52:13 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 10:52:13 INFO  Closing debug server tcp://0.0.0.0:53294
Apr 02, 2024 10:53:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32150
2024.04.02 10:54:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 10:54:24 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 215h 51m 57.176s)
2024.04.02 10:54:24 INFO  compiling root (1 scala source)
2024.04.02 10:54:24 INFO  compiling root (1 scala source)
2024.04.02 10:54:26 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 10:54:26 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 10:54:26 INFO  time: compiled root in 1.54s
2024.04.02 10:54:26 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 10:54:26 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 10:54:26 INFO  Starting debug proxy for [Dashboard]
2024.04.02 10:54:26 INFO  Loaded expression compiler in 6 milliseconds
2024.04.02 10:54:26 INFO  Loaded step filter in 0 milliseconds
2024.04.02 10:54:26 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 10:54:29 INFO  Loaded all sources and classes in 2 seconds
2024.04.02 10:54:30 INFO  Trying to attach to remote debuggee VM localhost:53337 .
2024.04.02 10:54:30 INFO  Attaching to debuggee VM succeeded.
2024.04.02 11:09:36 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 11:09:36 INFO  Closing debug server tcp://0.0.0.0:53333
2024.04.02 11:26:49 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 216h 24m 21.63s)
2024.04.02 11:26:49 INFO  compiling root (1 scala source)
2024.04.02 11:26:49 INFO  compiling root (1 scala source)
2024.04.02 11:26:52 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 11:26:52 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 11:26:52 INFO  time: compiled root in 3.24s
2024.04.02 11:26:52 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 216h 24m 25.177s)
2024.04.02 11:26:52 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 11:26:52 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 11:26:53 INFO  Starting debug proxy for [Dashboard]
2024.04.02 11:26:52 INFO  Loaded expression compiler in 6 milliseconds
2024.04.02 11:26:52 INFO  Loaded step filter in 0 milliseconds
2024.04.02 11:26:52 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 11:26:56 INFO  Loaded all sources and classes in 3 seconds
2024.04.02 11:26:57 INFO  Trying to attach to remote debuggee VM localhost:53481 .
2024.04.02 11:26:57 INFO  Attaching to debuggee VM succeeded.
2024.04.02 11:46:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 11:46:23 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 216h 43m 55.606s)
2024.04.02 11:46:23 INFO  compiling root (1 scala source)
2024.04.02 11:46:23 INFO  compiling root (1 scala source)
2024.04.02 11:46:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 11:46:25 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 11:46:25 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 11:46:25 INFO  Closing debug server tcp://0.0.0.0:53478
2024.04.02 11:46:26 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 11:46:25 INFO  time: compiled root in 2.92s
2024.04.02 11:46:26 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 11:46:25 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 216h 43m 58.726s)
2024.04.02 11:46:26 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 11:46:26 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 11:46:26 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 11:46:26 INFO  Starting debug proxy for [Dashboard]
2024.04.02 11:46:26 INFO  Starting debug proxy for [Dashboard]
2024.04.02 11:46:25 INFO  Loaded expression compiler in 1 millisecond
2024.04.02 11:46:25 INFO  Loaded expression compiler in 1 millisecond
2024.04.02 11:46:25 INFO  Loaded step filter in 0 milliseconds
2024.04.02 11:46:25 INFO  Loaded step filter in 0 milliseconds
2024.04.02 11:46:25 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 11:46:25 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/circe/circe-numbers_3/0.14.2/circe-numbers_3-0.14.2-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/softwaremill/sttp/client3/core_3/3.3.7/core_3-3.3.7-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http_3/10.5.3/akka-http_3-10.5.3-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-kernel_3/2.7.0/cats-kernel_3-2.7.0-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/20/javafx-controls-20-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-web/20/javafx-web-20-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-fxml/20/javafx-fxml-20-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/typelevel/simulacrum-scalafix-annotations_3/0.5.4/simulacrum-scalafix-annotations_3-0.5.4-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-swing/20/javafx-swing-20-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home/lib/src.zip: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http-core_3/10.5.3/akka-http-core_3-10.5.3-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-core_3/2.7.0/cats-core_3-2.7.0-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/softwaremill/sttp/client3/json-common_3/3.3.7/json-common_3-3.3.7-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/softwaremill/sttp/client3/circe_3/3.3.7/circe_3-3.3.7-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/circe/circe-jawn_3/0.14.2/circe-jawn_3-0.14.2-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/20/javafx-graphics-20-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/circe/circe-parser_3/0.14.2/circe-parser_3-0.14.2-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/typelevel/jawn-parser_3/1.3.2/jawn-parser_3-1.3.2-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/circe/circe-generic_3/0.14.2/circe-generic_3-0.14.2-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/circe/circe-core_3/0.14.2/circe-core_3-0.14.2-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-parsing_3/10.5.3/akka-parsing_3-10.5.3-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/20/javafx-base-20-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/softwaremill/sttp/shared/ws_3/1.2.5/ws_3-1.2.5-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.10/scala-library-2.13.10-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-media/20/javafx-media-20-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalafx/scalafx_3/20.0.0-R31/scalafx_3-20.0.0-R31-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:25 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.3.0/scala3-library_3-3.3.0-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:27 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 11:46:27 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 11:46:28 INFO  Starting debug proxy for [Dashboard]
2024.04.02 11:46:28 INFO  Loaded expression compiler in 5 milliseconds
2024.04.02 11:46:28 INFO  Loaded step filter in 0 milliseconds
2024.04.02 11:46:28 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 11:46:28 WARN  Cannot list the source files in /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home/lib/src.zip: FileSystemAlreadyExistsException null
2024.04.02 11:46:28 WARN  Cannot list the source files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http_3/10.5.3/akka-http_3-10.5.3-sources.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:28 WARN  Cannot list the class files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/20/javafx-graphics-20-mac.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:28 WARN  Cannot list the class files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http-core_3/10.5.3/akka-http-core_3-10.5.3.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:28 WARN  Cannot list the class files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.10/scala-library-2.13.10.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:28 WARN  Cannot list the class files in /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-core_3/2.7.0/cats-core_3-2.7.0.jar: FileSystemAlreadyExistsException null
2024.04.02 11:46:30 INFO  Loaded all sources and classes in 4 seconds
2024.04.02 11:46:30 INFO  Loaded all sources and classes in 2 seconds
2024.04.02 11:46:32 INFO  Loaded all sources and classes in 5 seconds
2024.04.02 11:46:33 INFO  Trying to attach to remote debuggee VM localhost:53577 .
2024.04.02 11:46:33 INFO  Trying to attach to remote debuggee VM localhost:53572 .
2024.04.02 11:46:33 INFO  Attaching to debuggee VM succeeded.
2024.04.02 11:46:33 INFO  Attaching to debuggee VM succeeded.
2024.04.02 11:46:33 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 216h 44m 6.929s)
2024.04.02 11:46:34 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 11:46:34 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 11:46:35 INFO  Starting debug proxy for [Dashboard]
2024.04.02 11:46:36 INFO  Loaded expression compiler in 17 milliseconds
2024.04.02 11:46:36 INFO  Loaded step filter in 0 milliseconds
2024.04.02 11:46:36 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 11:46:36 INFO  Trying to attach to remote debuggee VM localhost:53573 .
2024.04.02 11:46:36 INFO  Attaching to debuggee VM succeeded.
2024.04.02 11:46:41 INFO  Loaded all sources and classes in 5 seconds
2024.04.02 11:46:42 INFO  Trying to attach to remote debuggee VM localhost:53586 .
2024.04.02 11:46:42 INFO  Attaching to debuggee VM succeeded.
Apr 02, 2024 11:49:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32539
2024.04.02 11:49:53 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 11:49:54 INFO  Closing debug server tcp://0.0.0.0:53566
2024.04.02 11:52:43 INFO  compiling root (1 scala source)
2024.04.02 11:52:46 INFO  time: compiled root in 3.02s
Apr 02, 2024 11:53:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32603
Apr 02, 2024 11:53:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32612
2024.04.02 11:53:05 INFO  compiling root (1 scala source)
2024.04.02 11:53:07 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 11:53:07 INFO  time: compiled root in 3.15s
Apr 02, 2024 11:53:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32631
2024.04.02 11:55:28 INFO  compiling root (1 scala source)
2024.04.02 11:55:29 INFO  time: compiled root in 1.55s
2024.04.02 11:55:44 INFO  compiling root (1 scala source)
2024.04.02 11:55:47 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 11:55:47 INFO  time: compiled root in 2.58s
2024.04.02 11:56:51 INFO  Closing debug server tcp://0.0.0.0:53583
2024.04.02 11:56:51 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 11:57:09 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 11:57:09 INFO  Closing debug server tcp://0.0.0.0:53575
2024.04.02 11:57:37 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 11:57:37 INFO  Closing debug server tcp://0.0.0.0:53568
2024.04.02 12:46:08 INFO  time: code lens generation in 1.22s
Apr 02, 2024 12:46:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32788
2024.04.02 12:46:12 INFO  compiling root (1 scala source)
2024.04.02 12:46:15 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 12:46:15 INFO  time: compiled root in 3.1s
2024.04.02 13:02:01 INFO  compiling root (1 scala source)
2024.04.02 13:02:03 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 13:02:03 INFO  time: compiled root in 2.14s
2024.04.02 13:02:12 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:260: error: illegal character '\u00a7'
  §
  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 13:02:17 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 217h 59m 49.786s)
2024.04.02 13:02:17 INFO  compiling root (1 scala source)
2024.04.02 13:02:17 INFO  compiling root (1 scala source)
2024.04.02 13:02:18 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 13:02:18 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 13:02:18 INFO  time: compiled root in 1.7s
2024.04.02 13:02:19 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 13:02:19 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 13:02:19 INFO  Starting debug proxy for [Dashboard]
2024.04.02 13:02:18 INFO  Loaded expression compiler in 23 milliseconds
2024.04.02 13:02:18 INFO  Loaded step filter in 0 milliseconds
2024.04.02 13:02:18 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 13:02:24 INFO  Loaded all sources and classes in 5 seconds
2024.04.02 13:02:26 INFO  Trying to attach to remote debuggee VM localhost:53818 .
2024.04.02 13:02:26 INFO  Attaching to debuggee VM succeeded.
Apr 02, 2024 1:06:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 33033
2024.04.02 13:07:09 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 218h 4m 42.173s)
2024.04.02 13:07:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 13:07:09 INFO  compiling root (1 scala source)
2024.04.02 13:07:09 INFO  compiling root (1 scala source)
2024.04.02 13:07:11 INFO  time: compiled root in 2.03s
2024.04.02 13:07:11 INFO  compiling root (1 scala source)
2024.04.02 13:07:12 INFO  time: compiled root in 0.94s
2024.04.02 13:07:13 INFO  {
  "jsonrpc": "2.0",
  "id": "2993",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.02 13:07:13 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 13:07:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 13:07:22 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 13:07:22 INFO  Closing debug server tcp://0.0.0.0:53815
2024.04.02 13:07:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 13:07:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 13:07:40 INFO  compiling root (1 scala source)
2024.04.02 13:07:41 INFO  time: compiled root in 1.28s
2024.04.02 13:07:41 INFO  compiling root (1 scala source)
2024.04.02 13:07:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 13:07:43 INFO  time: compiled root in 1.36s
2024.04.02 13:07:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 13:07:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 13:07:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 02, 2024 1:07:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 33121
2024.04.02 13:07:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 13:07:55 INFO  compiling root (1 scala source)
2024.04.02 13:07:57 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 13:07:57 INFO  time: compiled root in 2.24s
2024.04.02 13:09:39 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 13:09:39 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 13:09:39 INFO  Starting debug proxy for [Dashboard]
2024.04.02 13:09:39 INFO  Loaded expression compiler in 10 milliseconds
2024.04.02 13:09:39 INFO  Loaded step filter in 0 milliseconds
2024.04.02 13:09:39 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 13:09:43 INFO  Loaded all sources and classes in 4 seconds
2024.04.02 13:09:46 INFO  Trying to attach to remote debuggee VM localhost:53866 .
2024.04.02 13:09:46 INFO  Attaching to debuggee VM succeeded.
2024.04.02 13:15:00 INFO  compiling root (1 scala source)
2024.04.02 13:15:07 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 13:15:07 INFO  time: compiled root in 7.11s
2024.04.02 13:15:17 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 13:15:17 INFO  Closing debug server tcp://0.0.0.0:53861
2024.04.02 13:22:50 INFO  compiling root (1 scala source)
2024.04.02 13:22:52 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 13:22:52 INFO  time: compiled root in 1.91s
2024.04.02 13:34:15 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:255: error: illegal character '\u00b4'
      if loaded = 0 h´
                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 13:34:18 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:256: error: illegal character '\u00a7'
     §
     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 13:47:20 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 13:52:54 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 218h 50m 26.516s)
2024.04.02 13:52:54 INFO  compiling root (1 scala source)
2024.04.02 13:52:54 INFO  compiling root (1 scala source)
2024.04.02 13:52:57 INFO  time: compiled root in 3.21s
2024.04.02 13:52:57 INFO  compiling root (1 scala source)
2024.04.02 13:53:00 INFO  time: compiled root in 3.2s
2024.04.02 13:53:00 INFO  compiling root (1 scala source)
2024.04.02 13:53:00 INFO  {
  "jsonrpc": "2.0",
  "id": "3056",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.02 13:53:00 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 13:53:03 INFO  time: compiled root in 2.54s
2024.04.02 13:53:14 INFO  compiling root (1 scala source)
2024.04.02 13:53:14 INFO  time: compiled root in 0.93s
2024.04.02 13:53:15 INFO  compiling root (1 scala source)
2024.04.02 13:53:17 INFO  time: compiled root in 1.81s
2024.04.02 13:54:42 INFO  compiling root (1 scala source)
2024.04.02 13:54:45 INFO  time: compiled root in 2.83s
2024.04.02 13:54:45 INFO  compiling root (1 scala source)
2024.04.02 13:54:48 INFO  time: compiled root in 3s
2024.04.02 13:55:27 INFO  compiling root (4 scala sources)
2024.04.02 13:55:32 INFO  time: compiled root in 4.86s
2024.04.02 13:55:32 INFO  compiling root (4 scala sources)
2024.04.02 13:55:35 INFO  time: compiled root in 2.51s
2024.04.02 13:55:41 INFO  compiling root (4 scala sources)
2024.04.02 13:55:43 INFO  time: compiled root in 1.93s
2024.04.02 13:55:43 INFO  compiling root (4 scala sources)
2024.04.02 13:55:45 INFO  time: compiled root in 1.97s
2024.04.02 13:55:48 INFO  compiling root (4 scala sources)
2024.04.02 13:55:49 INFO  time: compiled root in 1.52s
2024.04.02 13:55:49 INFO  compiling root (4 scala sources)
2024.04.02 13:55:50 INFO  time: compiled root in 1.11s
2024.04.02 13:56:08 INFO  compiling root (4 scala sources)
2024.04.02 13:56:12 INFO  time: compiled root in 3.46s
2024.04.02 13:56:12 INFO  compiling root (4 scala sources)
2024.04.02 13:56:16 INFO  time: compiled root in 4.41s
2024.04.02 13:56:19 INFO  compiling root (4 scala sources)
2024.04.02 13:56:24 INFO  time: compiled root in 5.18s
2024.04.02 13:56:24 INFO  compiling root (4 scala sources)
2024.04.02 13:56:28 INFO  time: compiled root in 3.73s
Apr 02, 2024 1:56:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34278
2024.04.02 13:56:52 INFO  compiling root (4 scala sources)
2024.04.02 13:56:57 INFO  time: compiled root in 4.8s
Apr 02, 2024 1:56:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34290
2024.04.02 13:57:04 INFO  compiling root (4 scala sources)
2024.04.02 13:57:08 INFO  time: compiled root in 4.67s
Apr 02, 2024 1:57:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34313
Apr 02, 2024 1:57:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34350
2024.04.02 13:57:56 INFO  compiling root (5 scala sources)
2024.04.02 13:57:59 INFO  time: compiled root in 3.62s
2024.04.02 13:57:59 INFO  compiling root (5 scala sources)
2024.04.02 13:58:05 INFO  time: compiled root in 5.17s
2024.04.02 13:58:07 INFO  compiling root (5 scala sources)
2024.04.02 13:58:10 INFO  time: compiled root in 3.1s
Apr 02, 2024 1:58:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34392
2024.04.02 13:58:24 INFO  compiling root (6 scala sources)
2024.04.02 13:58:28 INFO  time: compiled root in 4.15s
2024.04.02 13:58:28 INFO  compiling root (6 scala sources)
2024.04.02 13:58:33 INFO  time: compiled root in 5.1s
2024.04.02 14:00:35 INFO  compiling root (6 scala sources)
2024.04.02 14:00:38 INFO  time: compiled root in 3.02s
2024.04.02 14:00:38 INFO  compiling root (6 scala sources)
2024.04.02 14:00:41 INFO  time: compiled root in 2.9s
2024.04.02 14:01:11 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:241: error: Invalid literal number
            fileContent.foreach(i => flights.addAll(9i)
                                                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 02, 2024 2:01:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34597
2024.04.02 14:01:16 INFO  compiling root (6 scala sources)
2024.04.02 14:01:17 INFO  time: compiled root in 1.42s
2024.04.02 14:01:17 INFO  compiling root (6 scala sources)
2024.04.02 14:01:19 INFO  time: compiled root in 1.22s
Apr 02, 2024 2:07:13 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath

Apr 02, 2024 2:07:13 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath

Apr 02, 2024 2:07:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34872
2024.04.02 14:07:44 INFO  compiling root (6 scala sources)
2024.04.02 14:07:47 INFO  time: compiled root in 2.28s
2024.04.02 14:07:47 INFO  compiling root (6 scala sources)
2024.04.02 14:07:49 INFO  time: compiled root in 2.32s
Apr 02, 2024 2:08:48 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath

Apr 02, 2024 2:08:48 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath

Apr 02, 2024 2:08:48 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath

Apr 02, 2024 2:08:48 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath

2024.04.02 14:08:55 INFO  compiling root (6 scala sources)
2024.04.02 14:08:56 INFO  time: compiled root in 1.32s
2024.04.02 14:08:56 INFO  compiling root (6 scala sources)
2024.04.02 14:08:58 INFO  time: compiled root in 1.21s
2024.04.02 14:10:34 WARN  Using indexes to guess the definition of String
2024.04.02 14:10:40 INFO  compiling root (6 scala sources)
2024.04.02 14:10:41 INFO  time: compiled root in 1.24s
2024.04.02 14:10:41 INFO  compiling root (6 scala sources)
2024.04.02 14:10:42 INFO  time: compiled root in 1.19s
Apr 02, 2024 2:11:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35503
2024.04.02 14:11:21 INFO  compiling root (6 scala sources)
2024.04.02 14:11:22 INFO  time: compiled root in 1.11s
2024.04.02 14:11:22 INFO  compiling root (6 scala sources)
2024.04.02 14:11:23 INFO  time: compiled root in 1.2s
Apr 02, 2024 2:12:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35634
2024.04.02 14:12:04 INFO  compiling root (6 scala sources)
2024.04.02 14:12:07 INFO  time: compiled root in 2.3s
2024.04.02 14:12:07 INFO  compiling root (6 scala sources)
2024.04.02 14:12:09 INFO  time: compiled root in 1.76s
2024.04.02 14:14:31 WARN  Using indexes to guess the definition of HttpURLConnectionBackend
Apr 02, 2024 2:15:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36045
Apr 02, 2024 2:16:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36351
2024.04.02 14:17:14 WARN  Using indexes to guess the definition of HttpURLConnectionBackend
Apr 02, 2024 2:17:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36402
Apr 02, 2024 2:17:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36405
Apr 02, 2024 2:17:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36407
2024.04.02 14:17:48 INFO  compiling root (6 scala sources)
2024.04.02 14:17:49 INFO  time: compiled root in 1.45s
2024.04.02 14:17:49 INFO  compiling root (6 scala sources)
2024.04.02 14:17:50 INFO  time: compiled root in 1.22s
2024.04.02 14:17:50 INFO  compiling root (6 scala sources)
2024.04.02 14:17:52 INFO  time: compiled root in 1.11s
2024.04.02 14:17:52 INFO  compiling root (6 scala sources)
2024.04.02 14:17:53 INFO  time: compiled root in 1.08s
2024.04.02 14:24:04 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Data/DataParser.scala
scala.meta.tokenizers.TokenizeException: <input>:35: error: unclosed string literal
    result += "xmlContent.toString
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 14:24:07 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Data/DataParser.scala
scala.meta.tokenizers.TokenizeException: <input>:35: error: unclosed string literal
    result += "allxmlContent.toString
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 14:24:31 INFO  compiling root (6 scala sources)
2024.04.02 14:24:35 INFO  time: compiled root in 3.42s
2024.04.02 14:24:35 INFO  compiling root (6 scala sources)
2024.04.02 14:24:37 INFO  time: compiled root in 2.56s
2024.04.02 14:24:37 INFO  compiling root (6 scala sources)
2024.04.02 14:24:40 INFO  time: compiled root in 2.62s
2024.04.02 14:24:40 INFO  compiling root (6 scala sources)
2024.04.02 14:24:43 INFO  time: compiled root in 3.09s
2024.04.02 14:24:43 INFO  compiling root (6 scala sources)
2024.04.02 14:24:46 INFO  time: compiled root in 2.33s
2024.04.02 14:24:46 INFO  compiling root (6 scala sources)
2024.04.02 14:24:47 INFO  time: compiled root in 1.71s
2024.04.02 14:24:47 INFO  compiling root (6 scala sources)
2024.04.02 14:24:50 INFO  time: compiled root in 2.34s
2024.04.02 14:24:50 INFO  compiling root (6 scala sources)
2024.04.02 14:24:54 INFO  time: compiled root in 3.88s
2024.04.02 14:25:11 INFO  compiling root (6 scala sources)
2024.04.02 14:25:13 INFO  time: compiled root in 1.55s
2024.04.02 14:25:13 INFO  compiling root (6 scala sources)
2024.04.02 14:25:13 INFO  time: compiled root in 0.84s
2024.04.02 14:25:13 INFO  compiling root (6 scala sources)
2024.04.02 14:25:15 INFO  time: compiled root in 1.13s
2024.04.02 14:25:15 INFO  compiling root (6 scala sources)
2024.04.02 14:25:16 INFO  time: compiled root in 0.98s
Apr 02, 2024 2:25:31 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath

Apr 02, 2024 2:25:31 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.util.type.ByteString
the classfile defining the type might be missing from the classpath

2024.04.02 14:26:34 INFO  compiling root (6 scala sources)
2024.04.02 14:26:36 INFO  time: compiled root in 1.91s
2024.04.02 14:27:06 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:237: error: unclosed comment
     /*   if (selectedFile != null) {
     ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 14:27:09 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:237: error: unclosed comment
     /*   if (selectedFile != null) {
     ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 14:27:10 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:237: error: unclosed comment
     /*   if (selectedFile != null) {
     ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 14:27:14 INFO  compiling root (6 scala sources)
2024.04.02 14:27:15 INFO  time: compiled root in 1.21s
2024.04.02 14:27:15 INFO  compiling root (6 scala sources)
2024.04.02 14:27:17 INFO  time: compiled root in 1.12s
2024.04.02 14:27:36 INFO  compiling root (6 scala sources)
2024.04.02 14:27:41 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 14:27:41 INFO  time: compiled root in 4.62s
2024.04.02 14:27:41 INFO  compiling root (6 scala sources)
2024.04.02 14:27:45 INFO  time: compiled root in 3.57s
2024.04.02 14:27:45 INFO  compiling root (6 scala sources)
2024.04.02 14:27:48 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 14:27:48 INFO  time: compiled root in 3.38s
2024.04.02 14:27:48 INFO  compiling root (6 scala sources)
2024.04.02 14:27:53 INFO  time: compiled root in 4.51s
2024.04.02 14:27:53 INFO  compiling root (12 scala sources)
2024.04.02 14:27:58 INFO  time: compiled root in 4.81s
2024.04.02 14:27:58 INFO  compiling root (12 scala sources)
2024.04.02 14:28:03 INFO  time: compiled root in 4.41s
Apr 02, 2024 2:28:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37120
Apr 02, 2024 2:28:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37170
Apr 02, 2024 2:28:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37193
2024.04.02 14:28:32 INFO  compiling root (12 scala sources)
2024.04.02 14:28:34 INFO  time: compiled root in 2.45s
2024.04.02 14:28:34 INFO  compiling root (12 scala sources)
Apr 02, 2024 2:28:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37264
Apr 02, 2024 2:28:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37270
2024.04.02 14:28:37 INFO  time: compiled root in 3.21s
Apr 02, 2024 2:28:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37297
2024.04.02 14:28:55 INFO  compiling root (12 scala sources)
2024.04.02 14:28:58 WARN  there were 2 deprecation warnings; re-run with -deprecation for details
2024.04.02 14:28:58 INFO  time: compiled root in 3.07s
Exception in thread "pool-6-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.02 14:29:26 INFO  Shutting down server
2024.04.02 14:29:26 INFO  shutting down Metals
2024.04.02 14:29:26 INFO  Shut down connection with build server.
2024.04.02 14:29:26 INFO  Shut down connection with build server.
2024.04.02 14:29:26 INFO  Exiting server
2024.04.02 14:29:57 INFO  Started: Metals version 1.2.2 in folders '/Users/alvin/VScode/OS2Projekti' for client Visual Studio Code 1.87.2.
14:29:59.308 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
14:29:59.315 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
14:29:59.315 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
14:29:59.320 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
14:29:59.320 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@531d72ca ...
14:29:59.320 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
14:29:59.320 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
14:29:59.320 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@531d72ca ...
14:29:59.324 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
14:29:59.334 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
14:29:59.334 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
14:29:59.334 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
14:29:59.334 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
14:29:59.334 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
14:29:59.334 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
14:29:59.338 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:59.338 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
14:29:59.340 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
14:29:59.340 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
14:29:59.340 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
14:29:59.518 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:/Users/alvin/VScode/OS2Projekti/.metals/metals (H2 2.2)
14:29:59.518 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
14:29:59.518 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
14:29:59.519 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
14:29:59.520 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
14:29:59.524 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
14:29:59.526 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
14:29:59.526 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:59.536 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
14:29:59.539 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:59.550 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:59.550 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
14:29:59.550 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
14:29:59.550 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
14:29:59.550 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
14:29:59.551 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:59.551 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
14:29:59.551 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
14:29:59.551 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
14:29:59.551 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
14:29:59.567 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.030s)
14:29:59.569 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
14:29:59.580 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
14:29:59.585 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
14:29:59.947 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 81 of 114M
2024.04.02 14:30:04 INFO  skipping build import with status 'Installed'
2024.04.02 14:30:04 INFO  Attempting to connect to the build server...
2024.04.02 14:30:04 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.02 14:30:04 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.02 14:30:05 INFO  Attempting to connect to the build server...
2024.04.02 14:30:05 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.02 14:30:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/project/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.02 14:30:05 INFO  time: Connected to build server in 1.65s
2024.04.02 14:30:05 INFO  Connected to Build server: Bloop v1.5.15
2024.04.02 14:30:06 INFO  time: Imported build in 0.36s
2024.04.02 14:30:12 INFO  running '/Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home/bin/java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar /var/folders/_k/74l7m8q96c70qsmn56rqh_zc0000gq/T/metals16822113511663112987/sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.02 14:30:17 INFO  [info] welcome to sbt 1.9.8 (Amazon.com Inc. Java 17.0.8.1)
2024.04.02 14:30:21 INFO  [info] loading global plugins from /Users/alvin/.sbt/1.0/plugins
2024.04.02 14:30:24 INFO  no build target found for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.02 14:30:31 INFO  [info] loading settings for project os2projekti-build-build from metals.sbt ...
2024.04.02 14:30:31 INFO  [info] loading project definition from /Users/alvin/VScode/OS2Projekti/project/project
2024.04.02 14:30:34 INFO  [info] loading settings for project os2projekti-build from metals.sbt ...
2024.04.02 14:30:34 INFO  [info] loading project definition from /Users/alvin/VScode/OS2Projekti/project
2024.04.02 14:30:38 INFO  time: indexed workspace in 13s
2024.04.02 14:30:40 INFO  [success] Generated .bloop/os2projekti-build.json
2024.04.02 14:30:40 INFO  [success] Total time: 6 s, completed 2 Apr 2024, 14.30.40
2024.04.02 14:30:40 INFO  [info] loading settings for project root from build.sbt ...
2024.04.02 14:30:41 INFO  [info] set current project to OS2Projekti (in build file:/Users/alvin/VScode/OS2Projekti/)
2024.04.02 14:30:42 INFO  [success] Generated .bloop/root.json
2024.04.02 14:30:42 INFO  [success] Generated .bloop/root-test.json
2024.04.02 14:30:42 INFO  [success] Total time: 1 s, completed 2 Apr 2024, 14.30.42
2024.04.02 14:30:42 INFO  time: ran 'sbt bloopInstall' in 29s
2024.04.02 14:30:42 INFO  Disconnecting from Bloop session...
2024.04.02 14:30:43 INFO  Cancelling compilation on Bloop server
2024.04.02 14:30:43 INFO  Shut down connection with build server.
2024.04.02 14:30:44 ERROR timeout: build server 'bloop' during shutdown
2024.04.02 14:30:45 INFO  Attempting to connect to the build server...
2024.04.02 14:30:45 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.02 14:30:45 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.02 14:30:45 INFO  Attempting to connect to the build server...
2024.04.02 14:30:45 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.02 14:30:45 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/project/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.02 14:30:45 INFO  time: Connected to build server in 0.12s
2024.04.02 14:30:45 INFO  Connected to Build server: Bloop v1.5.15
Apr 02, 2024 2:30:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22
Apr 02, 2024 2:30:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8
Apr 02, 2024 2:30:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27
Apr 02, 2024 2:30:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28
Apr 02, 2024 2:30:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32
2024.04.02 14:30:51 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 14:30:51 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 14:30:51 INFO  Starting debug proxy for [Dashboard]
2024.04.02 14:30:52 INFO  Loaded expression compiler in 7 milliseconds
2024.04.02 14:30:52 INFO  Loaded step filter in 0 milliseconds
2024.04.02 14:30:52 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 14:30:55 INFO  Loaded all sources and classes in 3 seconds
2024.04.02 14:30:57 INFO  Trying to attach to remote debuggee VM localhost:54327 .
2024.04.02 14:30:57 INFO  Attaching to debuggee VM succeeded.
2024.04.02 14:31:13 INFO  time: indexed workspace in 23s
error: /Users/alvin/VScode/OS2Projekti/.metals/.tmp/.metals/.tmp/Main-7312240658896736163.scala is not a file
2024.04.02 14:32:51 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 14:32:51 INFO  Closing debug server tcp://0.0.0.0:54324
2024.04.02 14:34:14 INFO  compiling root (1 scala source)
2024.04.02 14:34:16 INFO  time: compiled root in 1.69s
2024.04.02 14:34:25 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Data/DataParser.scala
scala.meta.tokenizers.TokenizeException: <input>:46: error: invalid escape character
    result += "xxxxx \Nyyyyy\n" + xmlContent.toString
                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.invalidEscape(LegacyScanner.scala:744)
	at scala.meta.internal.tokenizers.LegacyScanner.getLitChar(LegacyScanner.scala:732)
	at scala.meta.internal.tokenizers.LegacyScanner.getLitChars(LegacyScanner.scala:753)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:546)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 14:34:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Data/DataParser.scala
2024.04.02 14:34:51 INFO  compiling root (1 scala source)
2024.04.02 14:34:53 INFO  time: compiled root in 1.37s
Apr 02, 2024 2:34:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 311
Apr 02, 2024 2:49:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 664
2024.04.02 14:54:56 INFO  compiling root (2 scala sources)
2024.04.02 14:54:57 INFO  time: compiled root in 1.39s
2024.04.02 14:54:57 INFO  compiling root (2 scala sources)
2024.04.02 14:54:58 INFO  time: compiled root in 1.44s
2024.04.02 14:55:23 INFO  compiling root (2 scala sources)
2024.04.02 14:55:24 INFO  time: compiled root in 1.04s
2024.04.02 14:55:24 INFO  compiling root (2 scala sources)
2024.04.02 14:55:25 INFO  time: compiled root in 1.12s
Apr 02, 2024 2:55:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1127
Apr 02, 2024 2:55:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1128
Apr 02, 2024 2:55:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1130
Apr 02, 2024 2:55:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1131
Apr 02, 2024 2:55:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1133
Apr 02, 2024 2:55:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1134
Apr 02, 2024 2:55:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1136
Apr 02, 2024 2:55:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1138
Apr 02, 2024 2:55:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1140
2024.04.02 14:55:52 INFO  compiling root (2 scala sources)
2024.04.02 14:55:53 INFO  time: compiled root in 1.07s
2024.04.02 14:55:53 INFO  compiling root (2 scala sources)
2024.04.02 14:55:53 INFO  time: compiled root in 0.89s
2024.04.02 14:56:10 INFO  compiling root (2 scala sources)
2024.04.02 14:56:13 INFO  time: compiled root in 2.47s
2024.04.02 14:56:13 INFO  compiling root (2 scala sources)
2024.04.02 14:56:15 INFO  time: compiled root in 2.67s
2024.04.02 14:58:14 INFO  compiling root (2 scala sources)
2024.04.02 14:58:16 INFO  time: compiled root in 2.24s
2024.04.02 14:58:16 INFO  compiling root (2 scala sources)
2024.04.02 14:58:18 INFO  time: compiled root in 2.09s
2024.04.02 14:58:33 INFO  compiling root (2 scala sources)
2024.04.02 14:58:35 INFO  time: compiled root in 2.34s
2024.04.02 14:58:35 INFO  compiling root (2 scala sources)
2024.04.02 14:58:37 INFO  time: compiled root in 2.22s
2024.04.02 14:58:45 INFO  compiling root (2 scala sources)
2024.04.02 14:58:46 INFO  time: compiled root in 1.17s
2024.04.02 14:58:46 INFO  compiling root (2 scala sources)
2024.04.02 14:58:47 INFO  time: compiled root in 1.05s
2024.04.02 14:59:41 INFO  compiling root (2 scala sources)
2024.04.02 14:59:43 INFO  time: compiled root in 1.23s
2024.04.02 14:59:43 INFO  compiling root (2 scala sources)
2024.04.02 14:59:44 INFO  time: compiled root in 1.02s
2024.04.02 15:00:21 INFO  compiling root (2 scala sources)
2024.04.02 15:00:22 INFO  time: compiled root in 1.1s
2024.04.02 15:00:22 INFO  compiling root (2 scala sources)
2024.04.02 15:00:23 INFO  time: compiled root in 1.16s
2024.04.02 15:02:10 INFO  compiling root (2 scala sources)
2024.04.02 15:02:11 INFO  time: compiled root in 1.02s
2024.04.02 15:02:11 INFO  compiling root (2 scala sources)
2024.04.02 15:02:12 INFO  time: compiled root in 1.02s
2024.04.02 15:02:14 INFO  compiling root (2 scala sources)
2024.04.02 15:02:16 INFO  time: compiled root in 1.2s
2024.04.02 15:02:16 INFO  compiling root (2 scala sources)
2024.04.02 15:02:17 INFO  time: compiled root in 0.95s
2024.04.02 15:03:30 INFO  compiling root (2 scala sources)
2024.04.02 15:03:33 INFO  time: compiled root in 2.69s
2024.04.02 15:03:33 INFO  compiling root (2 scala sources)
2024.04.02 15:03:35 INFO  time: compiled root in 2.19s
2024.04.02 15:04:00 INFO  compiling root (2 scala sources)
2024.04.02 15:04:01 INFO  time: compiled root in 1.2s
2024.04.02 15:04:01 INFO  compiling root (2 scala sources)
2024.04.02 15:04:03 INFO  time: compiled root in 1.1s
Apr 02, 2024 3:09:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2037
Apr 02, 2024 3:09:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2146
Apr 02, 2024 3:09:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2157
Apr 02, 2024 3:09:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2172
Apr 02, 2024 3:10:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2290
2024.04.02 15:10:16 INFO  compiling root (2 scala sources)
2024.04.02 15:10:18 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 15:10:18 INFO  time: compiled root in 2.04s
2024.04.02 15:11:06 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 15:11:06 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 15:11:06 INFO  Starting debug proxy for [Dashboard]
2024.04.02 15:11:06 INFO  Loaded expression compiler in 9 milliseconds
2024.04.02 15:11:06 INFO  Loaded step filter in 0 milliseconds
2024.04.02 15:11:06 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 15:11:10 INFO  Loaded all sources and classes in 3 seconds
2024.04.02 15:11:13 INFO  Trying to attach to remote debuggee VM localhost:54538 .
2024.04.02 15:11:13 INFO  Attaching to debuggee VM succeeded.
2024.04.02 15:14:06 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 15:14:06 INFO  Closing debug server tcp://0.0.0.0:54535
2024.04.02 15:19:26 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 48m 41.187s)
2024.04.02 15:19:26 INFO  compiling root (1 scala source)
2024.04.02 15:19:26 INFO  compiling root (1 scala source)
2024.04.02 15:19:29 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 15:19:29 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 15:19:29 INFO  time: compiled root in 3.03s
2024.04.02 15:19:29 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 15:19:30 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 15:19:30 INFO  Starting debug proxy for [Dashboard]
2024.04.02 15:19:29 INFO  Loaded expression compiler in 9 milliseconds
2024.04.02 15:19:29 INFO  Loaded step filter in 0 milliseconds
2024.04.02 15:19:29 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 15:19:34 INFO  Loaded all sources and classes in 4 seconds
2024.04.02 15:19:35 INFO  Trying to attach to remote debuggee VM localhost:54593 .
2024.04.02 15:19:35 INFO  Attaching to debuggee VM succeeded.
2024.04.02 15:21:38 INFO  Closing debug server tcp://0.0.0.0:54590
2024.04.02 15:21:38 INFO  Canceling debug proxy for [Dashboard]
Apr 02, 2024 3:21:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2435
2024.04.02 15:22:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Data/DataParser.scala
2024.04.02 15:22:06 INFO  compiling root (1 scala source)
2024.04.02 15:22:07 INFO  time: compiled root in 1.14s
Apr 02, 2024 3:27:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2573
Apr 02, 2024 3:27:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2589
2024.04.02 15:27:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 15:27:27 INFO  compiling root (1 scala source)
2024.04.02 15:27:27 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 56m 42.756s)
2024.04.02 15:27:27 INFO  compiling root (1 scala source)
2024.04.02 15:27:29 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 15:27:29 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 15:27:29 INFO  time: compiled root in 1.57s
2024.04.02 15:27:29 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 15:27:29 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 15:27:29 INFO  Starting debug proxy for [Dashboard]
2024.04.02 15:27:29 INFO  Loaded expression compiler in 2 milliseconds
2024.04.02 15:27:29 INFO  Loaded step filter in 0 milliseconds
2024.04.02 15:27:29 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 15:27:33 INFO  Loaded all sources and classes in 4 seconds
2024.04.02 15:27:35 INFO  Trying to attach to remote debuggee VM localhost:54654 .
2024.04.02 15:27:35 INFO  Attaching to debuggee VM succeeded.
Apr 02, 2024 3:28:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2628
2024.04.02 15:28:52 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 15:28:52 INFO  Closing debug server tcp://0.0.0.0:54650
2024.04.02 15:28:54 INFO  compiling root (1 scala source)
2024.04.02 15:28:54 INFO  time: compiled root in 0.82s
Apr 02, 2024 3:30:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2685
2024.04.02 15:33:15 INFO  compiling root (1 scala source)
2024.04.02 15:33:15 INFO  time: compiled root in 0.82s
2024.04.02 15:34:31 INFO  compiling root (1 scala source)
2024.04.02 15:34:31 INFO  time: compiled root in 0.65s
2024.04.02 15:39:15 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 8m 30.576s)
2024.04.02 15:39:15 INFO  compiling root (1 scala source)
2024.04.02 15:39:15 INFO  compiling root (1 scala source)
2024.04.02 15:39:19 INFO  time: compiled root in 3.67s
2024.04.02 15:39:19 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 8m 34.536s)
2024.04.02 15:39:19 INFO  compiling root (1 scala source)
2024.04.02 15:39:19 INFO  compiling root (1 scala source)
2024.04.02 15:39:20 INFO  time: compiled root in 1.27s
2024.04.02 15:39:21 INFO  {
  "jsonrpc": "2.0",
  "id": "267",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.02 15:39:21 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 15:39:54 INFO  compiling root (1 scala source)
2024.04.02 15:39:55 INFO  time: compiled root in 1.22s
2024.04.02 15:39:55 INFO  compiling root (1 scala source)
2024.04.02 15:39:57 INFO  time: compiled root in 1.68s
Exception in thread "pool-10-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.02 15:41:00 INFO  compiling root (1 scala source)
2024.04.02 15:41:02 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 15:41:02 INFO  time: compiled root in 1.85s
2024.04.02 15:45:30 INFO  compiling root (1 scala source)
2024.04.02 15:45:31 INFO  time: compiled root in 1.13s
Apr 02, 2024 3:46:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3177
2024.04.02 15:51:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 15:51:29 INFO  compiling root (1 scala source)
2024.04.02 15:51:31 INFO  time: compiled root in 1.26s
Apr 02, 2024 4:01:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3324
2024.04.02 16:04:05 INFO  compiling root (1 scala source)
2024.04.02 16:04:06 INFO  time: compiled root in 1.17s
2024.04.02 16:07:24 INFO  compiling root (1 scala source)
2024.04.02 16:07:26 INFO  time: compiled root in 1.07s
2024.04.02 16:09:05 INFO  compiling root (1 scala source)
2024.04.02 16:09:06 INFO  time: compiled root in 1s
Apr 02, 2024 4:10:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3516
2024.04.02 16:10:14 INFO  compiling root (1 scala source)
2024.04.02 16:10:14 INFO  time: compiled root in 0.99s
Apr 02, 2024 4:13:08 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
Apr 02, 2024 4:16:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3727
2024.04.02 16:16:33 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 45m 47.979s)
2024.04.02 16:16:33 INFO  compiling root (1 scala source)
2024.04.02 16:16:33 INFO  compiling root (1 scala source)
2024.04.02 16:16:34 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 16:16:34 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 16:16:34 INFO  time: compiled root in 1.81s
2024.04.02 16:16:35 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.02 16:16:35 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.02 16:16:35 INFO  Starting debug proxy for [Dashboard]
2024.04.02 16:16:35 INFO  Loaded expression compiler in 16 milliseconds
2024.04.02 16:16:35 INFO  Loaded step filter in 0 milliseconds
2024.04.02 16:16:35 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.02 16:16:39 INFO  Loaded all sources and classes in 3 seconds
2024.04.02 16:16:41 INFO  Trying to attach to remote debuggee VM localhost:55072 .
2024.04.02 16:16:41 INFO  Attaching to debuggee VM succeeded.
2024.04.02 16:18:01 INFO  Canceling debug proxy for [Dashboard]
2024.04.02 16:18:01 INFO  Closing debug server tcp://0.0.0.0:55069
2024.04.02 16:20:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:27 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 49m 41.94s)
2024.04.02 16:20:27 INFO  compiling root (1 scala source)
2024.04.02 16:20:27 INFO  compiling root (1 scala source)
2024.04.02 16:20:28 INFO  time: compiled root in 1.08s
2024.04.02 16:20:28 INFO  compiling root (1 scala source)
2024.04.02 16:20:29 INFO  time: compiled root in 1.63s
2024.04.02 16:20:29 INFO  compiling root (1 scala source)
2024.04.02 16:20:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:30 INFO  time: compiled root in 0.95s
2024.04.02 16:20:30 INFO  {
  "jsonrpc": "2.0",
  "id": "384",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.02 16:20:30 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.02 16:20:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 02, 2024 4:20:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4131
2024.04.02 16:20:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:50 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:20:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.02 16:21:00 INFO  compiling root (1 scala source)
2024.04.02 16:21:01 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 16:21:01 INFO  time: compiled root in 1.31s
Apr 02, 2024 4:22:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4243
Apr 02, 2024 4:29:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4291
2024.04.02 16:30:00 INFO  compiling root (2 scala sources)
2024.04.02 16:30:03 INFO  time: compiled root in 2.67s
2024.04.02 16:30:03 INFO  compiling root (2 scala sources)
2024.04.02 16:30:05 INFO  time: compiled root in 2.28s
2024.04.02 16:30:09 INFO  compiling root (2 scala sources)
2024.04.02 16:30:09 INFO  time: compiled root in 0.59s
2024.04.02 16:30:09 INFO  compiling root (2 scala sources)
2024.04.02 16:30:11 INFO  time: compiled root in 0.52s
Apr 02, 2024 4:30:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4367
2024.04.02 16:32:27 INFO  compiling root (2 scala sources)
2024.04.02 16:32:28 INFO  time: compiled root in 1.05s
2024.04.02 16:32:28 INFO  compiling root (2 scala sources)
2024.04.02 16:32:28 INFO  time: compiled root in 0.62s
Apr 02, 2024 4:33:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4590
2024.04.02 16:33:30 INFO  compiling root (2 scala sources)
2024.04.02 16:33:32 INFO  time: compiled root in 1.67s
2024.04.02 16:33:32 INFO  compiling root (2 scala sources)
2024.04.02 16:33:33 INFO  time: compiled root in 1.24s
2024.04.02 16:34:36 INFO  compiling root (2 scala sources)
2024.04.02 16:34:36 INFO  time: compiled root in 0.77s
2024.04.02 16:34:36 INFO  compiling root (2 scala sources)
2024.04.02 16:34:38 INFO  time: compiled root in 0.62s
Apr 02, 2024 4:35:29 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-02/r_compiler-error_(root)_16-35-29-721.md
Apr 02, 2024 4:35:30 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-02/r_compiler-error_(root)_16-35-30-369.md
Apr 02, 2024 4:35:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4758
Apr 02, 2024 4:35:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4759
2024.04.02 16:35:41 INFO  compiling root (2 scala sources)
2024.04.02 16:35:41 INFO  time: compiled root in 0.64s
2024.04.02 16:35:41 INFO  compiling root (2 scala sources)
2024.04.02 16:35:43 INFO  time: compiled root in 0.51s
2024.04.02 16:35:58 INFO  compiling root (2 scala sources)
2024.04.02 16:35:58 INFO  time: compiled root in 0.62s
2024.04.02 16:35:58 INFO  compiling root (2 scala sources)
2024.04.02 16:35:59 INFO  time: compiled root in 0.5s
2024.04.02 16:36:06 INFO  compiling root (2 scala sources)
2024.04.02 16:36:06 INFO  time: compiled root in 0.65s
2024.04.02 16:36:06 INFO  compiling root (2 scala sources)
2024.04.02 16:36:08 INFO  time: compiled root in 1.05s
2024.04.02 16:36:08 INFO  compiling root (2 scala sources)
2024.04.02 16:36:08 INFO  time: compiled root in 0.56s
2024.04.02 16:37:27 INFO  compiling root (2 scala sources)
2024.04.02 16:37:27 INFO  time: compiled root in 0.68s
2024.04.02 16:37:27 INFO  compiling root (2 scala sources)
2024.04.02 16:37:28 INFO  time: compiled root in 0.61s
2024.04.02 16:38:07 INFO  compiling root (2 scala sources)
2024.04.02 16:38:09 INFO  time: compiled root in 1.73s
Apr 02, 2024 4:38:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5092
2024.04.02 16:41:09 INFO  compiling root (1 scala source)
2024.04.02 16:41:11 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.02 16:41:11 INFO  time: compiled root in 1.6s
Apr 02, 2024 4:41:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5242
2024.04.02 16:46:06 INFO  compiling root (1 scala source)
2024.04.02 16:46:06 INFO  time: compiled root in 0.75s
2024.04.02 16:46:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:47:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:47:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:47:20 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:47:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:47:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:47:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:47:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:48:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:25 INFO  compiling root (1 scala source)
2024.04.02 16:49:26 INFO  time: compiled root in 1.7s
2024.04.02 16:49:26 INFO  compiling root (1 scala source)
2024.04.02 16:49:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:28 INFO  time: compiled root in 1.2s
2024.04.02 16:49:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Apr 02, 2024 4:49:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5961
Apr 02, 2024 4:49:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5964
2024.04.02 16:49:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:45 INFO  compiling root (1 scala source)
2024.04.02 16:49:47 INFO  time: compiled root in 1.36s
2024.04.02 16:49:47 INFO  compiling root (1 scala source)
2024.04.02 16:49:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:48 INFO  time: compiled root in 1.4s
2024.04.02 16:49:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:49:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:50:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:50:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:50:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:50:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:09 INFO  compiling root (1 scala source)
2024.04.02 16:51:09 INFO  time: compiled root in 0.47s
2024.04.02 16:51:09 INFO  compiling root (1 scala source)
2024.04.02 16:51:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:09 INFO  time: compiled root in 0.36s
2024.04.02 16:51:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:51:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:52:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:52:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:52:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:52:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.02 16:52:14 INFO  compiling root (1 scala source)
2024.04.02 16:52:15 INFO  time: compiled root in 1.47s
2024.04.02 17:00:44 INFO  compiling root (1 scala source)
2024.04.02 17:00:44 INFO  time: compiled root in 0.49s
2024.04.02 17:00:44 INFO  compiling root (1 scala source)
2024.04.02 17:00:45 INFO  time: compiled root in 0.64s
Apr 02, 2024 5:08:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6439
Apr 02, 2024 5:09:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6526
Apr 02, 2024 5:09:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6654
Apr 02, 2024 5:10:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6788
Apr 02, 2024 5:10:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6865
Apr 02, 2024 5:11:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6910
2024.04.02 17:11:13 INFO  compiling root (1 scala source)
2024.04.02 17:11:13 INFO  time: compiled root in 0.48s
2024.04.02 17:11:13 INFO  compiling root (1 scala source)
2024.04.02 17:11:13 INFO  time: compiled root in 0.35s
2024.04.02 17:11:30 INFO  compiling root (1 scala source)
2024.04.02 17:11:31 INFO  time: compiled root in 1.22s
2024.04.02 17:11:31 INFO  compiling root (1 scala source)
2024.04.02 17:11:32 INFO  time: compiled root in 1.19s
2024.04.02 17:11:48 INFO  compiling root (1 scala source)
2024.04.02 17:11:49 INFO  time: compiled root in 1.13s
2024.04.02 17:11:49 INFO  compiling root (1 scala source)
2024.04.02 17:11:50 INFO  time: compiled root in 1.07s
2024.04.02 17:12:04 INFO  compiling root (1 scala source)
2024.04.02 17:12:04 INFO  time: compiled root in 0.46s
2024.04.02 17:12:04 INFO  compiling root (1 scala source)
2024.04.02 17:12:04 INFO  time: compiled root in 0.48s
2024.04.02 17:12:32 INFO  compiling root (1 scala source)
2024.04.02 17:12:32 INFO  time: compiled root in 0.44s
2024.04.02 17:12:32 INFO  compiling root (1 scala source)
2024.04.02 17:12:32 INFO  time: compiled root in 0.38s
2024.04.02 17:12:56 INFO  compiling root (1 scala source)
2024.04.02 17:12:57 INFO  time: compiled root in 1.16s
Apr 02, 2024 5:13:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7255
Apr 02, 2024 5:14:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7275
Apr 02, 2024 5:15:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7576
Apr 02, 2024 5:15:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7595
2024.04.02 17:15:20 INFO  compiling root (1 scala source)
2024.04.02 17:15:20 INFO  time: compiled root in 0.47s
2024.04.02 17:16:11 INFO  compiling root (1 scala source)
2024.04.02 17:16:11 INFO  time: compiled root in 0.55s
2024.04.02 17:16:11 INFO  compiling root (1 scala source)
2024.04.02 17:16:11 INFO  time: compiled root in 0.36s
2024.04.02 17:17:19 INFO  compiling root (1 scala source)
2024.04.02 17:17:19 INFO  time: compiled root in 0.58s
2024.04.02 17:17:19 INFO  compiling root (1 scala source)
2024.04.02 17:17:20 INFO  time: compiled root in 0.48s
2024.04.02 17:18:26 INFO  compiling root (1 scala source)
2024.04.02 17:18:26 INFO  time: compiled root in 0.45s
2024.04.02 17:18:26 INFO  compiling root (1 scala source)
2024.04.02 17:18:26 INFO  time: compiled root in 0.37s
2024.04.02 17:18:31 INFO  compiling root (1 scala source)
2024.04.02 17:18:31 INFO  time: compiled root in 0.36s
2024.04.02 17:18:33 INFO  compiling root (1 scala source)
2024.04.02 17:18:33 INFO  time: compiled root in 0.34s
2024.04.02 17:18:33 INFO  compiling root (1 scala source)
2024.04.02 17:18:33 INFO  time: compiled root in 0.37s
2024.04.02 17:18:33 INFO  compiling root (1 scala source)
2024.04.02 17:18:34 INFO  time: compiled root in 0.36s
2024.04.03 10:13:06 INFO  compiling root (1 scala source)
2024.04.03 10:13:06 INFO  time: compiled root in 0.6s
2024.04.03 10:13:06 INFO  compiling root (1 scala source)
2024.04.03 10:13:08 INFO  time: compiled root in 0.61s
2024.04.03 10:13:14 INFO  compiling root (1 scala source)
2024.04.03 10:13:15 INFO  time: compiled root in 1.28s
2024.04.03 10:15:16 INFO  compiling root (1 scala source)
2024.04.03 10:15:16 INFO  time: compiled root in 0.56s
2024.04.03 10:15:16 INFO  compiling root (1 scala source)
2024.04.03 10:15:17 INFO  time: compiled root in 0.51s
2024.04.03 10:15:24 INFO  compiling root (1 scala source)
2024.04.03 10:15:25 INFO  time: compiled root in 1.09s
2024.04.03 10:18:20 INFO  compiling root (1 scala source)
2024.04.03 10:18:20 INFO  time: compiled root in 0.72s
2024.04.03 10:18:20 INFO  compiling root (1 scala source)
2024.04.03 10:18:21 INFO  time: compiled root in 0.4s
2024.04.03 10:19:41 INFO  compiling root (1 scala source)
2024.04.03 10:19:43 INFO  time: compiled root in 1.43s
2024.04.03 10:19:43 INFO  compiling root (1 scala source)
2024.04.03 10:19:44 INFO  time: compiled root in 1.33s
2024.04.03 10:20:21 INFO  compiling root (1 scala source)
2024.04.03 10:20:23 INFO  time: compiled root in 1.88s
Apr 03, 2024 10:20:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8221
Apr 03, 2024 10:23:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8236
Apr 03, 2024 10:23:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8258
2024.04.03 10:25:13 INFO  compiling root (1 scala source)
2024.04.03 10:25:13 INFO  time: compiled root in 0.62s
2024.04.03 10:25:13 INFO  compiling root (1 scala source)
2024.04.03 10:25:14 INFO  time: compiled root in 0.38s
2024.04.03 10:27:36 INFO  compiling root (1 scala source)
2024.04.03 10:27:38 INFO  time: compiled root in 1.36s
2024.04.03 10:34:41 INFO  compiling root (1 scala source)
2024.04.03 10:34:42 INFO  time: compiled root in 1.17s
Apr 03, 2024 10:38:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8854
Apr 03, 2024 10:44:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8870
Apr 03, 2024 10:50:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8918
Apr 03, 2024 10:50:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8919
Apr 03, 2024 10:50:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8976
Apr 03, 2024 10:50:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8985
Apr 03, 2024 10:55:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9110
2024.04.03 10:57:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 10:57:01 INFO  compiling root (1 scala source)
2024.04.03 10:57:02 INFO  time: compiled root in 1.33s
Apr 03, 2024 10:57:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9263
Apr 03, 2024 11:18:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9749
2024.04.03 11:18:48 INFO  compiling root (2 scala sources)
2024.04.03 11:18:49 INFO  time: compiled root in 1.46s
2024.04.03 11:18:49 INFO  compiling root (2 scala sources)
2024.04.03 11:18:49 INFO  time: compiled root in 0.89s
2024.04.03 11:21:50 INFO  compiling root (2 scala sources)
2024.04.03 11:21:51 INFO  time: compiled root in 1.24s
2024.04.03 11:21:51 INFO  compiling root (2 scala sources)
2024.04.03 11:21:52 INFO  time: compiled root in 1.11s
2024.04.03 11:21:59 INFO  compiling root (2 scala sources)
2024.04.03 11:22:00 INFO  time: compiled root in 1.09s
2024.04.03 11:22:00 INFO  compiling root (2 scala sources)
2024.04.03 11:22:01 INFO  time: compiled root in 0.98s
Apr 03, 2024 11:22:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9977
2024.04.03 11:22:05 INFO  compiling root (2 scala sources)
2024.04.03 11:22:07 INFO  time: compiled root in 1.13s
Apr 03, 2024 11:23:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10071
2024.04.03 11:24:39 INFO  compiling root (2 scala sources)
2024.04.03 11:24:39 INFO  time: compiled root in 0.96s
2024.04.03 11:24:40 INFO  compiling root (2 scala sources)
2024.04.03 11:24:40 INFO  time: compiled root in 0.84s
Apr 03, 2024 11:25:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10163
2024.04.03 11:25:39 INFO  compiling root (2 scala sources)
2024.04.03 11:25:40 INFO  time: compiled root in 1.27s
Apr 03, 2024 11:27:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10228
Exception in thread "pool-10-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Apr 03, 2024 11:29:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10320
2024.04.03 11:29:56 INFO  compiling root (2 scala sources)
2024.04.03 11:29:56 INFO  time: compiled root in 0.96s
2024.04.03 11:29:57 INFO  compiling root (2 scala sources)
2024.04.03 11:29:57 INFO  time: compiled root in 0.84s
2024.04.03 11:30:04 INFO  compiling root (2 scala sources)
2024.04.03 11:30:06 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:30:06 INFO  time: compiled root in 1.92s
2024.04.03 11:31:01 INFO  compiling root (1 scala source)
2024.04.03 11:31:01 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 16.454s)
2024.04.03 11:31:01 INFO  compiling root (1 scala source)
2024.04.03 11:31:02 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:31:02 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:31:02 INFO  time: compiled root in 1.31s
2024.04.03 11:31:02 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 17.835s)
2024.04.03 11:31:02 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.03 11:31:02 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.03 11:31:03 INFO  Starting debug proxy for [Dashboard]
2024.04.03 11:31:02 INFO  Loaded expression compiler in 13 milliseconds
2024.04.03 11:31:02 INFO  Loaded step filter in 0 milliseconds
2024.04.03 11:31:02 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.03 11:31:06 INFO  Loaded all sources and classes in 3 seconds
2024.04.03 11:31:08 INFO  Trying to attach to remote debuggee VM localhost:57868 .
2024.04.03 11:31:08 INFO  Attaching to debuggee VM succeeded.
2024.04.03 11:31:58 INFO  Canceling debug proxy for [Dashboard]
2024.04.03 11:31:58 INFO  Closing debug server tcp://0.0.0.0:57864
2024.04.03 11:31:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:31:58 INFO  compiling root (1 scala source)
2024.04.03 11:31:59 INFO  time: compiled root in 0.46s
2024.04.03 11:31:59 INFO  compiling root (1 scala source)
2024.04.03 11:32:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:31:59 INFO  time: compiled root in 0.41s
2024.04.03 11:32:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:32:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:32:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:32:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:32:20 INFO  compiling root (1 scala source)
2024.04.03 11:32:20 INFO  time: compiled root in 0.52s
Apr 03, 2024 11:32:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10697
2024.04.03 11:32:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:32:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:32:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:32:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:13 INFO  compiling root (2 scala sources)
2024.04.03 11:33:13 INFO  time: compiled root in 0.94s
2024.04.03 11:33:13 INFO  compiling root (2 scala sources)
2024.04.03 11:33:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:15 INFO  time: compiled root in 0.88s
2024.04.03 11:33:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:39 INFO  compiling root (2 scala sources)
2024.04.03 11:33:40 INFO  time: compiled root in 1.13s
2024.04.03 11:33:40 INFO  compiling root (2 scala sources)
2024.04.03 11:33:41 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:40 INFO  time: compiled root in 0.92s
2024.04.03 11:33:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:47 INFO  compiling root (2 scala sources)
2024.04.03 11:33:47 INFO  time: compiled root in 0.89s
2024.04.03 11:33:47 INFO  compiling root (2 scala sources)
2024.04.03 11:33:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:49 INFO  time: compiled root in 0.97s
2024.04.03 11:33:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:33:55 INFO  compiling root (2 scala sources)
2024.04.03 11:33:55 INFO  time: compiled root in 0.84s
2024.04.03 11:33:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Apr 03, 2024 11:33:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10957
Apr 03, 2024 11:34:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10964
2024.04.03 11:34:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:34:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:34:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:39 INFO  compiling root (2 scala sources)
2024.04.03 11:34:40 INFO  time: compiled root in 1.08s
2024.04.03 11:34:40 INFO  compiling root (2 scala sources)
2024.04.03 11:34:41 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:41 INFO  time: compiled root in 1.12s
2024.04.03 11:34:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 11:34:46 INFO  compiling root (2 scala sources)
Apr 03, 2024 11:34:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11075
2024.04.03 11:34:47 INFO  time: compiled root in 1.12s
2024.04.03 11:34:47 INFO  compiling root (2 scala sources)
2024.04.03 11:34:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:34:49 INFO  time: compiled root in 1.88s
2024.04.03 11:34:50 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:34:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:34:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Apr 03, 2024 11:35:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11229
2024.04.03 11:35:20 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 03, 2024 11:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11269
2024.04.03 11:35:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:41 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:35:46 INFO  compiling root (2 scala sources)
2024.04.03 11:35:48 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:35:48 INFO  time: compiled root in 2.13s
2024.04.03 11:37:44 INFO  compiling root (1 scala source)
2024.04.03 11:37:46 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:37:46 INFO  time: compiled root in 1.42s
Apr 03, 2024 11:43:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11495
2024.04.03 11:43:24 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 12m 39.875s)
2024.04.03 11:43:24 INFO  compiling root (1 scala source)
2024.04.03 11:43:24 INFO  compiling root (1 scala source)
2024.04.03 11:43:26 INFO  time: compiled root in 1.04s
2024.04.03 11:43:26 INFO  compiling root (1 scala source)
2024.04.03 11:43:27 INFO  time: compiled root in 0.98s
2024.04.03 11:43:27 INFO  compiling root (1 scala source)
2024.04.03 11:43:27 INFO  time: compiled root in 0.93s
2024.04.03 11:43:27 INFO  {
  "jsonrpc": "2.0",
  "id": "1001",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.03 11:43:28 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 11:43:39 INFO  compiling root (1 scala source)
2024.04.03 11:43:39 INFO  time: compiled root in 0.88s
2024.04.03 11:43:39 INFO  compiling root (1 scala source)
2024.04.03 11:43:41 INFO  time: compiled root in 0.76s
2024.04.03 11:43:51 INFO  compiling root (1 scala source)
2024.04.03 11:43:53 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:43:53 INFO  time: compiled root in 1.4s
Apr 03, 2024 11:45:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11651
2024.04.03 11:45:09 INFO  compiling root (1 scala source)
2024.04.03 11:45:09 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 14m 24.665s)
2024.04.03 11:45:09 INFO  compiling root (1 scala source)
2024.04.03 11:45:11 INFO  time: compiled root in 1.33s
2024.04.03 11:45:11 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.03 11:45:11 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.03 11:45:12 INFO  Starting debug proxy for [Dashboard]
2024.04.03 11:45:12 INFO  Loaded expression compiler in 25 milliseconds
2024.04.03 11:45:12 INFO  Loaded step filter in 0 milliseconds
2024.04.03 11:45:12 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.03 11:45:17 INFO  Loaded all sources and classes in 5 seconds
2024.04.03 11:45:19 INFO  Trying to attach to remote debuggee VM localhost:57957 .
2024.04.03 11:45:19 INFO  Attaching to debuggee VM succeeded.
2024.04.03 11:48:08 INFO  compiling root (2 scala sources)
2024.04.03 11:48:09 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:48:09 INFO  time: compiled root in 2.05s
2024.04.03 11:48:12 INFO  Canceling debug proxy for [Dashboard]
2024.04.03 11:48:12 INFO  Closing debug server tcp://0.0.0.0:57954
Apr 03, 2024 11:48:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11844
2024.04.03 11:50:24 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 19m 38.992s)
2024.04.03 11:50:24 INFO  compiling root (1 scala source)
2024.04.03 11:50:24 INFO  compiling root (1 scala source)
2024.04.03 11:50:27 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:50:27 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:50:27 INFO  time: compiled root in 3.54s
2024.04.03 11:50:27 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 19m 42.659s)
2024.04.03 11:50:27 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.03 11:50:27 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.03 11:50:27 INFO  Starting debug proxy for [Dashboard]
2024.04.03 11:50:27 INFO  Loaded expression compiler in 4 milliseconds
2024.04.03 11:50:27 INFO  Loaded step filter in 0 milliseconds
2024.04.03 11:50:27 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.03 11:50:30 INFO  Loaded all sources and classes in 2 seconds
2024.04.03 11:50:32 INFO  Trying to attach to remote debuggee VM localhost:58001 .
2024.04.03 11:50:32 INFO  Attaching to debuggee VM succeeded.
2024.04.03 11:51:54 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 21m 9.055s)
2024.04.03 11:51:54 INFO  compiling root (1 scala source)
2024.04.03 11:51:54 INFO  compiling root (1 scala source)
2024.04.03 11:51:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:51:57 INFO  time: compiled root in 3.2s
2024.04.03 11:51:57 INFO  compiling root (1 scala source)
2024.04.03 11:51:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:51:59 INFO  time: compiled root in 2.14s
2024.04.03 11:51:59 INFO  {
  "jsonrpc": "2.0",
  "id": "1065",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.03 11:51:59 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 11:52:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:20 INFO  Canceling debug proxy for [Dashboard]
2024.04.03 11:52:20 INFO  Closing debug server tcp://0.0.0.0:57998
2024.04.03 11:52:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:24 INFO  compiling root (1 scala source)
2024.04.03 11:52:26 INFO  time: compiled root in 2s
2024.04.03 11:52:26 INFO  compiling root (1 scala source)
2024.04.03 11:52:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:27 INFO  time: compiled root in 1.69s
2024.04.03 11:52:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 03, 2024 11:52:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12143
2024.04.03 11:52:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:50 INFO  compiling root (1 scala source)
2024.04.03 11:52:50 INFO  time: compiled root in 0.95s
2024.04.03 11:52:50 INFO  compiling root (1 scala source)
2024.04.03 11:52:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:52 INFO  time: compiled root in 1.07s
2024.04.03 11:52:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 11:52:59 INFO  compiling root (1 scala source)
2024.04.03 11:53:01 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 11:53:01 INFO  time: compiled root in 1.71s
2024.04.03 12:02:11 INFO  compiling root (1 scala source)
2024.04.03 12:02:12 INFO  time: compiled root in 1.4s
2024.04.03 12:02:12 INFO  compiling root (1 scala source)
2024.04.03 12:02:14 INFO  time: compiled root in 1.21s
2024.04.03 12:02:18 INFO  compiling root (1 scala source)
2024.04.03 12:02:20 INFO  time: compiled root in 1.59s
2024.04.03 12:02:20 INFO  compiling root (1 scala source)
2024.04.03 12:02:21 INFO  time: compiled root in 1.54s
Apr 03, 2024 12:02:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12421
Apr 03, 2024 12:02:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12419
2024.04.03 12:02:37 INFO  compiling root (1 scala source)
2024.04.03 12:02:37 INFO  time: compiled root in 0.55s
2024.04.03 12:02:37 INFO  compiling root (1 scala source)
2024.04.03 12:02:38 INFO  time: compiled root in 0.42s
2024.04.03 12:03:01 INFO  compiling root (1 scala source)
2024.04.03 12:03:02 INFO  time: compiled root in 1.43s
2024.04.03 12:03:02 INFO  compiling root (1 scala source)
2024.04.03 12:03:04 INFO  time: compiled root in 1.9s
2024.04.03 12:03:04 INFO  compiling root (1 scala source)
2024.04.03 12:03:05 INFO  time: compiled root in 1.02s
2024.04.03 12:03:05 INFO  compiling root (1 scala source)
2024.04.03 12:03:08 INFO  time: compiled root in 2.33s
2024.04.03 12:03:09 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
scala.meta.tokenizers.TokenizeException: <input>:75: error: illegal character '\u00a8'
        highlighted = true¨
                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 03, 2024 12:03:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12524
2024.04.03 12:03:30 INFO  compiling root (2 scala sources)
2024.04.03 12:03:31 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 12:03:31 INFO  time: compiled root in 1.38s
2024.04.03 12:04:04 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 33m 19.098s)
2024.04.03 12:04:04 INFO  compiling root (1 scala source)
2024.04.03 12:04:04 INFO  compiling root (1 scala source)
2024.04.03 12:04:05 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 12:04:05 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 12:04:05 INFO  time: compiled root in 1.54s
2024.04.03 12:04:05 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.03 12:04:05 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.03 12:04:05 INFO  Starting debug proxy for [Dashboard]
2024.04.03 12:04:05 INFO  Loaded expression compiler in 2 milliseconds
2024.04.03 12:04:05 INFO  Loaded step filter in 0 milliseconds
2024.04.03 12:04:05 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.03 12:04:08 INFO  Loaded all sources and classes in 2 seconds
2024.04.03 12:04:12 INFO  Trying to attach to remote debuggee VM localhost:58102 .
2024.04.03 12:04:12 INFO  Attaching to debuggee VM succeeded.
2024.04.03 12:47:30 INFO  Started: Metals version 1.2.2 in folders '/Users/alvin/VScode/OS2Projekti' for client Visual Studio Code 1.87.2.
12:47:37.228 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
12:47:37.246 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
12:47:37.247 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
12:47:37.254 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
12:47:37.254 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@531d72ca ...
12:47:37.254 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
12:47:37.255 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
12:47:37.255 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@531d72ca ...
12:47:37.265 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
12:47:37.276 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
12:47:37.276 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
12:47:37.277 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
12:47:37.277 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
12:47:37.277 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
12:47:37.277 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
12:47:37.289 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:47:37.290 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
12:47:37.298 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
12:47:37.299 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
12:47:37.299 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
12:47:37.570 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:/Users/alvin/VScode/OS2Projekti/.metals/metals (H2 2.2)
12:47:37.570 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
12:47:37.570 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
12:47:37.572 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
12:47:37.573 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
12:47:37.588 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
12:47:37.590 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
12:47:37.590 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:47:37.612 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
12:47:37.623 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:47:37.645 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:47:37.645 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
12:47:37.645 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
12:47:37.646 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
12:47:37.646 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
12:47:37.647 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:47:37.647 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
12:47:37.647 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
12:47:37.647 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
12:47:37.647 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
12:47:37.679 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.064s)
12:47:37.684 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
12:47:37.699 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
12:47:37.708 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
12:47:38.359 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 44 of 141M
2024.04.03 12:47:49 INFO  Attempting to connect to the build server...
2024.04.03 12:47:49 INFO  skipping build import with status 'Installed'
2024.04.03 12:47:49 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.03 12:48:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.03 12:48:05 INFO  Attempting to connect to the build server...
2024.04.03 12:48:05 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.03 12:48:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/project/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.03 12:48:05 INFO  time: Connected to build server in 17s
2024.04.03 12:48:05 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 12:48:06 INFO  time: Imported build in 0.41s
2024.04.03 12:48:10 INFO  no build target found for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.03 12:48:19 INFO  time: indexed workspace in 9.4s
Apr 03, 2024 1:01:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 186
Apr 03, 2024 1:02:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 414
2024.04.03 13:02:39 INFO  compiling root (1 scala source)
2024.04.03 13:02:46 INFO  time: compiled root in 6.85s
2024.04.03 13:02:46 INFO  compiling root (1 scala source)
2024.04.03 13:02:49 INFO  time: compiled root in 2.79s
2024.04.03 13:03:07 INFO  compiling root (1 scala source)
2024.04.03 13:03:09 INFO  time: compiled root in 1.74s
2024.04.03 13:03:09 INFO  compiling root (1 scala source)
2024.04.03 13:03:10 INFO  time: compiled root in 1.22s
2024.04.03 13:05:16 INFO  compiling root (1 scala source)
2024.04.03 13:05:22 INFO  time: compiled root in 6.25s
2024.04.03 13:05:22 INFO  compiling root (1 scala source)
2024.04.03 13:05:30 INFO  time: compiled root in 7.76s
2024.04.03 13:05:30 INFO  compiling root (1 scala source)
2024.04.03 13:05:33 INFO  time: compiled root in 2.92s
2024.04.03 13:05:33 INFO  compiling root (1 scala source)
2024.04.03 13:05:38 INFO  time: compiled root in 5.48s
Apr 03, 2024 1:06:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 747
2024.04.03 13:06:12 INFO  compiling root (2 scala sources)
2024.04.03 13:06:18 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 13:06:18 INFO  time: compiled root in 6s
2024.04.03 13:08:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:08:31 INFO  compiling root (1 scala source)
2024.04.03 13:08:32 INFO  time: compiled root in 1.17s
2024.04.03 13:08:32 INFO  compiling root (1 scala source)
2024.04.03 13:08:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:08:32 INFO  time: compiled root in 0.55s
2024.04.03 13:08:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:08:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:11:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:11:08 INFO  file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala:78:11: stale bloop error: Not found: rect
          rect.stroke = Color.Black
          ^^^^
2024.04.03 13:11:08 INFO  file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala:82:11: stale bloop error: Not found: rect
          rect.stroke = Color.Transparent
          ^^^^
2024.04.03 13:11:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:11:08 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:11:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:11:10 INFO  compiling root (1 scala source)
2024.04.03 13:11:13 INFO  time: compiled root in 2.54s
2024.04.03 13:11:13 INFO  compiling root (1 scala source)
2024.04.03 13:11:15 INFO  time: compiled root in 2.12s
2024.04.03 13:11:15 INFO  compiling root (1 scala source)
2024.04.03 13:11:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:11:17 INFO  time: compiled root in 2.15s
2024.04.03 13:11:17 INFO  compiling root (1 scala source)
2024.04.03 13:11:18 INFO  time: compiled root in 1.23s
2024.04.03 13:11:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Apr 03, 2024 1:12:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1156
Apr 03, 2024 1:12:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1155
Apr 03, 2024 1:13:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1347
2024.04.03 13:13:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Apr 03, 2024 1:13:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1372
2024.04.03 13:13:33 INFO  compiling root (2 scala sources)
2024.04.03 13:13:34 INFO  time: compiled root in 1.64s
2024.04.03 13:13:34 INFO  compiling root (2 scala sources)
2024.04.03 13:13:36 INFO  time: compiled root in 1.47s
2024.04.03 13:21:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:21:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:21:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:21:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 13:21:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
Apr 03, 2024 1:21:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1477
2024.04.03 13:21:11 INFO  compiling root (2 scala sources)
2024.04.03 13:21:12 INFO  time: compiled root in 1.11s
2024.04.03 13:21:12 INFO  compiling root (2 scala sources)
2024.04.03 13:21:13 INFO  time: compiled root in 1.24s
2024.04.03 13:21:57 INFO  compiling root (2 scala sources)
2024.04.03 13:22:00 INFO  time: compiled root in 3.51s
2024.04.03 13:22:00 INFO  compiling root (2 scala sources)
2024.04.03 13:22:04 INFO  time: compiled root in 3.11s
Apr 03, 2024 1:41:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1830
Apr 03, 2024 1:41:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1835
Apr 03, 2024 1:41:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1886
2024.04.03 13:41:33 INFO  compiling root (2 scala sources)
2024.04.03 13:41:35 INFO  time: compiled root in 2.23s
2024.04.03 13:41:35 INFO  compiling root (2 scala sources)
2024.04.03 13:41:37 INFO  time: compiled root in 1.75s
Apr 03, 2024 1:41:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1951
2024.04.03 13:42:12 INFO  compiling root (2 scala sources)
2024.04.03 13:42:14 INFO  time: compiled root in 2.24s
2024.04.03 13:42:14 INFO  compiling root (2 scala sources)
2024.04.03 13:42:17 INFO  time: compiled root in 2.65s
Apr 03, 2024 1:43:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2070
Apr 03, 2024 1:46:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2243
Apr 03, 2024 1:48:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2366
2024.04.03 13:48:29 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:238: error: unclosed string literal
        if viewComboBox.value.value == "Craph ViewupdateChart()
                                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 13:48:39 INFO  compiling root (2 scala sources)
2024.04.03 13:48:42 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 13:48:42 INFO  time: compiled root in 3.18s
2024.04.03 13:50:08 INFO  compiling root (1 scala source)
2024.04.03 13:50:08 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 2m 2.317s)
2024.04.03 13:50:08 INFO  compiling root (1 scala source)
2024.04.03 13:50:09 INFO  time: compiled root in 1.54s
2024.04.03 13:50:09 INFO  compiling root (1 scala source)
2024.04.03 13:50:09 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 2m 4.008s)
2024.04.03 13:50:09 INFO  compiling root (1 scala source)
2024.04.03 13:50:10 INFO  time: compiled root in 1.03s
2024.04.03 13:50:11 INFO  {
  "jsonrpc": "2.0",
  "id": "165",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.03 13:50:11 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 03, 2024 1:50:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2792
2024.04.03 13:50:47 INFO  compiling root (1 scala source)
2024.04.03 13:50:49 INFO  time: compiled root in 1.95s
2024.04.03 13:50:49 INFO  compiling root (1 scala source)
2024.04.03 13:50:51 INFO  time: compiled root in 1.67s
2024.04.03 13:51:08 INFO  compiling root (1 scala source)
2024.04.03 13:51:10 INFO  time: compiled root in 2.55s
2024.04.03 13:51:10 INFO  compiling root (1 scala source)
2024.04.03 13:51:13 INFO  time: compiled root in 2.63s
2024.04.03 13:51:13 INFO  compiling root (1 scala source)
2024.04.03 13:51:15 INFO  time: compiled root in 1.93s
2024.04.03 13:51:58 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:191: error: illegal character '\u00a0'
      var newContent: Chart ||  = defaultChart
                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 13:52:02 INFO  compiling root (1 scala source)
2024.04.03 13:52:04 INFO  time: compiled root in 1.23s
2024.04.03 13:52:04 INFO  compiling root (1 scala source)
2024.04.03 13:52:05 INFO  time: compiled root in 1s
2024.04.03 13:52:13 INFO  compiling root (1 scala source)
2024.04.03 13:52:14 INFO  time: compiled root in 1.02s
2024.04.03 13:52:14 INFO  compiling root (1 scala source)
2024.04.03 13:52:14 INFO  time: compiled root in 0.86s
Apr 03, 2024 1:52:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3012
2024.04.03 13:52:54 INFO  compiling root (1 scala source)
2024.04.03 13:52:55 INFO  time: compiled root in 1.03s
2024.04.03 13:52:55 INFO  compiling root (1 scala source)
2024.04.03 13:52:55 INFO  time: compiled root in 0.9s
2024.04.03 13:53:22 INFO  compiling root (1 scala source)
2024.04.03 13:53:24 INFO  time: compiled root in 2.07s
2024.04.03 13:53:24 INFO  compiling root (1 scala source)
2024.04.03 13:53:26 INFO  time: compiled root in 1.61s
2024.04.03 13:53:26 INFO  compiling root (1 scala source)
2024.04.03 13:53:28 INFO  time: compiled root in 1.26s
Apr 03, 2024 1:53:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3151
2024.04.03 13:53:56 INFO  compiling root (1 scala source)
2024.04.03 13:53:57 INFO  time: compiled root in 1.06s
2024.04.03 13:53:57 INFO  compiling root (1 scala source)
2024.04.03 13:53:58 INFO  time: compiled root in 1.02s
2024.04.03 13:54:41 INFO  compiling root (2 scala sources)
2024.04.03 13:54:42 INFO  time: compiled root in 1.12s
2024.04.03 13:54:42 INFO  compiling root (2 scala sources)
2024.04.03 13:54:43 INFO  time: compiled root in 1.48s
2024.04.03 13:55:06 INFO  compiling root (2 scala sources)
2024.04.03 13:55:07 INFO  time: compiled root in 1.23s
2024.04.03 13:55:07 INFO  compiling root (2 scala sources)
2024.04.03 13:55:08 INFO  time: compiled root in 1.08s
2024.04.03 13:55:11 INFO  compiling root (2 scala sources)
Apr 03, 2024 1:55:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3332
2024.04.03 13:55:12 INFO  time: compiled root in 1.09s
2024.04.03 13:55:30 INFO  compiling root (2 scala sources)
2024.04.03 13:55:32 INFO  time: compiled root in 1.44s
2024.04.03 13:55:32 INFO  compiling root (2 scala sources)
2024.04.03 13:55:33 INFO  time: compiled root in 1.18s
Apr 03, 2024 1:56:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3440
Apr 03, 2024 1:56:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3448
2024.04.03 14:12:43 INFO  compiling root (2 scala sources)
2024.04.03 14:12:44 INFO  time: compiled root in 1.58s
2024.04.03 14:12:44 INFO  compiling root (2 scala sources)
2024.04.03 14:12:46 INFO  time: compiled root in 1.75s
Apr 03, 2024 2:13:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3547
2024.04.03 14:13:44 INFO  compiling root (2 scala sources)
2024.04.03 14:13:46 INFO  time: compiled root in 1.36s
2024.04.03 14:13:46 INFO  compiling root (2 scala sources)
2024.04.03 14:13:47 INFO  time: compiled root in 1.11s
2024.04.03 14:13:58 INFO  compiling root (2 scala sources)
2024.04.03 14:14:00 INFO  time: compiled root in 1.45s
2024.04.03 14:14:00 INFO  compiling root (2 scala sources)
2024.04.03 14:14:01 INFO  time: compiled root in 1.12s
2024.04.03 14:15:16 INFO  compiling root (2 scala sources)
2024.04.03 14:15:17 INFO  time: compiled root in 1.59s
2024.04.03 14:15:17 INFO  compiling root (2 scala sources)
2024.04.03 14:15:18 INFO  time: compiled root in 0.95s
2024.04.03 14:15:25 INFO  compiling root (2 scala sources)
2024.04.03 14:15:27 INFO  time: compiled root in 1.15s
2024.04.03 14:15:27 INFO  compiling root (2 scala sources)
2024.04.03 14:15:28 INFO  time: compiled root in 0.98s
Apr 03, 2024 2:17:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3713
2024.04.03 14:17:24 INFO  compiling root (2 scala sources)
2024.04.03 14:17:26 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 14:17:26 INFO  time: compiled root in 2.7s
2024.04.03 14:21:10 INFO  compiling root (1 scala source)
2024.04.03 14:21:12 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 14:21:12 INFO  time: compiled root in 2.83s
2024.04.03 14:23:40 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 35m 34.796s)
2024.04.03 14:23:40 INFO  compiling root (1 scala source)
2024.04.03 14:23:40 INFO  compiling root (1 scala source)
2024.04.03 14:23:42 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 14:23:42 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 14:23:42 INFO  time: compiled root in 2.38s
2024.04.03 14:23:42 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 35m 37.471s)
2024.04.03 14:23:44 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.03 14:23:44 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.03 14:23:44 INFO  Starting debug proxy for [Dashboard]
2024.04.03 14:23:46 INFO  Loaded expression compiler in 1 second
2024.04.03 14:23:46 INFO  /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/ch/epfl/scala/scala-debug-step-filter_3/3.1.6/scala-debug-step-filter_3-3.1.6.jar
2024.04.03 14:23:46 INFO  /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/tasty-core_3/3.3.1/tasty-core_3-3.3.1.jar
2024.04.03 14:23:46 INFO  /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.3.1/scala3-library_3-3.3.1.jar
2024.04.03 14:23:46 INFO  /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/ch/epfl/scala/tasty-query_3/0.9.3/tasty-query_3-0.9.3.jar
2024.04.03 14:23:46 INFO  /Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.10/scala-library-2.13.10.jar
2024.04.03 14:23:46 INFO  Loaded step filter in 99 milliseconds
2024.04.03 14:23:46 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.03 14:23:50 INFO  Loaded all sources and classes in 4 seconds
2024.04.03 14:23:52 INFO  Trying to attach to remote debuggee VM localhost:49793 .
2024.04.03 14:23:52 INFO  Attaching to debuggee VM succeeded.
2024.04.03 14:23:54 INFO  Closing debug server tcp://0.0.0.0:49790
2024.04.03 14:23:56 INFO  Canceling debug proxy for [Dashboard]
Apr 03, 2024 2:30:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4016
Apr 03, 2024 2:43:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4152
Apr 03, 2024 2:43:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4252
2024.04.03 14:44:22 INFO  compiling root (2 scala sources)
2024.04.03 14:44:24 INFO  time: compiled root in 1.88s
2024.04.03 14:44:24 INFO  compiling root (2 scala sources)
2024.04.03 14:44:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 14:44:26 INFO  time: compiled root in 2.75s
2024.04.03 14:45:51 INFO  compiling root (2 scala sources)
2024.04.03 14:45:52 INFO  time: compiled root in 1.47s
2024.04.03 14:45:52 INFO  compiling root (2 scala sources)
2024.04.03 14:45:54 INFO  time: compiled root in 1.72s
2024.04.03 14:46:18 INFO  compiling root (2 scala sources)
2024.04.03 14:46:21 INFO  time: compiled root in 2.41s
2024.04.03 14:46:21 INFO  compiling root (2 scala sources)
2024.04.03 14:46:23 INFO  time: compiled root in 2.02s
2024.04.03 14:46:37 INFO  compiling root (2 scala sources)
2024.04.03 14:46:38 INFO  time: compiled root in 1.37s
2024.04.03 14:46:38 INFO  compiling root (2 scala sources)
2024.04.03 14:46:39 INFO  time: compiled root in 1.16s
2024.04.03 14:46:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 14:47:20 INFO  compiling root (2 scala sources)
2024.04.03 14:47:21 INFO  time: compiled root in 1.09s
2024.04.03 14:47:21 INFO  compiling root (2 scala sources)
2024.04.03 14:47:21 INFO  time: compiled root in 0.89s
2024.04.03 14:47:28 INFO  compiling root (2 scala sources)
2024.04.03 14:47:29 INFO  time: compiled root in 1.08s
2024.04.03 14:47:29 INFO  compiling root (2 scala sources)
2024.04.03 14:47:30 INFO  time: compiled root in 1.14s
2024.04.03 14:48:31 INFO  compiling root (2 scala sources)
2024.04.03 14:48:32 INFO  time: compiled root in 1.07s
2024.04.03 14:48:32 INFO  compiling root (2 scala sources)
2024.04.03 14:48:34 INFO  time: compiled root in 0.98s
2024.04.03 14:48:34 INFO  compiling root (2 scala sources)
2024.04.03 14:48:35 INFO  time: compiled root in 1.78s
2024.04.03 14:48:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 14:48:55 INFO  compiling root (2 scala sources)
2024.04.03 14:48:56 INFO  time: compiled root in 1.01s
2024.04.03 14:48:56 INFO  compiling root (2 scala sources)
2024.04.03 14:48:57 INFO  time: compiled root in 1.04s
2024.04.03 14:53:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 14:53:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 14:55:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 03, 2024 2:55:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4652
2024.04.03 14:58:04 INFO  compiling root (2 scala sources)
2024.04.03 14:58:06 INFO  time: compiled root in 1.44s
2024.04.03 14:58:06 INFO  compiling root (2 scala sources)
2024.04.03 14:58:06 INFO  time: compiled root in 0.86s
2024.04.03 14:58:13 INFO  compiling root (2 scala sources)
2024.04.03 14:58:14 INFO  time: compiled root in 1.03s
2024.04.03 14:58:14 INFO  compiling root (2 scala sources)
2024.04.03 14:58:14 INFO  time: compiled root in 0.83s
Apr 03, 2024 2:58:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4846
2024.04.03 14:58:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 03, 2024 2:59:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4930
2024.04.03 14:59:37 INFO  compiling root (2 scala sources)
2024.04.03 14:59:38 INFO  time: compiled root in 1.1s
2024.04.03 14:59:38 INFO  compiling root (2 scala sources)
2024.04.03 14:59:38 INFO  time: compiled root in 0.87s
Apr 03, 2024 2:59:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.UnsupportedOperationException: tail of empty list
java.util.concurrent.CompletionException: java.lang.UnsupportedOperationException: tail of empty list
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.UnsupportedOperationException: tail of empty list
	at scala.collection.immutable.Nil$.tail(List.scala:664)
	at scala.collection.immutable.Nil$.tail(List.scala:661)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$endPosOfTree$1(CreateCompanionObjectCodeAction.scala:77)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.endPosOfTree(CreateCompanionObjectCodeAction.scala:75)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$5(CreateCompanionObjectCodeAction.scala:61)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$4(CreateCompanionObjectCodeAction.scala:58)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$2(CreateCompanionObjectCodeAction.scala:56)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$1(CreateCompanionObjectCodeAction.scala:55)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.03 14:59:51 INFO  compiling root (2 scala sources)
2024.04.03 14:59:53 INFO  time: compiled root in 1.18s
2024.04.03 14:59:53 INFO  compiling root (2 scala sources)
2024.04.03 14:59:53 INFO  time: compiled root in 0.92s
2024.04.03 15:00:40 INFO  compiling root (2 scala sources)
2024.04.03 15:00:41 INFO  time: compiled root in 1.43s
2024.04.03 15:00:41 INFO  compiling root (2 scala sources)
2024.04.03 15:00:42 INFO  time: compiled root in 1.04s
2024.04.03 15:01:15 INFO  compiling root (2 scala sources)
2024.04.03 15:01:16 INFO  time: compiled root in 1.16s
2024.04.03 15:01:16 INFO  compiling root (2 scala sources)
2024.04.03 15:01:17 INFO  time: compiled root in 1.09s
2024.04.03 15:01:43 INFO  compiling root (2 scala sources)
2024.04.03 15:01:43 INFO  time: compiled root in 0.97s
2024.04.03 15:01:44 INFO  compiling root (2 scala sources)
Apr 03, 2024 3:01:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5174
2024.04.03 15:01:44 INFO  time: compiled root in 0.86s
2024.04.03 15:02:23 INFO  compiling root (2 scala sources)
2024.04.03 15:02:24 INFO  time: compiled root in 1.05s
2024.04.03 15:02:24 INFO  compiling root (2 scala sources)
2024.04.03 15:02:24 INFO  time: compiled root in 0.89s
2024.04.03 15:02:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:41 INFO  compiling root (2 scala sources)
2024.04.03 15:02:42 INFO  time: compiled root in 1.05s
2024.04.03 15:02:42 INFO  compiling root (2 scala sources)
2024.04.03 15:02:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:43 INFO  time: compiled root in 0.94s
2024.04.03 15:02:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 03, 2024 3:02:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5413
2024.04.03 15:02:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:02:59 INFO  compiling root (2 scala sources)
2024.04.03 15:03:01 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:03:01 INFO  time: compiled root in 2.76s
2024.04.03 15:03:28 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.03 15:03:29 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.03 15:03:29 INFO  Starting debug proxy for [Dashboard]
2024.04.03 15:03:29 INFO  Loaded expression compiler in 5 milliseconds
2024.04.03 15:03:29 INFO  Loaded step filter in 0 milliseconds
2024.04.03 15:03:29 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.03 15:03:32 INFO  Loaded all sources and classes in 3 seconds
2024.04.03 15:03:34 INFO  Trying to attach to remote debuggee VM localhost:50515 .
2024.04.03 15:03:34 INFO  Attaching to debuggee VM succeeded.
2024.04.03 15:04:43 INFO  Canceling debug proxy for [Dashboard]
2024.04.03 15:04:43 INFO  Closing debug server tcp://0.0.0.0:50512
2024.04.03 15:04:55 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 2h 16m 49.293s)
2024.04.03 15:04:55 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.03 15:04:55 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.03 15:04:55 INFO  Starting debug proxy for [Dashboard]
2024.04.03 15:04:55 INFO  Loaded expression compiler in 29 milliseconds
2024.04.03 15:04:55 INFO  Loaded step filter in 0 milliseconds
2024.04.03 15:04:55 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.03 15:04:59 INFO  Loaded all sources and classes in 3 seconds
2024.04.03 15:05:00 INFO  Trying to attach to remote debuggee VM localhost:50528 .
2024.04.03 15:05:00 INFO  Attaching to debuggee VM succeeded.
Apr 03, 2024 3:05:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5476
Apr 03, 2024 3:09:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5719
2024.04.03 15:09:55 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 2h 21m 49.569s)
2024.04.03 15:09:55 INFO  compiling root (1 scala source)
2024.04.03 15:09:55 INFO  compiling root (1 scala source)
2024.04.03 15:09:58 INFO  time: compiled root in 3.11s
2024.04.03 15:09:58 INFO  compiling root (1 scala source)
2024.04.03 15:10:00 INFO  time: compiled root in 1.83s
2024.04.03 15:10:00 INFO  {
  "jsonrpc": "2.0",
  "id": "558",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.03 15:10:00 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

error while checking new Pane(
  makeChart("Pie", graphData.flightPerHourData(getAllFlightData()), "Time",
    "Airplanes flown", "Airplanes flown each hour") = null
)
error while checking val defaultChart =
  new Pane(
    makeChart("Pie", graphData.flightPerHourData(getAllFlightData()), "Time",
      "Airplanes flown", "Airplanes flown each hour") = null
  )
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val colorItem = new MenuItem("Color")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(colorItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  val defaultChart =
    new Pane(
      makeChart("Pie", graphData.flightPerHourData(getAllFlightData()), "Time",
        "Airplanes flown", "Airplanes flown each hour") = null
    )
  <empty>
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val colorItem = new MenuItem("Color")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(colorItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    val defaultChart =
      new Pane(
        makeChart("Pie", graphData.flightPerHourData(getAllFlightData()),
          "Time", "Airplanes flown", "Airplanes flown each hour") = null
      )
    <empty>
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      val defaultChart =
        new Pane(
          makeChart("Pie", graphData.flightPerHourData(getAllFlightData()),
            "Time", "Airplanes flown", "Airplanes flown each hour") = null
        )
      <empty>
    }
  var selectedDatasetM = datasetComboBoxM.value.value
  var selectedDepArrM = deparrComboBoxC.value.value
  var selectedView = viewComboBox.value.value
  if loaded == 0 then
    depArrData =
      selectedDepArrM match
        {
          case "All" =>
            getAllFlightData()
          case "Departing" =>
            getDepFlightData()
          case "Arriving" =>
            getArrFlightData()
        }
  newContent =
    {
      newCBoxes.children.clear()
      newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
        removeButton, addButton)
      (
        metric.addMetric(getMetricData(selectedDatasetM, depArrData)._2,
          getMetricData(selectedDatasetM, depArrData)._1)
      )
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      val defaultChart =
        new Pane(
          makeChart("Pie", graphData.flightPerHourData(getAllFlightData()),
            "Time", "Airplanes flown", "Airplanes flown each hour") = null
        )
      <empty>
    }
  var selectedDatasetM = datasetComboBoxM.value.value
  var selectedDepArrM = deparrComboBoxC.value.value
  var selectedView = viewComboBox.value.value
  if loaded == 0 then
    depArrData =
      selectedDepArrM match
        {
          case "All" =>
            getAllFlightData()
          case "Departing" =>
            getDepFlightData()
          case "Arriving" =>
            getArrFlightData()
        }
  newContent =
    {
      newCBoxes.children.clear()
      newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
        removeButton, addButton)
      (
        metric.addMetric(getMetricData(selectedDatasetM, depArrData)._2,
          getMetricData(selectedDatasetM, depArrData)._1)
      )
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val colorItem = new MenuItem("Color")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(colorItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        val defaultChart =
          new Pane(
            makeChart("Pie", graphData.flightPerHourData(getAllFlightData()),
              "Time", "Airplanes flown", "Airplanes flown each hour") = null
          )
        <empty>
      }
    var selectedDatasetM = datasetComboBoxM.value.value
    var selectedDepArrM = deparrComboBoxC.value.value
    var selectedView = viewComboBox.value.value
    if loaded == 0 then
      depArrData =
        selectedDepArrM match
          {
            case "All" =>
              getAllFlightData()
            case "Departing" =>
              getDepFlightData()
            case "Arriving" =>
              getArrFlightData()
          }
    newContent =
      {
        newCBoxes.children.clear()
        newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
          removeButton, addButton)
        (
          metric.addMetric(getMetricData(selectedDatasetM, depArrData)._2,
            getMetricData(selectedDatasetM, depArrData)._1)
        )
      }
  }
  val border = new BorderPane()
}
Apr 03, 2024 3:10:23 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-03/r_compiler-error_(root)_15-10-23-071.md
2024.04.03 15:10:23 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 15:10:27 INFO  compiling root (1 scala source)
2024.04.03 15:10:30 INFO  time: compiled root in 2.36s
2024.04.03 15:11:14 INFO  compiling root (1 scala source)
2024.04.03 15:11:16 INFO  time: compiled root in 1.86s
2024.04.03 15:12:08 INFO  compiling root (1 scala source)
2024.04.03 15:12:10 INFO  time: compiled root in 2.25s
2024.04.03 15:12:13 INFO  Canceling debug proxy for [Dashboard]
2024.04.03 15:12:13 INFO  Closing debug server tcp://0.0.0.0:50525
2024.04.03 15:12:15 INFO  compiling root (1 scala source)
2024.04.03 15:12:18 INFO  time: compiled root in 3.41s
2024.04.03 15:14:12 INFO  compiling root (1 scala source)
2024.04.03 15:14:14 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:14:14 INFO  time: compiled root in 1.98s
2024.04.03 15:41:09 INFO  compiling root (1 scala source)
2024.04.03 15:41:09 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 2h 53m 3.919s)
2024.04.03 15:41:09 INFO  compiling root (1 scala source)
2024.04.03 15:41:11 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:41:11 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:41:11 INFO  time: compiled root in 1.33s
2024.04.03 15:41:11 INFO  compiling root (1 scala source)
2024.04.03 15:41:11 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 2h 53m 5.329s)
2024.04.03 15:41:11 INFO  compiling root (1 scala source)
2024.04.03 15:41:12 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:41:12 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:41:12 INFO  time: compiled root in 1.04s
2024.04.03 15:41:12 INFO  {
  "jsonrpc": "2.0",
  "id": "604",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.03 15:41:12 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 03, 2024 3:42:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.UnsupportedOperationException: tail of empty list
java.util.concurrent.CompletionException: java.lang.UnsupportedOperationException: tail of empty list
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.UnsupportedOperationException: tail of empty list
	at scala.collection.immutable.Nil$.tail(List.scala:664)
	at scala.collection.immutable.Nil$.tail(List.scala:661)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$endPosOfTree$1(CreateCompanionObjectCodeAction.scala:77)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.endPosOfTree(CreateCompanionObjectCodeAction.scala:75)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$5(CreateCompanionObjectCodeAction.scala:61)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$4(CreateCompanionObjectCodeAction.scala:58)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$2(CreateCompanionObjectCodeAction.scala:56)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$1(CreateCompanionObjectCodeAction.scala:55)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.03 15:43:05 INFO  compiling root (2 scala sources)
2024.04.03 15:43:06 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:43:06 INFO  time: compiled root in 1.29s
2024.04.03 15:43:06 INFO  compiling root (2 scala sources)
2024.04.03 15:43:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 15:43:08 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:43:08 INFO  time: compiled root in 1.46s
2024.04.03 15:43:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/Metric.scala
2024.04.03 15:43:18 INFO  compiling root (2 scala sources)
2024.04.03 15:43:19 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:43:19 INFO  time: compiled root in 1.27s
2024.04.03 15:45:37 INFO  compiling root (2 scala sources)
2024.04.03 15:45:39 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:45:39 INFO  time: compiled root in 1.79s
2024.04.03 15:50:19 INFO  compiling root (1 scala source)
2024.04.03 15:50:19 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 3h 2m 13.458s)
2024.04.03 15:50:19 INFO  compiling root (1 scala source)
2024.04.03 15:50:20 INFO  time: compiled root in 1.08s
2024.04.03 15:50:20 INFO  compiling root (1 scala source)
2024.04.03 15:50:20 INFO  time: compiled root in 0.87s
2024.04.03 15:50:21 INFO  {
  "jsonrpc": "2.0",
  "id": "642",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.03 15:50:21 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 15:50:20 INFO  compiling root (1 scala source)
2024.04.03 15:50:22 INFO  time: compiled root in 0.83s
2024.04.03 15:50:33 INFO  compiling root (1 scala source)
2024.04.03 15:50:34 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:50:34 INFO  time: compiled root in 1.17s
2024.04.03 15:50:34 INFO  compiling root (1 scala source)
2024.04.03 15:50:35 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:50:35 INFO  time: compiled root in 1.01s
2024.04.03 15:51:18 INFO  compiling root (1 scala source)
2024.04.03 15:51:19 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:51:19 INFO  time: compiled root in 1.22s
2024.04.03 15:51:23 INFO  compiling root (1 scala source)
2024.04.03 15:51:24 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:51:24 INFO  time: compiled root in 1.37s
2024.04.03 15:52:40 INFO  compiling root (1 scala source)
2024.04.03 15:52:42 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:52:42 INFO  time: compiled root in 2.17s
2024.04.03 15:54:58 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 3h 6m 52.208s)
2024.04.03 15:54:58 INFO  compiling root (1 scala source)
2024.04.03 15:54:58 INFO  compiling root (1 scala source)
2024.04.03 15:55:00 INFO  time: compiled root in 2.19s
2024.04.03 15:55:00 INFO  compiling root (1 scala source)
2024.04.03 15:55:02 INFO  time: compiled root in 2.23s
2024.04.03 15:55:02 INFO  compiling root (1 scala source)
2024.04.03 15:55:04 INFO  time: compiled root in 1.71s
2024.04.03 15:55:04 INFO  {
  "jsonrpc": "2.0",
  "id": "686",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.03 15:55:04 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 15:55:07 INFO  compiling root (1 scala source)
2024.04.03 15:55:09 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 15:55:09 INFO  time: compiled root in 1.56s
2024.04.03 15:58:55 INFO  compiling root (1 scala source)
2024.04.03 15:58:55 INFO  time: compiled root in 0.5s
2024.04.03 15:58:55 INFO  compiling root (1 scala source)
2024.04.03 15:58:56 INFO  time: compiled root in 0.43s
2024.04.03 15:59:36 INFO  compiling root (1 scala source)
2024.04.03 15:59:36 INFO  time: compiled root in 0.52s
2024.04.03 15:59:49 INFO  compiling root (1 scala source)
2024.04.03 15:59:49 INFO  time: compiled root in 0.42s
2024.04.03 15:59:49 INFO  compiling root (1 scala source)
2024.04.03 15:59:50 INFO  time: compiled root in 0.71s
2024.04.03 16:00:45 INFO  compiling root (1 scala source)
2024.04.03 16:00:45 INFO  time: compiled root in 0.51s
2024.04.03 16:00:45 INFO  compiling root (1 scala source)
2024.04.03 16:00:45 INFO  time: compiled root in 0.44s
2024.04.03 16:00:52 INFO  compiling root (1 scala source)
2024.04.03 16:00:52 INFO  time: compiled root in 0.36s
2024.04.03 16:00:52 INFO  compiling root (1 scala source)
2024.04.03 16:00:52 INFO  time: compiled root in 0.4s
2024.04.03 16:01:18 INFO  compiling root (1 scala source)
2024.04.03 16:01:19 INFO  time: compiled root in 1.23s
2024.04.03 16:03:16 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:289: error: unclosed string literal
              if viewComboBox.value.value == "CupdateChart())
                                             ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 16:03:17 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:289: error: unclosed string literal
              if viewComboBox.value.value == "CharupdateChart())
                                             ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 16:03:17 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:289: error: unclosed string literal
              if viewComboBox.value.value == "Chart updateChart())
                                             ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 16:03:18 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:289: error: unclosed string literal
              if viewComboBox.value.value == "Chart ViwupdateChart())
                                             ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 16:03:19 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:289: error: unclosed string literal
              if viewComboBox.value.value == "Chart ViewupdateChart())
                                             ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

error while checking  extends TimerTask {
  def run(): Unit =
    {
      Platform.runLater(
        () =>
          if viewComboBox.value.value == "Chart View" then updateChart() else
            null
      )
    }
}
error while checking new TimerTask {
  def run(): Unit =
    {
      Platform.runLater(
        () =>
          if viewComboBox.value.value == "Chart View" then updateChart() else
            null
      )
    }
}
error while checking timer.scheduleAtFixedRate(
  new TimerTask {
    def run(): Unit =
      {
        Platform.runLater(
          () =>
            if viewComboBox.value.value == "Chart View" then updateChart() else
              null
        )
      }
  }
)
error while checking {
  val timer = new Timer(true)
  val interval = 1.minute.toMillis
  timer.scheduleAtFixedRate(
    new TimerTask {
      def run(): Unit =
        {
          Platform.runLater(
            () =>
              if viewComboBox.value.value == "Chart View" then updateChart()
                 else null
          )
        }
    }
  )
}
error while checking if loaded == 0 then
  {
    val timer = new Timer(true)
    val interval = 1.minute.toMillis
    timer.scheduleAtFixedRate(
      new TimerTask {
        def run(): Unit =
          {
            Platform.runLater(
              () =>
                if viewComboBox.value.value == "Chart View" then updateChart()
                   else null
            )
          }
      }
    )
  }
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  val chartVBox = new VBox(comboBoxHBox1, defaultChart)
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  var newContent: Pane = defaultChart
  val metric = new Metric()
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = viewComboBox
  border.bottom = defaultChart
  def updateChart(): Unit =
    {
      var selectedDepArrC = deparrComboBoxC.value.value
      var selectedDatasetC = datasetComboBoxC.value.value
      var selectedView = viewComboBox.value.value
      var selectedGraph = graphComboBox.value.value
      if loaded == 0 then
        depArrData =
          selectedDepArrC match
            {
              case "All" =>
                getAllFlightData()
              case "Departing" =>
                getDepFlightData()
              case "Arriving" =>
                getArrFlightData()
            }
      val newChart =
        {
          newCBoxes.children.clear()
          newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
            deparrComboBoxC)
          new VBox(
            makeChart(selectedGraph,
              getChartData(selectedDatasetC, depArrData)._1,
              getChartData(selectedDatasetC, depArrData)._2,
              getChartData(selectedDatasetC, depArrData)._3,
              getChartData(selectedDatasetC, depArrData)._4)
          )
        }
      border.bottom = newChart
    }
  def updateMetrics(): Unit =
    {
      var selectedDatasetM = datasetComboBoxM.value.value
      var selectedDepArrM = deparrComboBoxC.value.value
      var selectedView = viewComboBox.value.value
      if loaded == 0 then
        depArrData =
          selectedDepArrM match
            {
              case "All" =>
                getAllFlightData()
              case "Departing" =>
                getDepFlightData()
              case "Arriving" =>
                getArrFlightData()
            }
      val newMetric =
        {
          newCBoxes.children.clear()
          newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
            removeButton, addButton)
          (
            metric.addMetric(getMetricData(selectedDatasetM, depArrData)._2,
              getMetricData(selectedDatasetM, depArrData)._1)
          )
        }
      border.bottom = newMetric
    }
  graphComboBox.onAction = () => updateChart()
  datasetComboBoxC.onAction = () => updateChart()
  datasetComboBoxM.onAction = () => updateChart()
  deparrComboBoxC.onAction = () => updateChart()
  deparrComboBoxM.onAction = () => updateChart()
  viewComboBox.onAction =
    () =>
      if (viewComboBox.value.value == "Graph View") updateChart() else
        updateMetrics()
  removeButton.onMousePressed =
    (e: MouseEvent) =>
      {
        if (metric.selectedCard != None)
          {
            metric.removeMetric(metric.selectedCard.get)
            println("pressed")
            metric.selectedCard = None
          }
      }
  exitItem.onAction = (e: ActionEvent) => sys.exit(0)
  saveItem.onAction =
    (e: ActionEvent) =>
      {
        val fileChooser = new FileChooser()
        val selectedFile = fileChooser.showSaveDialog(stage)
        if (selectedFile != null)
          {
            val writer = new java.io.PrintWriter(selectedFile)
            writer.write(xmlFlightData())
            writer.close()
          }
      }
  openItem.onAction =
    (e: ActionEvent) =>
      {
        val fileChooser = new FileChooser()
        val selectedFile = fileChooser.showOpenDialog(stage)
        if (selectedFile != null)
          {
            try
              {
                val fileContent =
                  scala.io.Source.fromFile(selectedFile).mkString
                depArrData = getLoadedFlightData("all", fileContent)
                loaded = 1
                updateChart()
              }
             catch {
              {
                case ex:Exception =>
                  ex.printStackTrace()
              }
            }
          }
      }
  if loaded == 0 then
    {
      val timer = new Timer(true)
      val interval = 1.minute.toMillis
      timer.scheduleAtFixedRate(
        new TimerTask {
          def run(): Unit =
            {
              Platform.runLater(
                () =>
                  if viewComboBox.value.value == "Chart View" then updateChart()
                     else null
              )
            }
        }
      )
    }
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    val chartVBox = new VBox(comboBoxHBox1, defaultChart)
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    var newContent: Pane = defaultChart
    val metric = new Metric()
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = viewComboBox
    border.bottom = defaultChart
    def updateChart(): Unit =
      {
        var selectedDepArrC = deparrComboBoxC.value.value
        var selectedDatasetC = datasetComboBoxC.value.value
        var selectedView = viewComboBox.value.value
        var selectedGraph = graphComboBox.value.value
        if loaded == 0 then
          depArrData =
            selectedDepArrC match
              {
                case "All" =>
                  getAllFlightData()
                case "Departing" =>
                  getDepFlightData()
                case "Arriving" =>
                  getArrFlightData()
              }
        val newChart =
          {
            newCBoxes.children.clear()
            newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
              deparrComboBoxC)
            new VBox(
              makeChart(selectedGraph,
                getChartData(selectedDatasetC, depArrData)._1,
                getChartData(selectedDatasetC, depArrData)._2,
                getChartData(selectedDatasetC, depArrData)._3,
                getChartData(selectedDatasetC, depArrData)._4)
            )
          }
        border.bottom = newChart
      }
    def updateMetrics(): Unit =
      {
        var selectedDatasetM = datasetComboBoxM.value.value
        var selectedDepArrM = deparrComboBoxC.value.value
        var selectedView = viewComboBox.value.value
        if loaded == 0 then
          depArrData =
            selectedDepArrM match
              {
                case "All" =>
                  getAllFlightData()
                case "Departing" =>
                  getDepFlightData()
                case "Arriving" =>
                  getArrFlightData()
              }
        val newMetric =
          {
            newCBoxes.children.clear()
            newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
              removeButton, addButton)
            (
              metric.addMetric(getMetricData(selectedDatasetM, depArrData)._2,
                getMetricData(selectedDatasetM, depArrData)._1)
            )
          }
        border.bottom = newMetric
      }
    graphComboBox.onAction = () => updateChart()
    datasetComboBoxC.onAction = () => updateChart()
    datasetComboBoxM.onAction = () => updateChart()
    deparrComboBoxC.onAction = () => updateChart()
    deparrComboBoxM.onAction = () => updateChart()
    viewComboBox.onAction =
      () =>
        if (viewComboBox.value.value == "Graph View") updateChart() else
          updateMetrics()
    removeButton.onMousePressed =
      (e: MouseEvent) =>
        {
          if (metric.selectedCard != None)
            {
              metric.removeMetric(metric.selectedCard.get)
              println("pressed")
              metric.selectedCard = None
            }
        }
    exitItem.onAction = (e: ActionEvent) => sys.exit(0)
    saveItem.onAction =
      (e: ActionEvent) =>
        {
          val fileChooser = new FileChooser()
          val selectedFile = fileChooser.showSaveDialog(stage)
          if (selectedFile != null)
            {
              val writer = new java.io.PrintWriter(selectedFile)
              writer.write(xmlFlightData())
              writer.close()
            }
        }
    openItem.onAction =
      (e: ActionEvent) =>
        {
          val fileChooser = new FileChooser()
          val selectedFile = fileChooser.showOpenDialog(stage)
          if (selectedFile != null)
            {
              try
                {
                  val fileContent =
                    scala.io.Source.fromFile(selectedFile).mkString
                  depArrData = getLoadedFlightData("all", fileContent)
                  loaded = 1
                  updateChart()
                }
               catch {
                {
                  case ex:Exception =>
                    ex.printStackTrace()
                }
              }
            }
        }
    if loaded == 0 then
      {
        val timer = new Timer(true)
        val interval = 1.minute.toMillis
        timer.scheduleAtFixedRate(
          new TimerTask {
            def run(): Unit =
              {
                Platform.runLater(
                  () =>
                    if viewComboBox.value.value == "Chart View" then
                      updateChart() else null
                )
              }
          }
        )
      }
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val colorItem = new MenuItem("Color")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(colorItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  val defaultChart = new Pane()
  defaultChart.getChildren().addAll(
    makeChart("Pie", graphData.flightPerHourData(getAllFlightData()), "Time",
      "Airplanes flown", "Airplanes flown each hour")
  )
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      val chartVBox = new VBox(comboBoxHBox1, defaultChart)
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      var newContent: Pane = defaultChart
      val metric = new Metric()
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = viewComboBox
      border.bottom = defaultChart
      def updateChart(): Unit =
        {
          var selectedDepArrC = deparrComboBoxC.value.value
          var selectedDatasetC = datasetComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          var selectedGraph = graphComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrC match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          val newChart =
            {
              newCBoxes.children.clear()
              newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                deparrComboBoxC)
              new VBox(
                makeChart(selectedGraph,
                  getChartData(selectedDatasetC, depArrData)._1,
                  getChartData(selectedDatasetC, depArrData)._2,
                  getChartData(selectedDatasetC, depArrData)._3,
                  getChartData(selectedDatasetC, depArrData)._4)
              )
            }
          border.bottom = newChart
        }
      def updateMetrics(): Unit =
        {
          var selectedDatasetM = datasetComboBoxM.value.value
          var selectedDepArrM = deparrComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrM match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          val newMetric =
            {
              newCBoxes.children.clear()
              newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
                removeButton, addButton)
              (
                metric.addMetric(
                  getMetricData(selectedDatasetM, depArrData)._2,
                  getMetricData(selectedDatasetM, depArrData)._1)
              )
            }
          border.bottom = newMetric
        }
      graphComboBox.onAction = () => updateChart()
      datasetComboBoxC.onAction = () => updateChart()
      datasetComboBoxM.onAction = () => updateChart()
      deparrComboBoxC.onAction = () => updateChart()
      deparrComboBoxM.onAction = () => updateChart()
      viewComboBox.onAction =
        () =>
          if (viewComboBox.value.value == "Graph View") updateChart() else
            updateMetrics()
      removeButton.onMousePressed =
        (e: MouseEvent) =>
          {
            if (metric.selectedCard != None)
              {
                metric.removeMetric(metric.selectedCard.get)
                println("pressed")
                metric.selectedCard = None
              }
          }
      exitItem.onAction = (e: ActionEvent) => sys.exit(0)
      saveItem.onAction =
        (e: ActionEvent) =>
          {
            val fileChooser = new FileChooser()
            val selectedFile = fileChooser.showSaveDialog(stage)
            if (selectedFile != null)
              {
                val writer = new java.io.PrintWriter(selectedFile)
                writer.write(xmlFlightData())
                writer.close()
              }
          }
      openItem.onAction =
        (e: ActionEvent) =>
          {
            val fileChooser = new FileChooser()
            val selectedFile = fileChooser.showOpenDialog(stage)
            if (selectedFile != null)
              {
                try
                  {
                    val fileContent =
                      scala.io.Source.fromFile(selectedFile).mkString
                    depArrData = getLoadedFlightData("all", fileContent)
                    loaded = 1
                    updateChart()
                  }
                 catch {
                  {
                    case ex:Exception =>
                      ex.printStackTrace()
                  }
                }
              }
          }
      if loaded == 0 then
        {
          val timer = new Timer(true)
          val interval = 1.minute.toMillis
          timer.scheduleAtFixedRate(
            new TimerTask {
              def run(): Unit =
                {
                  Platform.runLater(
                    () =>
                      if viewComboBox.value.value == "Chart View" then
                        updateChart() else null
                  )
                }
            }
          )
        }
    }
  <empty>
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val colorItem = new MenuItem("Color")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(colorItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    val defaultChart = new Pane()
    defaultChart.getChildren().addAll(
      makeChart("Pie", graphData.flightPerHourData(getAllFlightData()), "Time",
        "Airplanes flown", "Airplanes flown each hour")
    )
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        val chartVBox = new VBox(comboBoxHBox1, defaultChart)
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        var newContent: Pane = defaultChart
        val metric = new Metric()
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = viewComboBox
        border.bottom = defaultChart
        def updateChart(): Unit =
          {
            var selectedDepArrC = deparrComboBoxC.value.value
            var selectedDatasetC = datasetComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            var selectedGraph = graphComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrC match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            val newChart =
              {
                newCBoxes.children.clear()
                newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                  deparrComboBoxC)
                new VBox(
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                )
              }
            border.bottom = newChart
          }
        def updateMetrics(): Unit =
          {
            var selectedDatasetM = datasetComboBoxM.value.value
            var selectedDepArrM = deparrComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrM match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            val newMetric =
              {
                newCBoxes.children.clear()
                newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
                  removeButton, addButton)
                (
                  metric.addMetric(
                    getMetricData(selectedDatasetM, depArrData)._2,
                    getMetricData(selectedDatasetM, depArrData)._1)
                )
              }
            border.bottom = newMetric
          }
        graphComboBox.onAction = () => updateChart()
        datasetComboBoxC.onAction = () => updateChart()
        datasetComboBoxM.onAction = () => updateChart()
        deparrComboBoxC.onAction = () => updateChart()
        deparrComboBoxM.onAction = () => updateChart()
        viewComboBox.onAction =
          () =>
            if (viewComboBox.value.value == "Graph View") updateChart() else
              updateMetrics()
        removeButton.onMousePressed =
          (e: MouseEvent) =>
            {
              if (metric.selectedCard != None)
                {
                  metric.removeMetric(metric.selectedCard.get)
                  println("pressed")
                  metric.selectedCard = None
                }
            }
        exitItem.onAction = (e: ActionEvent) => sys.exit(0)
        saveItem.onAction =
          (e: ActionEvent) =>
            {
              val fileChooser = new FileChooser()
              val selectedFile = fileChooser.showSaveDialog(stage)
              if (selectedFile != null)
                {
                  val writer = new java.io.PrintWriter(selectedFile)
                  writer.write(xmlFlightData())
                  writer.close()
                }
            }
        openItem.onAction =
          (e: ActionEvent) =>
            {
              val fileChooser = new FileChooser()
              val selectedFile = fileChooser.showOpenDialog(stage)
              if (selectedFile != null)
                {
                  try
                    {
                      val fileContent =
                        scala.io.Source.fromFile(selectedFile).mkString
                      depArrData = getLoadedFlightData("all", fileContent)
                      loaded = 1
                      updateChart()
                    }
                   catch {
                    {
                      case ex:Exception =>
                        ex.printStackTrace()
                    }
                  }
                }
            }
        if loaded == 0 then
          {
            val timer = new Timer(true)
            val interval = 1.minute.toMillis
            timer.scheduleAtFixedRate(
              new TimerTask {
                def run(): Unit =
                  {
                    Platform.runLater(
                      () =>
                        if viewComboBox.value.value == "Chart View" then
                          updateChart() else null
                    )
                  }
              }
            )
          }
      }
    <empty>
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      val defaultChart = new Pane()
      defaultChart.getChildren().addAll(
        makeChart("Pie", graphData.flightPerHourData(getAllFlightData()),
          "Time", "Airplanes flown", "Airplanes flown each hour")
      )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          val chartVBox = new VBox(comboBoxHBox1, defaultChart)
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          var newContent: Pane = defaultChart
          val metric = new Metric()
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = defaultChart
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                {
                  newCBoxes.children.clear()
                  newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                    deparrComboBoxC)
                  new VBox(
                    makeChart(selectedGraph,
                      getChartData(selectedDatasetC, depArrData)._1,
                      getChartData(selectedDatasetC, depArrData)._2,
                      getChartData(selectedDatasetC, depArrData)._3,
                      getChartData(selectedDatasetC, depArrData)._4)
                  )
                }
              border.bottom = newChart
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newMetric =
                {
                  newCBoxes.children.clear()
                  newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
                    removeButton, addButton)
                  (
                    metric.addMetric(
                      getMetricData(selectedDatasetM, depArrData)._2,
                      getMetricData(selectedDatasetM, depArrData)._1)
                  )
                }
              border.bottom = newMetric
            }
          graphComboBox.onAction = () => updateChart()
          datasetComboBoxC.onAction = () => updateChart()
          datasetComboBoxM.onAction = () => updateChart()
          deparrComboBoxC.onAction = () => updateChart()
          deparrComboBoxM.onAction = () => updateChart()
          viewComboBox.onAction =
            () =>
              if (viewComboBox.value.value == "Graph View") updateChart() else
                updateMetrics()
          removeButton.onMousePressed =
            (e: MouseEvent) =>
              {
                if (metric.selectedCard != None)
                  {
                    metric.removeMetric(metric.selectedCard.get)
                    println("pressed")
                    metric.selectedCard = None
                  }
              }
          exitItem.onAction = (e: ActionEvent) => sys.exit(0)
          saveItem.onAction =
            (e: ActionEvent) =>
              {
                val fileChooser = new FileChooser()
                val selectedFile = fileChooser.showSaveDialog(stage)
                if (selectedFile != null)
                  {
                    val writer = new java.io.PrintWriter(selectedFile)
                    writer.write(xmlFlightData())
                    writer.close()
                  }
              }
          openItem.onAction =
            (e: ActionEvent) =>
              {
                val fileChooser = new FileChooser()
                val selectedFile = fileChooser.showOpenDialog(stage)
                if (selectedFile != null)
                  {
                    try
                      {
                        val fileContent =
                          scala.io.Source.fromFile(selectedFile).mkString
                        depArrData = getLoadedFlightData("all", fileContent)
                        loaded = 1
                        updateChart()
                      }
                     catch {
                      {
                        case ex:Exception =>
                          ex.printStackTrace()
                      }
                    }
                  }
              }
          if loaded == 0 then
            {
              val timer = new Timer(true)
              val interval = 1.minute.toMillis
              timer.scheduleAtFixedRate(
                new TimerTask {
                  def run(): Unit =
                    {
                      Platform.runLater(
                        () =>
                          if viewComboBox.value.value == "Chart View" then
                            updateChart() else null
                      )
                    }
                }
              )
            }
        }
      <empty>
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      val defaultChart = new Pane()
      defaultChart.getChildren().addAll(
        makeChart("Pie", graphData.flightPerHourData(getAllFlightData()),
          "Time", "Airplanes flown", "Airplanes flown each hour")
      )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          val chartVBox = new VBox(comboBoxHBox1, defaultChart)
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          var newContent: Pane = defaultChart
          val metric = new Metric()
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = defaultChart
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                {
                  newCBoxes.children.clear()
                  newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                    deparrComboBoxC)
                  new VBox(
                    makeChart(selectedGraph,
                      getChartData(selectedDatasetC, depArrData)._1,
                      getChartData(selectedDatasetC, depArrData)._2,
                      getChartData(selectedDatasetC, depArrData)._3,
                      getChartData(selectedDatasetC, depArrData)._4)
                  )
                }
              border.bottom = newChart
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newMetric =
                {
                  newCBoxes.children.clear()
                  newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
                    removeButton, addButton)
                  (
                    metric.addMetric(
                      getMetricData(selectedDatasetM, depArrData)._2,
                      getMetricData(selectedDatasetM, depArrData)._1)
                  )
                }
              border.bottom = newMetric
            }
          graphComboBox.onAction = () => updateChart()
          datasetComboBoxC.onAction = () => updateChart()
          datasetComboBoxM.onAction = () => updateChart()
          deparrComboBoxC.onAction = () => updateChart()
          deparrComboBoxM.onAction = () => updateChart()
          viewComboBox.onAction =
            () =>
              if (viewComboBox.value.value == "Graph View") updateChart() else
                updateMetrics()
          removeButton.onMousePressed =
            (e: MouseEvent) =>
              {
                if (metric.selectedCard != None)
                  {
                    metric.removeMetric(metric.selectedCard.get)
                    println("pressed")
                    metric.selectedCard = None
                  }
              }
          exitItem.onAction = (e: ActionEvent) => sys.exit(0)
          saveItem.onAction =
            (e: ActionEvent) =>
              {
                val fileChooser = new FileChooser()
                val selectedFile = fileChooser.showSaveDialog(stage)
                if (selectedFile != null)
                  {
                    val writer = new java.io.PrintWriter(selectedFile)
                    writer.write(xmlFlightData())
                    writer.close()
                  }
              }
          openItem.onAction =
            (e: ActionEvent) =>
              {
                val fileChooser = new FileChooser()
                val selectedFile = fileChooser.showOpenDialog(stage)
                if (selectedFile != null)
                  {
                    try
                      {
                        val fileContent =
                          scala.io.Source.fromFile(selectedFile).mkString
                        depArrData = getLoadedFlightData("all", fileContent)
                        loaded = 1
                        updateChart()
                      }
                     catch {
                      {
                        case ex:Exception =>
                          ex.printStackTrace()
                      }
                    }
                  }
              }
          if loaded == 0 then
            {
              val timer = new Timer(true)
              val interval = 1.minute.toMillis
              timer.scheduleAtFixedRate(
                new TimerTask {
                  def run(): Unit =
                    {
                      Platform.runLater(
                        () =>
                          if viewComboBox.value.value == "Chart View" then
                            updateChart() else null
                      )
                    }
                }
              )
            }
        }
      <empty>
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val colorItem = new MenuItem("Color")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(colorItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        val defaultChart = new Pane()
        defaultChart.getChildren().addAll(
          makeChart("Pie", graphData.flightPerHourData(getAllFlightData()),
            "Time", "Airplanes flown", "Airplanes flown each hour")
        )
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            val chartVBox = new VBox(comboBoxHBox1, defaultChart)
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            var newContent: Pane = defaultChart
            val metric = new Metric()
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = defaultChart
            def updateChart(): Unit =
              {
                var selectedDepArrC = deparrComboBoxC.value.value
                var selectedDatasetC = datasetComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                var selectedGraph = graphComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrC match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                val newChart =
                  {
                    newCBoxes.children.clear()
                    newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                      deparrComboBoxC)
                    new VBox(
                      makeChart(selectedGraph,
                        getChartData(selectedDatasetC, depArrData)._1,
                        getChartData(selectedDatasetC, depArrData)._2,
                        getChartData(selectedDatasetC, depArrData)._3,
                        getChartData(selectedDatasetC, depArrData)._4)
                    )
                  }
                border.bottom = newChart
              }
            def updateMetrics(): Unit =
              {
                var selectedDatasetM = datasetComboBoxM.value.value
                var selectedDepArrM = deparrComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrM match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                val newMetric =
                  {
                    newCBoxes.children.clear()
                    newCBoxes.children.addAll(datasetComboBoxM,
                      deparrComboBoxM, removeButton, addButton)
                    (
                      metric.addMetric(
                        getMetricData(selectedDatasetM, depArrData)._2,
                        getMetricData(selectedDatasetM, depArrData)._1)
                    )
                  }
                border.bottom = newMetric
              }
            graphComboBox.onAction = () => updateChart()
            datasetComboBoxC.onAction = () => updateChart()
            datasetComboBoxM.onAction = () => updateChart()
            deparrComboBoxC.onAction = () => updateChart()
            deparrComboBoxM.onAction = () => updateChart()
            viewComboBox.onAction =
              () =>
                if (viewComboBox.value.value == "Graph View") updateChart()
                   else updateMetrics()
            removeButton.onMousePressed =
              (e: MouseEvent) =>
                {
                  if (metric.selectedCard != None)
                    {
                      metric.removeMetric(metric.selectedCard.get)
                      println("pressed")
                      metric.selectedCard = None
                    }
                }
            exitItem.onAction = (e: ActionEvent) => sys.exit(0)
            saveItem.onAction =
              (e: ActionEvent) =>
                {
                  val fileChooser = new FileChooser()
                  val selectedFile = fileChooser.showSaveDialog(stage)
                  if (selectedFile != null)
                    {
                      val writer = new java.io.PrintWriter(selectedFile)
                      writer.write(xmlFlightData())
                      writer.close()
                    }
                }
            openItem.onAction =
              (e: ActionEvent) =>
                {
                  val fileChooser = new FileChooser()
                  val selectedFile = fileChooser.showOpenDialog(stage)
                  if (selectedFile != null)
                    {
                      try
                        {
                          val fileContent =
                            scala.io.Source.fromFile(selectedFile).mkString
                          depArrData = getLoadedFlightData("all", fileContent)
                          loaded = 1
                          updateChart()
                        }
                       catch {
                        {
                          case ex:Exception =>
                            ex.printStackTrace()
                        }
                      }
                    }
                }
            if loaded == 0 then
              {
                val timer = new Timer(true)
                val interval = 1.minute.toMillis
                timer.scheduleAtFixedRate(
                  new TimerTask {
                    def run(): Unit =
                      {
                        Platform.runLater(
                          () =>
                            if viewComboBox.value.value == "Chart View" then
                              updateChart() else null
                        )
                      }
                  }
                )
              }
          }
        <empty>
      }
  }
}
Apr 03, 2024 4:03:24 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-03/r_compiler-error_(root)_16-03-24-952.md
2024.04.03 16:03:24 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 16:03:31 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 3h 15m 25.719s)
2024.04.03 16:03:31 INFO  compiling root (1 scala source)
2024.04.03 16:03:31 INFO  compiling root (1 scala source)
2024.04.03 16:03:33 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 16:03:33 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 16:03:33 INFO  time: compiled root in 1.53s
2024.04.03 16:03:33 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.03 16:03:33 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.03 16:03:33 INFO  Starting debug proxy for [Dashboard]
2024.04.03 16:03:33 INFO  Loaded expression compiler in 5 milliseconds
2024.04.03 16:03:33 INFO  Loaded step filter in 0 milliseconds
2024.04.03 16:03:33 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.03 16:03:35 INFO  Loaded all sources and classes in 2 seconds
2024.04.03 16:03:37 INFO  Trying to attach to remote debuggee VM localhost:50907 .
2024.04.03 16:03:37 INFO  Attaching to debuggee VM succeeded.
2024.04.03 16:05:19 INFO  compiling root (1 scala source)
2024.04.03 16:05:20 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.03 16:05:21 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 16:05:21 INFO  time: compiled root in 1.46s
2024.04.03 16:05:28 INFO  Canceling debug proxy for [Dashboard]
2024.04.03 16:05:28 INFO  Closing debug server tcp://0.0.0.0:50904
2024.04.03 16:07:46 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 3h 19m 40.44s)
2024.04.03 16:07:46 INFO  compiling root (1 scala source)
2024.04.03 16:07:46 INFO  compiling root (1 scala source)
2024.04.03 16:07:48 INFO  time: compiled root in 2.1s
2024.04.03 16:07:48 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 3h 19m 42.723s)
2024.04.03 16:07:48 INFO  compiling root (1 scala source)
2024.04.03 16:07:48 INFO  compiling root (1 scala source)
2024.04.03 16:07:49 INFO  time: compiled root in 1.05s
2024.04.03 16:07:49 INFO  {
  "jsonrpc": "2.0",
  "id": "774",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.03 16:07:49 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 16:07:56 INFO  compiling root (1 scala source)
2024.04.03 16:07:56 INFO  time: compiled root in 0.99s
2024.04.03 16:07:57 INFO  compiling root (1 scala source)
2024.04.03 16:07:57 INFO  time: compiled root in 0.83s
2024.04.03 16:08:26 INFO  compiling root (1 scala source)
2024.04.03 16:08:28 INFO  time: compiled root in 1.99s
2024.04.03 16:08:28 INFO  compiling root (1 scala source)
2024.04.03 16:08:30 INFO  time: compiled root in 2.57s
2024.04.03 16:08:45 INFO  compiling root (1 scala source)
2024.04.03 16:08:47 INFO  time: compiled root in 2.02s
2024.04.03 16:08:47 INFO  compiling root (1 scala source)
2024.04.03 16:08:49 INFO  time: compiled root in 1.56s
2024.04.03 16:08:56 INFO  compiling root (1 scala source)
2024.04.03 16:08:58 INFO  time: compiled root in 1.9s
2024.04.03 16:10:23 INFO  compiling root (1 scala source)
2024.04.03 16:10:25 INFO  time: compiled root in 1.92s
2024.04.03 16:10:29 INFO  compiling root (1 scala source)
2024.04.03 16:10:30 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 16:10:30 INFO  time: compiled root in 1.37s
Apr 03, 2024 4:11:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8716
2024.04.03 16:11:31 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 3h 23m 25.561s)
2024.04.03 16:11:31 INFO  compiling root (1 scala source)
2024.04.03 16:11:31 INFO  compiling root (1 scala source)
2024.04.03 16:11:32 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 16:11:32 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.03 16:11:32 INFO  time: compiled root in 1.51s
2024.04.03 16:11:32 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 3h 23m 27.175s)
2024.04.03 16:11:33 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.03 16:11:33 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.03 16:11:33 INFO  Starting debug proxy for [Dashboard]
2024.04.03 16:11:32 INFO  Loaded expression compiler in 11 milliseconds
2024.04.03 16:11:32 INFO  Loaded step filter in 0 milliseconds
2024.04.03 16:11:32 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.03 16:11:35 INFO  Loaded all sources and classes in 2 seconds
2024.04.03 16:11:37 INFO  Trying to attach to remote debuggee VM localhost:51047 .
2024.04.03 16:11:37 INFO  Attaching to debuggee VM succeeded.
2024.04.03 16:11:55 INFO  Canceling debug proxy for [Dashboard]
2024.04.03 16:11:55 INFO  Closing debug server tcp://0.0.0.0:51044
Apr 04, 2024 10:31:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8819
2024.04.04 10:32:06 INFO  compiling root (1 scala source)
2024.04.04 10:32:10 INFO  time: compiled root in 3.53s
Apr 04, 2024 10:33:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8882
2024.04.04 10:34:35 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 46m 29.739s)
2024.04.04 10:34:35 INFO  compiling root (1 scala source)
2024.04.04 10:34:35 INFO  compiling root (1 scala source)
2024.04.04 10:34:35 INFO  time: compiled root in 0.9s
2024.04.04 10:34:35 INFO  compiling root (1 scala source)
2024.04.04 10:34:37 INFO  time: compiled root in 0.39s
2024.04.04 10:34:37 INFO  compiling root (1 scala source)
2024.04.04 10:34:37 INFO  time: compiled root in 0.57s
2024.04.04 10:34:37 INFO  {
  "jsonrpc": "2.0",
  "id": "865",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 10:34:37 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 10:34:43 INFO  compiling root (1 scala source)
2024.04.04 10:34:45 INFO  time: compiled root in 1.68s
2024.04.04 10:34:45 INFO  compiling root (1 scala source)
2024.04.04 10:34:46 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 10:34:46 INFO  time: compiled root in 1.48s
2024.04.04 10:40:12 INFO  compiling root (1 scala source)
2024.04.04 10:40:12 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 52m 7.004s)
2024.04.04 10:40:12 INFO  compiling root (1 scala source)
2024.04.04 10:40:14 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 10:40:14 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 10:40:14 INFO  time: compiled root in 2.13s
2024.04.04 10:40:14 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 52m 9.219s)
2024.04.04 10:40:15 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 10:40:15 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 10:40:15 INFO  Starting debug proxy for [Dashboard]
2024.04.04 10:40:14 INFO  Loaded expression compiler in 5 milliseconds
2024.04.04 10:40:14 INFO  Loaded step filter in 0 milliseconds
2024.04.04 10:40:14 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 10:40:18 INFO  Loaded all sources and classes in 2 seconds
2024.04.04 10:40:19 INFO  Trying to attach to remote debuggee VM localhost:53566 .
2024.04.04 10:40:19 INFO  Attaching to debuggee VM succeeded.
2024.04.04 10:42:47 INFO  compiling root (1 scala source)
2024.04.04 10:42:49 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 10:42:49 INFO  time: compiled root in 1.49s
2024.04.04 10:42:52 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 10:42:52 INFO  Closing debug server tcp://0.0.0.0:53563
2024.04.04 10:45:40 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 57m 34.985s)
2024.04.04 10:45:40 INFO  compiling root (1 scala source)
2024.04.04 10:45:40 INFO  compiling root (1 scala source)
2024.04.04 10:45:43 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 10:45:43 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 10:45:43 INFO  time: compiled root in 2.76s
2024.04.04 10:45:43 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 21h 57m 37.866s)
2024.04.04 10:45:43 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 10:45:44 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 10:45:44 INFO  Starting debug proxy for [Dashboard]
2024.04.04 10:45:43 INFO  Loaded expression compiler in 2 milliseconds
2024.04.04 10:45:43 INFO  Loaded step filter in 0 milliseconds
2024.04.04 10:45:43 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 10:45:46 INFO  Loaded all sources and classes in 2 seconds
2024.04.04 10:45:48 INFO  Trying to attach to remote debuggee VM localhost:53636 .
2024.04.04 10:45:48 INFO  Attaching to debuggee VM succeeded.
2024.04.04 10:47:12 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 10:47:12 INFO  Closing debug server tcp://0.0.0.0:53633
2024.04.04 10:55:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:55:27 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 22h 7m 21.613s)
2024.04.04 10:55:27 INFO  compiling root (1 scala source)
2024.04.04 10:55:27 INFO  compiling root (1 scala source)
2024.04.04 10:55:30 INFO  time: compiled root in 2.9s
2024.04.04 10:55:30 INFO  compiling root (1 scala source)
2024.04.04 10:55:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:55:33 INFO  time: compiled root in 3.23s
2024.04.04 10:55:33 INFO  {
  "jsonrpc": "2.0",
  "id": "927",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 10:55:33 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 10:55:33 INFO  compiling root (1 scala source)
2024.04.04 10:55:36 INFO  time: compiled root in 2.17s
2024.04.04 10:55:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:55:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:55:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:55:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:55:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:55:55 INFO  compiling root (1 scala source)
2024.04.04 10:55:58 INFO  time: compiled root in 3.05s
2024.04.04 10:55:58 INFO  compiling root (1 scala source)
2024.04.04 10:55:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:02 INFO  time: compiled root in 3.35s
2024.04.04 10:56:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:04 INFO  compiling root (1 scala source)
2024.04.04 10:56:07 INFO  time: compiled root in 2.59s
2024.04.04 10:56:07 INFO  compiling root (1 scala source)
2024.04.04 10:56:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:09 INFO  time: compiled root in 2.02s
2024.04.04 10:56:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:29 INFO  compiling root (1 scala source)
2024.04.04 10:56:32 INFO  time: compiled root in 3.24s
2024.04.04 10:56:32 INFO  compiling root (1 scala source)
2024.04.04 10:56:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:35 INFO  time: compiled root in 2.13s
2024.04.04 10:56:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:56:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 04, 2024 10:57:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10615
Apr 04, 2024 10:57:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10616
2024.04.04 10:57:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:13 INFO  compiling root (1 scala source)
2024.04.04 10:57:16 INFO  time: compiled root in 2.32s
2024.04.04 10:57:16 INFO  compiling root (1 scala source)
2024.04.04 10:57:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:18 INFO  time: compiled root in 1.93s
2024.04.04 10:57:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:20 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:28 INFO  compiling root (1 scala source)
2024.04.04 10:57:30 INFO  time: compiled root in 2.17s
2024.04.04 10:57:30 INFO  compiling root (1 scala source)
2024.04.04 10:57:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 10:57:33 INFO  time: compiled root in 3.52s
2024.04.04 10:57:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 04, 2024 11:00:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10772
2024.04.04 11:00:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:01:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:03:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:03:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:04:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:05:55 INFO  compiling root (1 scala source)
Apr 04, 2024 11:05:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11152
2024.04.04 11:05:58 INFO  time: compiled root in 3.01s
Apr 04, 2024 11:05:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11173
2024.04.04 11:06:00 INFO  compiling root (2 scala sources)
2024.04.04 11:06:04 INFO  time: compiled root in 4.25s
2024.04.04 11:06:04 INFO  compiling root (2 scala sources)
2024.04.04 11:06:07 INFO  time: compiled root in 3.02s
2024.04.04 11:06:16 INFO  compiling root (2 scala sources)
2024.04.04 11:06:19 INFO  time: compiled root in 3.91s
2024.04.04 11:06:19 INFO  compiling root (2 scala sources)
2024.04.04 11:06:23 INFO  time: compiled root in 2.98s
2024.04.04 11:06:23 INFO  compiling root (2 scala sources)
Apr 04, 2024 11:06:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.UnsupportedOperationException: tail of empty list
java.util.concurrent.CompletionException: java.lang.UnsupportedOperationException: tail of empty list
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.UnsupportedOperationException: tail of empty list
	at scala.collection.immutable.Nil$.tail(List.scala:664)
	at scala.collection.immutable.Nil$.tail(List.scala:661)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$endPosOfTree$1(CreateCompanionObjectCodeAction.scala:77)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.endPosOfTree(CreateCompanionObjectCodeAction.scala:75)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$5(CreateCompanionObjectCodeAction.scala:61)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$4(CreateCompanionObjectCodeAction.scala:58)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$2(CreateCompanionObjectCodeAction.scala:56)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$1(CreateCompanionObjectCodeAction.scala:55)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.04 11:06:26 INFO  time: compiled root in 3.13s
2024.04.04 11:06:38 INFO  compiling root (2 scala sources)
2024.04.04 11:06:41 INFO  time: compiled root in 3.01s
2024.04.04 11:06:41 INFO  compiling root (2 scala sources)
2024.04.04 11:06:44 INFO  time: compiled root in 2.74s
2024.04.04 11:06:45 INFO  compiling root (2 scala sources)
2024.04.04 11:06:48 INFO  time: compiled root in 2.42s
2024.04.04 11:06:48 INFO  compiling root (2 scala sources)
2024.04.04 11:06:50 INFO  time: compiled root in 2.03s
2024.04.04 11:09:09 INFO  compiling root (2 scala sources)
2024.04.04 11:09:12 INFO  time: compiled root in 3.55s
2024.04.04 11:09:14 INFO  compiling root (2 scala sources)
2024.04.04 11:09:17 INFO  time: compiled root in 2.58s
2024.04.04 11:09:43 INFO  compiling root (2 scala sources)
2024.04.04 11:09:46 INFO  time: compiled root in 2.54s
2024.04.04 11:09:56 INFO  compiling root (2 scala sources)
2024.04.04 11:10:00 INFO  time: compiled root in 3.6s
2024.04.04 11:10:00 INFO  compiling root (2 scala sources)
2024.04.04 11:10:03 INFO  time: compiled root in 2.75s
2024.04.04 11:10:23 INFO  compiling root (2 scala sources)
2024.04.04 11:10:25 INFO  time: compiled root in 2.35s
2024.04.04 11:10:25 INFO  compiling root (2 scala sources)
2024.04.04 11:10:28 INFO  time: compiled root in 2.34s
2024.04.04 11:11:18 INFO  compiling root (2 scala sources)
2024.04.04 11:11:20 INFO  time: compiled root in 2.49s
2024.04.04 11:11:20 INFO  compiling root (2 scala sources)
2024.04.04 11:11:22 INFO  time: compiled root in 1.8s
Apr 04, 2024 11:11:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11606
2024.04.04 11:13:41 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:13:41 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:13:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:13:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:13:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:13:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:13:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 04, 2024 11:13:49 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11703
2024.04.04 11:13:50 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:14:03 INFO  compiling root (2 scala sources)
2024.04.04 11:14:07 INFO  time: compiled root in 3.56s
2024.04.04 11:14:07 INFO  compiling root (2 scala sources)
2024.04.04 11:14:09 INFO  time: compiled root in 2.46s
2024.04.04 11:14:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:14:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:14:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:14:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:14:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:14:33 INFO  compiling root (2 scala sources)
2024.04.04 11:14:36 INFO  time: compiled root in 2.71s
2024.04.04 11:14:36 INFO  compiling root (2 scala sources)
2024.04.04 11:14:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:14:39 INFO  time: compiled root in 3.27s
2024.04.04 11:14:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:14:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:32:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:32:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:32:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:32:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:32:51 INFO  compiling root (2 scala sources)
2024.04.04 11:32:53 INFO  time: compiled root in 2.46s
2024.04.04 11:32:53 INFO  compiling root (2 scala sources)
2024.04.04 11:32:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:32:55 INFO  time: compiled root in 2.17s
2024.04.04 11:32:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:33:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:33:20 INFO  compiling root (2 scala sources)
2024.04.04 11:33:23 INFO  time: compiled root in 2.45s
2024.04.04 11:33:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:35:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:35:38 INFO  compiling root (2 scala sources)
2024.04.04 11:35:41 INFO  time: compiled root in 3.64s
2024.04.04 11:35:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:35:58 INFO  compiling root (2 scala sources)
2024.04.04 11:36:01 INFO  time: compiled root in 2.63s
2024.04.04 11:36:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:36:56 INFO  compiling root (2 scala sources)
2024.04.04 11:36:59 INFO  time: compiled root in 2.44s
2024.04.04 11:36:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:38:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:38:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:38:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 11:38:24 INFO  compiling root (2 scala sources)
2024.04.04 11:38:25 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 11:38:25 INFO  time: compiled root in 2.1s
Apr 04, 2024 12:16:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12031
2024.04.04 12:17:06 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 23h 29m 0.302s)
2024.04.04 12:17:06 INFO  compiling root (1 scala source)
2024.04.04 12:17:06 INFO  compiling root (1 scala source)
2024.04.04 12:17:07 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:17:07 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:17:07 INFO  time: compiled root in 1.57s
2024.04.04 12:17:08 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 12:17:08 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 12:17:08 INFO  Starting debug proxy for [Dashboard]
2024.04.04 12:17:07 INFO  Loaded expression compiler in 8 milliseconds
2024.04.04 12:17:07 INFO  Loaded step filter in 0 milliseconds
2024.04.04 12:17:07 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 12:17:10 INFO  Loaded all sources and classes in 1 second
2024.04.04 12:17:11 INFO  Trying to attach to remote debuggee VM localhost:54122 .
2024.04.04 12:17:11 INFO  Attaching to debuggee VM succeeded.
Apr 04, 2024 12:32:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12240
2024.04.04 12:36:22 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 23h 48m 16.991s)
2024.04.04 12:36:22 INFO  compiling root (1 scala source)
2024.04.04 12:36:22 INFO  compiling root (1 scala source)
2024.04.04 12:36:25 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:36:25 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:36:25 INFO  time: compiled root in 2.28s
2024.04.04 12:36:25 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 12:36:25 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 12:36:25 INFO  Starting debug proxy for [Dashboard]
2024.04.04 12:36:25 INFO  Loaded expression compiler in 11 milliseconds
2024.04.04 12:36:25 INFO  Loaded step filter in 0 milliseconds
2024.04.04 12:36:25 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 12:36:27 INFO  Loaded all sources and classes in 1 second
2024.04.04 12:36:27 INFO  Trying to attach to remote debuggee VM localhost:54392 .
2024.04.04 12:36:27 INFO  Attaching to debuggee VM succeeded.
2024.04.04 12:38:01 INFO  Closing debug server tcp://0.0.0.0:54389
2024.04.04 12:38:01 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 12:38:03 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 12:38:03 INFO  Closing debug server tcp://0.0.0.0:54119
2024.04.04 12:39:34 INFO  compiling root (1 scala source)
2024.04.04 12:39:35 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:39:35 INFO  time: compiled root in 1.11s
2024.04.04 12:41:52 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 23h 53m 46.546s)
2024.04.04 12:41:52 INFO  compiling root (1 scala source)
2024.04.04 12:41:52 INFO  compiling root (1 scala source)
2024.04.04 12:41:54 INFO  time: compiled root in 1.67s
2024.04.04 12:41:54 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 23h 53m 48.33s)
2024.04.04 12:41:54 INFO  compiling root (1 scala source)
2024.04.04 12:41:54 INFO  compiling root (1 scala source)
2024.04.04 12:41:55 INFO  time: compiled root in 1.02s
2024.04.04 12:41:55 INFO  {
  "jsonrpc": "2.0",
  "id": "1193",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 12:41:55 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 12:42:00 INFO  compiling root (1 scala source)
2024.04.04 12:42:02 INFO  time: compiled root in 1.28s
2024.04.04 12:42:02 INFO  compiling root (1 scala source)
2024.04.04 12:42:03 INFO  time: compiled root in 1.04s
Apr 04, 2024 12:43:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12698
Apr 04, 2024 12:44:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12702
2024.04.04 12:44:03 INFO  compiling root (1 scala source)
2024.04.04 12:44:04 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:44:04 INFO  time: compiled root in 1.11s
Apr 04, 2024 12:46:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12958
2024.04.04 12:46:24 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:225: error: illegal character '\u00b4'
          visible.c´x
                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 04, 2024 12:46:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13078
2024.04.04 12:46:51 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 23h 58m 45.548s)
2024.04.04 12:46:51 INFO  compiling root (1 scala source)
2024.04.04 12:46:51 INFO  compiling root (1 scala source)
2024.04.04 12:46:51 INFO  time: compiled root in 0.6s
2024.04.04 12:46:51 INFO  compiling root (1 scala source)
2024.04.04 12:46:52 INFO  time: compiled root in 0.55s
2024.04.04 12:46:52 INFO  {
  "jsonrpc": "2.0",
  "id": "1221",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 12:46:52 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 12:46:52 INFO  compiling root (1 scala source)
2024.04.04 12:46:52 INFO  time: compiled root in 0.6s
2024.04.04 12:47:06 INFO  compiling root (1 scala source)
2024.04.04 12:47:06 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:47:06 INFO  time: compiled root in 0.89s
Apr 04, 2024 12:48:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13188
2024.04.04 12:48:42 INFO  compiling root (1 scala source)
2024.04.04 12:48:42 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 24h 36.664s)
2024.04.04 12:48:42 INFO  compiling root (1 scala source)
2024.04.04 12:48:42 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:48:42 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:48:42 INFO  time: compiled root in 0.91s
2024.04.04 12:48:43 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 12:48:43 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 12:48:43 INFO  Starting debug proxy for [Dashboard]
2024.04.04 12:48:43 INFO  Loaded expression compiler in 3 milliseconds
2024.04.04 12:48:43 INFO  Loaded step filter in 0 milliseconds
2024.04.04 12:48:43 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 12:48:45 INFO  Loaded all sources and classes in 1 second
2024.04.04 12:48:45 INFO  Trying to attach to remote debuggee VM localhost:54525 .
2024.04.04 12:48:45 INFO  Attaching to debuggee VM succeeded.
Apr 04, 2024 12:52:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13325
2024.04.04 12:52:27 INFO  compiling root (1 scala source)
2024.04.04 12:52:28 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:52:28 INFO  time: compiled root in 1.3s
2024.04.04 12:57:56 INFO  Closing debug server tcp://0.0.0.0:54522
2024.04.04 12:57:56 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 12:57:56 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 24h 9m 51.191s)
2024.04.04 12:57:56 INFO  compiling root (1 scala source)
2024.04.04 12:57:56 INFO  compiling root (1 scala source)
2024.04.04 12:57:58 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:57:58 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 12:57:58 INFO  time: compiled root in 1.56s
2024.04.04 12:57:58 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 24h 9m 52.86s)
2024.04.04 12:57:58 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 12:57:58 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 12:57:58 INFO  Starting debug proxy for [Dashboard]
2024.04.04 12:57:58 INFO  Loaded expression compiler in 2 milliseconds
2024.04.04 12:57:58 INFO  Loaded step filter in 0 milliseconds
2024.04.04 12:57:58 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 12:58:00 INFO  Loaded all sources and classes in 1 second
2024.04.04 12:58:00 INFO  Trying to attach to remote debuggee VM localhost:54657 .
2024.04.04 12:58:00 INFO  Attaching to debuggee VM succeeded.
2024.04.04 13:02:16 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:238: error: illegal character '\u00a7'
          §
          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 13:03:30 INFO  compiling root (1 scala source)
2024.04.04 13:03:32 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:03:32 INFO  time: compiled root in 1.53s
2024.04.04 13:08:01 INFO  compiling root (1 scala source)
2024.04.04 13:08:02 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:08:02 INFO  time: compiled root in 1.33s
2024.04.04 13:09:12 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 13:09:12 INFO  Closing debug server tcp://0.0.0.0:54654
2024.04.04 13:09:16 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 13:09:16 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 13:09:16 INFO  Starting debug proxy for [Dashboard]
2024.04.04 13:09:16 INFO  Loaded expression compiler in 3 milliseconds
2024.04.04 13:09:16 INFO  Loaded step filter in 0 milliseconds
2024.04.04 13:09:16 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 13:09:18 INFO  Loaded all sources and classes in 1 second
2024.04.04 13:09:18 INFO  Trying to attach to remote debuggee VM localhost:54776 .
2024.04.04 13:09:18 INFO  Attaching to debuggee VM succeeded.
2024.04.04 13:10:17 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 24h 22m 11.81s)
2024.04.04 13:10:17 INFO  compiling root (1 scala source)
2024.04.04 13:10:17 INFO  compiling root (1 scala source)
2024.04.04 13:10:19 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:10:19 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:10:19 INFO  time: compiled root in 2.13s
2024.04.04 13:10:19 INFO  Closing debug server tcp://0.0.0.0:54773
2024.04.04 13:10:19 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 13:10:20 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 13:10:20 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 13:10:20 INFO  Starting debug proxy for [Dashboard]
2024.04.04 13:10:19 INFO  Loaded expression compiler in 4 milliseconds
2024.04.04 13:10:19 INFO  Loaded step filter in 0 milliseconds
2024.04.04 13:10:19 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 13:10:21 INFO  Loaded all sources and classes in 1 second
2024.04.04 13:10:21 INFO  Trying to attach to remote debuggee VM localhost:54797 .
2024.04.04 13:10:21 INFO  Attaching to debuggee VM succeeded.
2024.04.04 13:12:39 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 24h 24m 33.947s)
2024.04.04 13:12:39 INFO  compiling root (1 scala source)
2024.04.04 13:12:39 INFO  compiling root (1 scala source)
2024.04.04 13:12:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:12:42 INFO  time: compiled root in 2.75s
2024.04.04 13:12:42 INFO  compiling root (1 scala source)
2024.04.04 13:12:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:12:46 INFO  time: compiled root in 3.27s
2024.04.04 13:12:46 INFO  {
  "jsonrpc": "2.0",
  "id": "1318",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 13:12:46 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 13:14:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:14:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:14:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:14:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:14:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:14:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:14:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:15:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:15:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 04, 2024 1:15:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14289
2024.04.04 13:15:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:15:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:15:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:16:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new VBox(metric.removeMetric(newestMetric) newCBoxes null)
error while checking if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
  new VBox(metric.removeMetric(newestMetric) newCBoxes null)
error while checking visible =
  if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
    new VBox(metric.removeMetric(newestMetric) newCBoxes null)
error while checking {
  var selectedDatasetM = datasetComboBoxM.value.value
  var selectedDepArrM = deparrComboBoxC.value.value
  var selectedView = viewComboBox.value.value
  if loaded == 0 then
    depArrData =
      selectedDepArrM match
        {
          case "All" =>
            getAllFlightData()
          case "Departing" =>
            getDepFlightData()
          case "Arriving" =>
            getArrFlightData()
        }
  visible =
    if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
      new VBox(metric.removeMetric(newestMetric) newCBoxes null)
}
error while checking def updateMetrics(): Unit =
  {
    var selectedDatasetM = datasetComboBoxM.value.value
    var selectedDepArrM = deparrComboBoxC.value.value
    var selectedView = viewComboBox.value.value
    if loaded == 0 then
      depArrData =
        selectedDepArrM match
          {
            case "All" =>
              getAllFlightData()
            case "Departing" =>
              getDepFlightData()
            case "Arriving" =>
              getArrFlightData()
          }
    visible =
      if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
        new VBox(metric.removeMetric(newestMetric) newCBoxes null)
  }
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = viewComboBox
  border.bottom = visible
  updateChart()
  def updateChart(): Unit =
    {
      var selectedDepArrC = deparrComboBoxC.value.value
      var selectedDatasetC = datasetComboBoxC.value.value
      var selectedView = viewComboBox.value.value
      var selectedGraph = graphComboBox.value.value
      if loaded == 0 then
        depArrData =
          selectedDepArrC match
            {
              case "All" =>
                getAllFlightData()
              case "Departing" =>
                getDepFlightData()
              case "Arriving" =>
                getArrFlightData()
            }
      val newChart =
        new VBox(
          makeChart(selectedGraph,
            getChartData(selectedDatasetC, depArrData)._1,
            getChartData(selectedDatasetC, depArrData)._2,
            getChartData(selectedDatasetC, depArrData)._3,
            getChartData(selectedDatasetC, depArrData)._4)
        )
      newCBoxes.children.clear()
      newCBoxes.children.addAll(graphComboBox, datasetComboBoxC, deparrComboBoxC
        )
      visible = newChart
      border.center = newCBoxes
      border.right = viewComboBox
      border.bottom = visible
    }
  def updateMetrics(): Unit =
    {
      var selectedDatasetM = datasetComboBoxM.value.value
      var selectedDepArrM = deparrComboBoxC.value.value
      var selectedView = viewComboBox.value.value
      if loaded == 0 then
        depArrData =
          selectedDepArrM match
            {
              case "All" =>
                getAllFlightData()
              case "Departing" =>
                getDepFlightData()
              case "Arriving" =>
                getArrFlightData()
            }
      visible =
        if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
          new VBox(metric.removeMetric(newestMetric) newCBoxes null)
    }
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = viewComboBox
    border.bottom = visible
    updateChart()
    def updateChart(): Unit =
      {
        var selectedDepArrC = deparrComboBoxC.value.value
        var selectedDatasetC = datasetComboBoxC.value.value
        var selectedView = viewComboBox.value.value
        var selectedGraph = graphComboBox.value.value
        if loaded == 0 then
          depArrData =
            selectedDepArrC match
              {
                case "All" =>
                  getAllFlightData()
                case "Departing" =>
                  getDepFlightData()
                case "Arriving" =>
                  getArrFlightData()
              }
        val newChart =
          new VBox(
            makeChart(selectedGraph,
              getChartData(selectedDatasetC, depArrData)._1,
              getChartData(selectedDatasetC, depArrData)._2,
              getChartData(selectedDatasetC, depArrData)._3,
              getChartData(selectedDatasetC, depArrData)._4)
          )
        newCBoxes.children.clear()
        newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
          deparrComboBoxC)
        visible = newChart
        border.center = newCBoxes
        border.right = viewComboBox
        border.bottom = visible
      }
    def updateMetrics(): Unit =
      {
        var selectedDatasetM = datasetComboBoxM.value.value
        var selectedDepArrM = deparrComboBoxC.value.value
        var selectedView = viewComboBox.value.value
        if loaded == 0 then
          depArrData =
            selectedDepArrM match
              {
                case "All" =>
                  getAllFlightData()
                case "Departing" =>
                  getDepFlightData()
                case "Arriving" =>
                  getArrFlightData()
              }
        visible =
          if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
            new VBox(metric.removeMetric(newestMetric) newCBoxes null)
      }
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val colorItem = new MenuItem("Color")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(colorItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox("")
  val metric = new Metric()
  var removeAdd = 0
  var newestMetric: StackPane =
    metric.makeMetric(getMetricData("Amount", depArrData)._2,
      getMetricData("Amount", depArrData)._1)
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = viewComboBox
      border.bottom = visible
      updateChart()
      def updateChart(): Unit =
        {
          var selectedDepArrC = deparrComboBoxC.value.value
          var selectedDatasetC = datasetComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          var selectedGraph = graphComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrC match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          val newChart =
            new VBox(
              makeChart(selectedGraph,
                getChartData(selectedDatasetC, depArrData)._1,
                getChartData(selectedDatasetC, depArrData)._2,
                getChartData(selectedDatasetC, depArrData)._3,
                getChartData(selectedDatasetC, depArrData)._4)
            )
          newCBoxes.children.clear()
          newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
            deparrComboBoxC)
          visible = newChart
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
        }
      def updateMetrics(): Unit =
        {
          var selectedDatasetM = datasetComboBoxM.value.value
          var selectedDepArrM = deparrComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrM match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          visible =
            if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
               else new VBox(metric.removeMetric(newestMetric) newCBoxes null)
        }
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val colorItem = new MenuItem("Color")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(colorItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox("")
    val metric = new Metric()
    var removeAdd = 0
    var newestMetric: StackPane =
      metric.makeMetric(getMetricData("Amount", depArrData)._2,
        getMetricData("Amount", depArrData)._1)
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = viewComboBox
        border.bottom = visible
        updateChart()
        def updateChart(): Unit =
          {
            var selectedDepArrC = deparrComboBoxC.value.value
            var selectedDatasetC = datasetComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            var selectedGraph = graphComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrC match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            val newChart =
              new VBox(
                makeChart(selectedGraph,
                  getChartData(selectedDatasetC, depArrData)._1,
                  getChartData(selectedDatasetC, depArrData)._2,
                  getChartData(selectedDatasetC, depArrData)._3,
                  getChartData(selectedDatasetC, depArrData)._4)
              )
            newCBoxes.children.clear()
            newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
              deparrComboBoxC)
            visible = newChart
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
          }
        def updateMetrics(): Unit =
          {
            var selectedDatasetM = datasetComboBoxM.value.value
            var selectedDepArrM = deparrComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrM match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            visible =
              if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
                 else new VBox(metric.removeMetric(newestMetric) newCBoxes null)
            }
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox("")
      val metric = new Metric()
      var removeAdd = 0
      var newestMetric: StackPane =
        metric.makeMetric(getMetricData("Amount", depArrData)._2,
          getMetricData("Amount", depArrData)._1)
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
          updateChart()
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                new VBox(
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                )
              newCBoxes.children.clear()
              newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                deparrComboBoxC)
              visible = newChart
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              visible =
                if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
                   else
                  new VBox(metric.removeMetric(newestMetric) newCBoxes null)
            }
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox("")
      val metric = new Metric()
      var removeAdd = 0
      var newestMetric: StackPane =
        metric.makeMetric(getMetricData("Amount", depArrData)._2,
          getMetricData("Amount", depArrData)._1)
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
          updateChart()
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                new VBox(
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                )
              newCBoxes.children.clear()
              newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                deparrComboBoxC)
              visible = newChart
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              visible =
                if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
                   else
                  new VBox(metric.removeMetric(newestMetric) newCBoxes null)
            }
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val colorItem = new MenuItem("Color")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(colorItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox("")
        val metric = new Metric()
        var removeAdd = 0
        var newestMetric: StackPane =
          metric.makeMetric(getMetricData("Amount", depArrData)._2,
            getMetricData("Amount", depArrData)._1)
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
            updateChart()
            def updateChart(): Unit =
              {
                var selectedDepArrC = deparrComboBoxC.value.value
                var selectedDatasetC = datasetComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                var selectedGraph = graphComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrC match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                val newChart =
                  new VBox(
                    makeChart(selectedGraph,
                      getChartData(selectedDatasetC, depArrData)._1,
                      getChartData(selectedDatasetC, depArrData)._2,
                      getChartData(selectedDatasetC, depArrData)._3,
                      getChartData(selectedDatasetC, depArrData)._4)
                  )
                newCBoxes.children.clear()
                newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                  deparrComboBoxC)
                visible = newChart
                border.center = newCBoxes
                border.right = viewComboBox
                border.bottom = visible
              }
            def updateMetrics(): Unit =
              {
                var selectedDatasetM = datasetComboBoxM.value.value
                var selectedDepArrM = deparrComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrM match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                visible =
                  if removeAdd == 1 then
                    new VBox(metric.addMetric(newestMetric)) else
                    new VBox(metric.removeMetric(newestMetric) newCBoxes null)
              }
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 04, 2024 1:17:05 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-04/r_compiler-error_(root)_13-17-05-571.md
2024.04.04 13:17:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new VBox(metric.removeMetric(newestMetric) newCBoxes null)
error while checking if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
  new VBox(metric.removeMetric(newestMetric) newCBoxes null)
error while checking visible =
  if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
    new VBox(metric.removeMetric(newestMetric) newCBoxes null)
error while checking {
  var selectedDatasetM = datasetComboBoxM.value.value
  var selectedDepArrM = deparrComboBoxC.value.value
  var selectedView = viewComboBox.value.value
  if loaded == 0 then
    depArrData =
      selectedDepArrM match
        {
          case "All" =>
            getAllFlightData()
          case "Departing" =>
            getDepFlightData()
          case "Arriving" =>
            getArrFlightData()
        }
  visible =
    if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
      new VBox(metric.removeMetric(newestMetric) newCBoxes null)
}
error while checking def updateMetrics(): Unit =
  {
    var selectedDatasetM = datasetComboBoxM.value.value
    var selectedDepArrM = deparrComboBoxC.value.value
    var selectedView = viewComboBox.value.value
    if loaded == 0 then
      depArrData =
        selectedDepArrM match
          {
            case "All" =>
              getAllFlightData()
            case "Departing" =>
              getDepFlightData()
            case "Arriving" =>
              getArrFlightData()
          }
    visible =
      if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
        new VBox(metric.removeMetric(newestMetric) newCBoxes null)
  }
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = viewComboBox
  border.bottom = visible
  updateChart()
  def updateChart(): Unit =
    {
      var selectedDepArrC = deparrComboBoxC.value.value
      var selectedDatasetC = datasetComboBoxC.value.value
      var selectedView = viewComboBox.value.value
      var selectedGraph = graphComboBox.value.value
      if loaded == 0 then
        depArrData =
          selectedDepArrC match
            {
              case "All" =>
                getAllFlightData()
              case "Departing" =>
                getDepFlightData()
              case "Arriving" =>
                getArrFlightData()
            }
      val newChart =
        new VBox(
          makeChart(selectedGraph,
            getChartData(selectedDatasetC, depArrData)._1,
            getChartData(selectedDatasetC, depArrData)._2,
            getChartData(selectedDatasetC, depArrData)._3,
            getChartData(selectedDatasetC, depArrData)._4)
        )
      newCBoxes.children.clear()
      newCBoxes.children.addAll(graphComboBox, datasetComboBoxC, deparrComboBoxC
        )
      visible = newChart
      border.center = newCBoxes
      border.right = viewComboBox
      border.bottom = visible
    }
  def updateMetrics(): Unit =
    {
      var selectedDatasetM = datasetComboBoxM.value.value
      var selectedDepArrM = deparrComboBoxC.value.value
      var selectedView = viewComboBox.value.value
      if loaded == 0 then
        depArrData =
          selectedDepArrM match
            {
              case "All" =>
                getAllFlightData()
              case "Departing" =>
                getDepFlightData()
              case "Arriving" =>
                getArrFlightData()
            }
      visible =
        if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
          new VBox(metric.removeMetric(newestMetric) newCBoxes null)
    }
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = viewComboBox
    border.bottom = visible
    updateChart()
    def updateChart(): Unit =
      {
        var selectedDepArrC = deparrComboBoxC.value.value
        var selectedDatasetC = datasetComboBoxC.value.value
        var selectedView = viewComboBox.value.value
        var selectedGraph = graphComboBox.value.value
        if loaded == 0 then
          depArrData =
            selectedDepArrC match
              {
                case "All" =>
                  getAllFlightData()
                case "Departing" =>
                  getDepFlightData()
                case "Arriving" =>
                  getArrFlightData()
              }
        val newChart =
          new VBox(
            makeChart(selectedGraph,
              getChartData(selectedDatasetC, depArrData)._1,
              getChartData(selectedDatasetC, depArrData)._2,
              getChartData(selectedDatasetC, depArrData)._3,
              getChartData(selectedDatasetC, depArrData)._4)
          )
        newCBoxes.children.clear()
        newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
          deparrComboBoxC)
        visible = newChart
        border.center = newCBoxes
        border.right = viewComboBox
        border.bottom = visible
      }
    def updateMetrics(): Unit =
      {
        var selectedDatasetM = datasetComboBoxM.value.value
        var selectedDepArrM = deparrComboBoxC.value.value
        var selectedView = viewComboBox.value.value
        if loaded == 0 then
          depArrData =
            selectedDepArrM match
              {
                case "All" =>
                  getAllFlightData()
                case "Departing" =>
                  getDepFlightData()
                case "Arriving" =>
                  getArrFlightData()
              }
        visible =
          if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
            new VBox(metric.removeMetric(newestMetric) newCBoxes null)
      }
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val colorItem = new MenuItem("Color")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(colorItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox("")
  val metric = new Metric()
  var removeAdd = 0
  var newestMetric: StackPane =
    metric.makeMetric(getMetricData("Amount", depArrData)._2,
      getMetricData("Amount", depArrData)._1)
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = viewComboBox
      border.bottom = visible
      updateChart()
      def updateChart(): Unit =
        {
          var selectedDepArrC = deparrComboBoxC.value.value
          var selectedDatasetC = datasetComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          var selectedGraph = graphComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrC match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          val newChart =
            new VBox(
              makeChart(selectedGraph,
                getChartData(selectedDatasetC, depArrData)._1,
                getChartData(selectedDatasetC, depArrData)._2,
                getChartData(selectedDatasetC, depArrData)._3,
                getChartData(selectedDatasetC, depArrData)._4)
            )
          newCBoxes.children.clear()
          newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
            deparrComboBoxC)
          visible = newChart
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
        }
      def updateMetrics(): Unit =
        {
          var selectedDatasetM = datasetComboBoxM.value.value
          var selectedDepArrM = deparrComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrM match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          visible =
            if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
               else new VBox(metric.removeMetric(newestMetric) newCBoxes null)
        }
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val colorItem = new MenuItem("Color")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(colorItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox("")
    val metric = new Metric()
    var removeAdd = 0
    var newestMetric: StackPane =
      metric.makeMetric(getMetricData("Amount", depArrData)._2,
        getMetricData("Amount", depArrData)._1)
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = viewComboBox
        border.bottom = visible
        updateChart()
        def updateChart(): Unit =
          {
            var selectedDepArrC = deparrComboBoxC.value.value
            var selectedDatasetC = datasetComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            var selectedGraph = graphComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrC match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            val newChart =
              new VBox(
                makeChart(selectedGraph,
                  getChartData(selectedDatasetC, depArrData)._1,
                  getChartData(selectedDatasetC, depArrData)._2,
                  getChartData(selectedDatasetC, depArrData)._3,
                  getChartData(selectedDatasetC, depArrData)._4)
              )
            newCBoxes.children.clear()
            newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
              deparrComboBoxC)
            visible = newChart
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
          }
        def updateMetrics(): Unit =
          {
            var selectedDatasetM = datasetComboBoxM.value.value
            var selectedDepArrM = deparrComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrM match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            visible =
              if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
                 else new VBox(metric.removeMetric(newestMetric) newCBoxes null)
            }
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox("")
      val metric = new Metric()
      var removeAdd = 0
      var newestMetric: StackPane =
        metric.makeMetric(getMetricData("Amount", depArrData)._2,
          getMetricData("Amount", depArrData)._1)
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
          updateChart()
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                new VBox(
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                )
              newCBoxes.children.clear()
              newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                deparrComboBoxC)
              visible = newChart
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              visible =
                if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
                   else
                  new VBox(metric.removeMetric(newestMetric) newCBoxes null)
            }
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox("")
      val metric = new Metric()
      var removeAdd = 0
      var newestMetric: StackPane =
        metric.makeMetric(getMetricData("Amount", depArrData)._2,
          getMetricData("Amount", depArrData)._1)
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
          updateChart()
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                new VBox(
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                )
              newCBoxes.children.clear()
              newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                deparrComboBoxC)
              visible = newChart
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              visible =
                if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
                   else
                  new VBox(metric.removeMetric(newestMetric) newCBoxes null)
            }
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val colorItem = new MenuItem("Color")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(colorItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox("")
        val metric = new Metric()
        var removeAdd = 0
        var newestMetric: StackPane =
          metric.makeMetric(getMetricData("Amount", depArrData)._2,
            getMetricData("Amount", depArrData)._1)
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
            updateChart()
            def updateChart(): Unit =
              {
                var selectedDepArrC = deparrComboBoxC.value.value
                var selectedDatasetC = datasetComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                var selectedGraph = graphComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrC match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                val newChart =
                  new VBox(
                    makeChart(selectedGraph,
                      getChartData(selectedDatasetC, depArrData)._1,
                      getChartData(selectedDatasetC, depArrData)._2,
                      getChartData(selectedDatasetC, depArrData)._3,
                      getChartData(selectedDatasetC, depArrData)._4)
                  )
                newCBoxes.children.clear()
                newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                  deparrComboBoxC)
                visible = newChart
                border.center = newCBoxes
                border.right = viewComboBox
                border.bottom = visible
              }
            def updateMetrics(): Unit =
              {
                var selectedDatasetM = datasetComboBoxM.value.value
                var selectedDepArrM = deparrComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrM match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                visible =
                  if removeAdd == 1 then
                    new VBox(metric.addMetric(newestMetric)) else
                    new VBox(metric.removeMetric(newestMetric) newCBoxes null)
              }
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 04, 2024 1:17:05 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-04/r_compiler-error_(root)_13-17-05-845.md
2024.04.04 13:17:05 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new VBox(metric.removeMetric(newestMetric) newCBoxes null)
error while checking if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
  new VBox(metric.removeMetric(newestMetric) newCBoxes null)
error while checking visible =
  if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
    new VBox(metric.removeMetric(newestMetric) newCBoxes null)
error while checking {
  var selectedDatasetM = datasetComboBoxM.value.value
  var selectedDepArrM = deparrComboBoxC.value.value
  var selectedView = viewComboBox.value.value
  if loaded == 0 then
    depArrData =
      selectedDepArrM match
        {
          case "All" =>
            getAllFlightData()
          case "Departing" =>
            getDepFlightData()
          case "Arriving" =>
            getArrFlightData()
        }
  visible =
    if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
      new VBox(metric.removeMetric(newestMetric) newCBoxes null)
}
error while checking def updateMetrics(): Unit =
  {
    var selectedDatasetM = datasetComboBoxM.value.value
    var selectedDepArrM = deparrComboBoxC.value.value
    var selectedView = viewComboBox.value.value
    if loaded == 0 then
      depArrData =
        selectedDepArrM match
          {
            case "All" =>
              getAllFlightData()
            case "Departing" =>
              getDepFlightData()
            case "Arriving" =>
              getArrFlightData()
          }
    visible =
      if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
        new VBox(metric.removeMetric(newestMetric) newCBoxes null)
  }
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = viewComboBox
  border.bottom = visible
  updateChart()
  def updateChart(): Unit =
    {
      var selectedDepArrC = deparrComboBoxC.value.value
      var selectedDatasetC = datasetComboBoxC.value.value
      var selectedView = viewComboBox.value.value
      var selectedGraph = graphComboBox.value.value
      if loaded == 0 then
        depArrData =
          selectedDepArrC match
            {
              case "All" =>
                getAllFlightData()
              case "Departing" =>
                getDepFlightData()
              case "Arriving" =>
                getArrFlightData()
            }
      val newChart =
        new VBox(
          makeChart(selectedGraph,
            getChartData(selectedDatasetC, depArrData)._1,
            getChartData(selectedDatasetC, depArrData)._2,
            getChartData(selectedDatasetC, depArrData)._3,
            getChartData(selectedDatasetC, depArrData)._4)
        )
      newCBoxes.children.clear()
      newCBoxes.children.addAll(graphComboBox, datasetComboBoxC, deparrComboBoxC
        )
      visible = newChart
      border.center = newCBoxes
      border.right = viewComboBox
      border.bottom = visible
    }
  def updateMetrics(): Unit =
    {
      var selectedDatasetM = datasetComboBoxM.value.value
      var selectedDepArrM = deparrComboBoxC.value.value
      var selectedView = viewComboBox.value.value
      if loaded == 0 then
        depArrData =
          selectedDepArrM match
            {
              case "All" =>
                getAllFlightData()
              case "Departing" =>
                getDepFlightData()
              case "Arriving" =>
                getArrFlightData()
            }
      visible =
        if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
          new VBox(metric.removeMetric(newestMetric) newCBoxes null)
    }
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = viewComboBox
    border.bottom = visible
    updateChart()
    def updateChart(): Unit =
      {
        var selectedDepArrC = deparrComboBoxC.value.value
        var selectedDatasetC = datasetComboBoxC.value.value
        var selectedView = viewComboBox.value.value
        var selectedGraph = graphComboBox.value.value
        if loaded == 0 then
          depArrData =
            selectedDepArrC match
              {
                case "All" =>
                  getAllFlightData()
                case "Departing" =>
                  getDepFlightData()
                case "Arriving" =>
                  getArrFlightData()
              }
        val newChart =
          new VBox(
            makeChart(selectedGraph,
              getChartData(selectedDatasetC, depArrData)._1,
              getChartData(selectedDatasetC, depArrData)._2,
              getChartData(selectedDatasetC, depArrData)._3,
              getChartData(selectedDatasetC, depArrData)._4)
          )
        newCBoxes.children.clear()
        newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
          deparrComboBoxC)
        visible = newChart
        border.center = newCBoxes
        border.right = viewComboBox
        border.bottom = visible
      }
    def updateMetrics(): Unit =
      {
        var selectedDatasetM = datasetComboBoxM.value.value
        var selectedDepArrM = deparrComboBoxC.value.value
        var selectedView = viewComboBox.value.value
        if loaded == 0 then
          depArrData =
            selectedDepArrM match
              {
                case "All" =>
                  getAllFlightData()
                case "Departing" =>
                  getDepFlightData()
                case "Arriving" =>
                  getArrFlightData()
              }
        visible =
          if removeAdd == 1 then new VBox(metric.addMetric(newestMetric)) else
            new VBox(metric.removeMetric(newestMetric) newCBoxes null)
      }
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val colorItem = new MenuItem("Color")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(colorItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox("")
  val metric = new Metric()
  var removeAdd = 0
  var newestMetric: StackPane =
    metric.makeMetric(getMetricData("Amount", depArrData)._2,
      getMetricData("Amount", depArrData)._1)
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = viewComboBox
      border.bottom = visible
      updateChart()
      def updateChart(): Unit =
        {
          var selectedDepArrC = deparrComboBoxC.value.value
          var selectedDatasetC = datasetComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          var selectedGraph = graphComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrC match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          val newChart =
            new VBox(
              makeChart(selectedGraph,
                getChartData(selectedDatasetC, depArrData)._1,
                getChartData(selectedDatasetC, depArrData)._2,
                getChartData(selectedDatasetC, depArrData)._3,
                getChartData(selectedDatasetC, depArrData)._4)
            )
          newCBoxes.children.clear()
          newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
            deparrComboBoxC)
          visible = newChart
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
        }
      def updateMetrics(): Unit =
        {
          var selectedDatasetM = datasetComboBoxM.value.value
          var selectedDepArrM = deparrComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrM match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          visible =
            if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
               else new VBox(metric.removeMetric(newestMetric) newCBoxes null)
        }
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val colorItem = new MenuItem("Color")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(colorItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox("")
    val metric = new Metric()
    var removeAdd = 0
    var newestMetric: StackPane =
      metric.makeMetric(getMetricData("Amount", depArrData)._2,
        getMetricData("Amount", depArrData)._1)
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = viewComboBox
        border.bottom = visible
        updateChart()
        def updateChart(): Unit =
          {
            var selectedDepArrC = deparrComboBoxC.value.value
            var selectedDatasetC = datasetComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            var selectedGraph = graphComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrC match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            val newChart =
              new VBox(
                makeChart(selectedGraph,
                  getChartData(selectedDatasetC, depArrData)._1,
                  getChartData(selectedDatasetC, depArrData)._2,
                  getChartData(selectedDatasetC, depArrData)._3,
                  getChartData(selectedDatasetC, depArrData)._4)
              )
            newCBoxes.children.clear()
            newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
              deparrComboBoxC)
            visible = newChart
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
          }
        def updateMetrics(): Unit =
          {
            var selectedDatasetM = datasetComboBoxM.value.value
            var selectedDepArrM = deparrComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrM match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            visible =
              if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
                 else new VBox(metric.removeMetric(newestMetric) newCBoxes null)
            }
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox("")
      val metric = new Metric()
      var removeAdd = 0
      var newestMetric: StackPane =
        metric.makeMetric(getMetricData("Amount", depArrData)._2,
          getMetricData("Amount", depArrData)._1)
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
          updateChart()
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                new VBox(
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                )
              newCBoxes.children.clear()
              newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                deparrComboBoxC)
              visible = newChart
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              visible =
                if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
                   else
                  new VBox(metric.removeMetric(newestMetric) newCBoxes null)
            }
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox("")
      val metric = new Metric()
      var removeAdd = 0
      var newestMetric: StackPane =
        metric.makeMetric(getMetricData("Amount", depArrData)._2,
          getMetricData("Amount", depArrData)._1)
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
          updateChart()
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                new VBox(
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                )
              newCBoxes.children.clear()
              newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                deparrComboBoxC)
              visible = newChart
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              visible =
                if removeAdd == 1 then new VBox(metric.addMetric(newestMetric))
                   else
                  new VBox(metric.removeMetric(newestMetric) newCBoxes null)
            }
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val colorItem = new MenuItem("Color")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(colorItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox("")
        val metric = new Metric()
        var removeAdd = 0
        var newestMetric: StackPane =
          metric.makeMetric(getMetricData("Amount", depArrData)._2,
            getMetricData("Amount", depArrData)._1)
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
            updateChart()
            def updateChart(): Unit =
              {
                var selectedDepArrC = deparrComboBoxC.value.value
                var selectedDatasetC = datasetComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                var selectedGraph = graphComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrC match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                val newChart =
                  new VBox(
                    makeChart(selectedGraph,
                      getChartData(selectedDatasetC, depArrData)._1,
                      getChartData(selectedDatasetC, depArrData)._2,
                      getChartData(selectedDatasetC, depArrData)._3,
                      getChartData(selectedDatasetC, depArrData)._4)
                  )
                newCBoxes.children.clear()
                newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                  deparrComboBoxC)
                visible = newChart
                border.center = newCBoxes
                border.right = viewComboBox
                border.bottom = visible
              }
            def updateMetrics(): Unit =
              {
                var selectedDatasetM = datasetComboBoxM.value.value
                var selectedDepArrM = deparrComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrM match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                visible =
                  if removeAdd == 1 then
                    new VBox(metric.addMetric(newestMetric)) else
                    new VBox(metric.removeMetric(newestMetric) newCBoxes null)
              }
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 04, 2024 1:17:06 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-04/r_compiler-error_(root)_13-17-06-558.md
2024.04.04 13:17:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:23 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 13:17:23 INFO  Closing debug server tcp://0.0.0.0:54794
2024.04.04 13:17:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:30 INFO  compiling root (1 scala source)
2024.04.04 13:17:32 INFO  time: compiled root in 1.46s
2024.04.04 13:17:32 INFO  compiling root (1 scala source)
2024.04.04 13:17:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:33 INFO  time: compiled root in 1.03s
2024.04.04 13:17:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:17:58 INFO  compiling root (1 scala source)
2024.04.04 13:17:59 INFO  time: compiled root in 1.29s
2024.04.04 13:17:59 INFO  compiling root (1 scala source)
2024.04.04 13:17:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:18:00 INFO  time: compiled root in 1.09s
2024.04.04 13:18:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:18:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:18:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:18:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:18:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:18:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:18:13 INFO  compiling root (1 scala source)
2024.04.04 13:18:14 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:18:14 INFO  time: compiled root in 1.24s
2024.04.04 13:22:39 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 24h 34m 33.643s)
2024.04.04 13:22:39 INFO  compiling root (1 scala source)
2024.04.04 13:22:39 INFO  compiling root (1 scala source)
2024.04.04 13:22:39 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:22:39 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:22:39 INFO  time: compiled root in 0.94s
2024.04.04 13:22:40 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 13:22:40 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 13:22:40 INFO  Starting debug proxy for [Dashboard]
2024.04.04 13:22:40 INFO  Loaded expression compiler in 9 milliseconds
2024.04.04 13:22:40 INFO  Loaded step filter in 0 milliseconds
2024.04.04 13:22:40 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 13:22:42 INFO  Loaded all sources and classes in 1 second
2024.04.04 13:22:42 INFO  Trying to attach to remote debuggee VM localhost:54924 .
2024.04.04 13:22:42 INFO  Attaching to debuggee VM succeeded.
Apr 04, 2024 1:27:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14769
2024.04.04 13:32:59 INFO  Closing debug server tcp://0.0.0.0:54921
2024.04.04 13:32:59 INFO  Canceling debug proxy for [Dashboard]
Apr 04, 2024 1:34:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15052
2024.04.04 13:34:57 INFO  compiling root (1 scala source)
2024.04.04 13:34:57 INFO  time: compiled root in 0.35s
2024.04.04 13:34:57 INFO  compiling root (1 scala source)
2024.04.04 13:34:57 INFO  time: compiled root in 0.38s
2024.04.04 13:35:20 INFO  compiling root (1 scala source)
2024.04.04 13:35:20 INFO  time: compiled root in 0.26s
2024.04.04 13:35:20 INFO  compiling root (1 scala source)
2024.04.04 13:35:20 INFO  time: compiled root in 0.22s
2024.04.04 13:37:34 INFO  compiling root (1 scala source)
2024.04.04 13:37:34 INFO  time: compiled root in 0.27s
2024.04.04 13:37:34 INFO  compiling root (1 scala source)
2024.04.04 13:37:34 INFO  time: compiled root in 0.34s
2024.04.04 13:37:49 INFO  compiling root (1 scala source)
2024.04.04 13:37:49 INFO  time: compiled root in 0.27s
2024.04.04 13:37:49 INFO  compiling root (1 scala source)
2024.04.04 13:37:49 INFO  time: compiled root in 0.38s
2024.04.04 13:41:59 INFO  compiling root (1 scala source)
2024.04.04 13:41:59 INFO  time: compiled root in 0.82s
2024.04.04 13:41:59 INFO  compiling root (1 scala source)
2024.04.04 13:42:00 INFO  time: compiled root in 0.66s
2024.04.04 13:42:08 INFO  compiling root (1 scala source)
2024.04.04 13:42:08 INFO  time: compiled root in 0.69s
2024.04.04 13:42:08 INFO  compiling root (1 scala source)
2024.04.04 13:42:09 INFO  time: compiled root in 0.63s
2024.04.04 13:46:52 INFO  compiling root (2 scala sources)
2024.04.04 13:46:53 INFO  time: compiled root in 1.74s
2024.04.04 13:46:53 INFO  compiling root (2 scala sources)
2024.04.04 13:46:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:46:56 INFO  time: compiled root in 2.28s
2024.04.04 13:46:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:08 INFO  compiling root (2 scala sources)
2024.04.04 13:47:09 INFO  time: compiled root in 1.62s
2024.04.04 13:47:09 INFO  compiling root (2 scala sources)
2024.04.04 13:47:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:11 INFO  time: compiled root in 1.49s
2024.04.04 13:47:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:31 INFO  compiling root (2 scala sources)
2024.04.04 13:47:34 INFO  time: compiled root in 2.14s
2024.04.04 13:47:34 INFO  compiling root (2 scala sources)
2024.04.04 13:47:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:35 INFO  time: compiled root in 1.5s
2024.04.04 13:47:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:36 INFO  compiling root (2 scala sources)
2024.04.04 13:47:38 INFO  time: compiled root in 1.49s
2024.04.04 13:47:38 INFO  compiling root (2 scala sources)
2024.04.04 13:47:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:40 INFO  time: compiled root in 1.39s
2024.04.04 13:47:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:58 INFO  compiling root (2 scala sources)
2024.04.04 13:47:58 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:47:59 INFO  time: compiled root in 1.01s
2024.04.04 13:47:59 INFO  compiling root (2 scala sources)
2024.04.04 13:48:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:47:59 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:47:59 INFO  time: compiled root in 0.58s
2024.04.04 13:48:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:48:06 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:48:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:48:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:48:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:48:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 04, 2024 1:48:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16014
2024.04.04 13:48:31 INFO  compiling root (2 scala sources)
2024.04.04 13:48:33 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:48:33 INFO  time: compiled root in 1.4s
2024.04.04 13:48:33 INFO  compiling root (2 scala sources)
2024.04.04 13:48:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:48:34 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:48:34 INFO  time: compiled root in 0.89s
2024.04.04 13:48:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:48:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:51:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:51:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:51:47 INFO  compiling root (2 scala sources)
2024.04.04 13:51:47 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:51:47 INFO  time: compiled root in 0.62s
2024.04.04 13:51:47 INFO  compiling root (2 scala sources)
2024.04.04 13:51:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:51:49 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:51:49 INFO  time: compiled root in 0.6s
2024.04.04 13:51:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:51:50 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:51:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:51:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:51:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 13:51:56 INFO  compiling root (2 scala sources)
2024.04.04 13:51:56 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 13:51:57 INFO  time: compiled root in 1.05s
2024.04.04 14:01:03 INFO  compiling root (1 scala source)
2024.04.04 14:01:04 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 14:01:04 INFO  time: compiled root in 1.19s
2024.04.04 14:17:30 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 25h 29m 24.47s)
2024.04.04 14:17:30 INFO  compiling root (1 scala source)
2024.04.04 14:17:30 INFO  compiling root (1 scala source)
2024.04.04 14:17:31 INFO  time: compiled root in 0.96s
2024.04.04 14:17:31 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 25h 29m 25.514s)
2024.04.04 14:17:31 INFO  compiling root (1 scala source)
2024.04.04 14:17:31 INFO  compiling root (1 scala source)
2024.04.04 14:17:31 INFO  time: compiled root in 0.74s
2024.04.04 14:17:32 INFO  {
  "jsonrpc": "2.0",
  "id": "1538",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 14:17:32 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 04, 2024 2:17:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16505
Apr 04, 2024 2:17:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16506
Apr 04, 2024 2:17:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16547
2024.04.04 14:17:51 INFO  compiling root (1 scala source)
2024.04.04 14:17:51 INFO  time: compiled root in 0.7s
2024.04.04 14:17:51 INFO  compiling root (1 scala source)
2024.04.04 14:17:52 INFO  time: compiled root in 0.59s
2024.04.04 14:21:21 INFO  compiling root (1 scala source)
2024.04.04 14:21:22 INFO  time: compiled root in 1.31s
2024.04.04 14:21:22 INFO  compiling root (1 scala source)
2024.04.04 14:21:23 INFO  time: compiled root in 0.98s
Apr 04, 2024 2:23:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16763
2024.04.04 14:25:41 INFO  compiling root (1 scala source)
2024.04.04 14:25:43 INFO  time: compiled root in 1.81s
2024.04.04 14:25:43 INFO  compiling root (1 scala source)
2024.04.04 14:25:44 INFO  time: compiled root in 1.35s
2024.04.04 14:25:52 INFO  compiling root (1 scala source)
2024.04.04 14:25:54 INFO  time: compiled root in 1.61s
2024.04.04 14:25:54 INFO  compiling root (1 scala source)
2024.04.04 14:25:55 INFO  time: compiled root in 1.57s
2024.04.04 14:27:50 INFO  compiling root (2 scala sources)
2024.04.04 14:27:52 INFO  time: compiled root in 2.18s
2024.04.04 14:27:55 INFO  compiling root (2 scala sources)
2024.04.04 14:27:57 INFO  time: compiled root in 2s
Apr 04, 2024 2:28:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17222
Apr 04, 2024 2:28:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17226
2024.04.04 14:28:17 INFO  compiling root (2 scala sources)
2024.04.04 14:28:19 INFO  time: compiled root in 1.75s
2024.04.04 14:28:19 INFO  compiling root (2 scala sources)
2024.04.04 14:28:21 INFO  time: compiled root in 2.45s
2024.04.04 14:28:27 INFO  compiling root (2 scala sources)
2024.04.04 14:28:29 INFO  time: compiled root in 2.08s
2024.04.04 14:28:29 INFO  compiling root (2 scala sources)
2024.04.04 14:28:31 INFO  time: compiled root in 1.84s
2024.04.04 14:30:49 INFO  compiling root (2 scala sources)
2024.04.04 14:30:51 INFO  time: compiled root in 1.62s
2024.04.04 14:30:58 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:113: error: unclosed comment
    /*Visual.ColumnChart.getData.foreach( series=> {
    ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 14:31:03 INFO  compiling root (2 scala sources)
2024.04.04 14:31:04 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 14:31:04 INFO  time: compiled root in 1.73s
Apr 04, 2024 2:35:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17389
2024.04.04 14:38:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:38:58 INFO  compiling root (1 scala source)
2024.04.04 14:38:58 INFO  time: compiled root in 0.89s
2024.04.04 14:38:58 INFO  compiling root (1 scala source)
2024.04.04 14:39:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:00 INFO  time: compiled root in 0.54s
2024.04.04 14:39:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:09 INFO  compiling root (1 scala source)
2024.04.04 14:39:09 INFO  time: compiled root in 0.79s
2024.04.04 14:39:09 INFO  compiling root (1 scala source)
2024.04.04 14:39:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:10 INFO  time: compiled root in 0.7s
2024.04.04 14:39:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
2024.04.04 14:39:31 INFO  compiling root (1 scala source)
2024.04.04 14:39:32 INFO  time: compiled root in 1.22s
2024.04.04 14:41:09 INFO  compiling root (1 scala source)
2024.04.04 14:41:10 INFO  time: compiled root in 1.08s
Apr 04, 2024 2:41:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17670
2024.04.04 14:41:41 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 14:41:41 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 14:41:41 INFO  Starting debug proxy for [Dashboard]
2024.04.04 14:41:42 INFO  Loaded expression compiler in 10 milliseconds
2024.04.04 14:41:42 INFO  Loaded step filter in 0 milliseconds
2024.04.04 14:41:42 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 14:41:43 INFO  Loaded all sources and classes in 1 second
2024.04.04 14:41:43 INFO  Trying to attach to remote debuggee VM localhost:55670 .
2024.04.04 14:41:43 INFO  Attaching to debuggee VM succeeded.
2024.04.04 14:42:16 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 14:42:16 INFO  Closing debug server tcp://0.0.0.0:55667
Apr 04, 2024 2:44:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17739
2024.04.04 14:44:55 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 25h 56m 49.86s)
2024.04.04 14:44:55 INFO  compiling root (1 scala source)
2024.04.04 14:44:55 INFO  compiling root (1 scala source)
2024.04.04 14:44:57 INFO  time: compiled root in 1.6s
2024.04.04 14:44:57 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 25h 56m 51.528s)
2024.04.04 14:44:57 INFO  compiling root (1 scala source)
2024.04.04 14:44:57 INFO  compiling root (1 scala source)
2024.04.04 14:44:58 INFO  time: compiled root in 1.35s
2024.04.04 14:44:58 INFO  {
  "jsonrpc": "2.0",
  "id": "1679",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 14:44:58 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 04, 2024 2:46:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17948
Apr 04, 2024 2:49:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18055
2024.04.04 14:59:54 INFO  compiling root (1 scala source)
2024.04.04 14:59:55 INFO  time: compiled root in 1.38s
2024.04.04 14:59:55 INFO  compiling root (1 scala source)
2024.04.04 14:59:57 INFO  time: compiled root in 2.19s
2024.04.04 15:00:24 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:255: error: illegal character '\u00a8'
                getChartData(selectedDatasetC, depArrData)._4))¨
                                                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 15:12:20 INFO  compiling root (1 scala source)
2024.04.04 15:12:20 INFO  time: compiled root in 0.71s
2024.04.04 15:12:20 INFO  compiling root (1 scala source)
2024.04.04 15:12:22 INFO  time: compiled root in 0.59s
2024.04.04 15:12:28 INFO  compiling root (1 scala source)
2024.04.04 15:12:30 INFO  time: compiled root in 1.46s
2024.04.04 15:12:30 INFO  compiling root (1 scala source)
2024.04.04 15:12:32 INFO  time: compiled root in 2.16s
2024.04.04 15:12:32 INFO  compiling root (1 scala source)
2024.04.04 15:12:34 INFO  time: compiled root in 1.54s
2024.04.04 15:12:34 INFO  compiling root (1 scala source)
2024.04.04 15:12:35 INFO  time: compiled root in 1.6s
2024.04.04 15:12:53 INFO  compiling root (1 scala source)
2024.04.04 15:12:55 INFO  time: compiled root in 2.45s
2024.04.04 15:12:55 INFO  compiling root (1 scala source)
2024.04.04 15:12:57 INFO  time: compiled root in 1.75s
Apr 04, 2024 3:13:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18613
Apr 04, 2024 3:13:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18784
2024.04.04 15:13:50 INFO  compiling root (1 scala source)
2024.04.04 15:13:52 INFO  time: compiled root in 1.67s
2024.04.04 15:13:52 INFO  compiling root (1 scala source)
2024.04.04 15:13:54 INFO  time: compiled root in 1.66s
2024.04.04 15:15:22 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:219: error: unclosed comment
      /*val total = Visual.PieGraph.getData.foldLeft(0.0) {(x, y) => x + y.getPieValue}
      ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 15:16:33 INFO  compiling root (1 scala source)
2024.04.04 15:16:35 INFO  time: compiled root in 2.61s
2024.04.04 15:16:35 INFO  compiling root (1 scala source)
2024.04.04 15:16:37 INFO  time: compiled root in 2s
2024.04.04 15:16:40 INFO  compiling root (1 scala source)
2024.04.04 15:16:41 INFO  time: compiled root in 1.47s
2024.04.04 15:16:41 INFO  compiling root (1 scala source)
2024.04.04 15:16:43 INFO  time: compiled root in 1.62s
2024.04.04 15:16:47 INFO  compiling root (1 scala source)
2024.04.04 15:16:48 INFO  time: compiled root in 1.46s
2024.04.04 15:16:48 INFO  compiling root (1 scala source)
2024.04.04 15:16:49 INFO  time: compiled root in 1.41s
2024.04.04 15:16:58 INFO  compiling root (1 scala source)
2024.04.04 15:16:59 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 15:16:59 INFO  time: compiled root in 1.13s
2024.04.04 15:18:36 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 26h 30m 30.127s)
2024.04.04 15:18:36 INFO  compiling root (1 scala source)
2024.04.04 15:18:36 INFO  compiling root (1 scala source)
2024.04.04 15:18:37 INFO  time: compiled root in 1.58s
2024.04.04 15:18:37 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 26h 30m 31.853s)
2024.04.04 15:18:37 INFO  compiling root (1 scala source)
2024.04.04 15:18:37 INFO  compiling root (1 scala source)
2024.04.04 15:18:38 INFO  time: compiled root in 0.85s
2024.04.04 15:18:38 INFO  {
  "jsonrpc": "2.0",
  "id": "1796",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 15:18:38 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 15:20:06 INFO  compiling root (1 scala source)
2024.04.04 15:20:06 INFO  time: compiled root in 0.67s
2024.04.04 15:23:09 INFO  compiling root (1 scala source)
2024.04.04 15:23:11 INFO  time: compiled root in 1.66s
2024.04.04 15:23:11 INFO  compiling root (1 scala source)
2024.04.04 15:23:12 INFO  time: compiled root in 1.35s
2024.04.04 15:25:04 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:177: error: unclosed string interpolation
    var chart: Option[ScatterChart[String, Number] | BarChart[String, Number] | LineChart[String, Number]] = makeChart("Scatter", ", "dfe", "fr")
                                                                                                                                                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 15:25:35 INFO  compiling root (1 scala source)
2024.04.04 15:25:37 INFO  time: compiled root in 1.75s
2024.04.04 15:25:37 INFO  compiling root (1 scala source)
2024.04.04 15:25:39 INFO  time: compiled root in 1.75s
2024.04.04 15:25:52 INFO  compiling root (1 scala source)
2024.04.04 15:25:54 INFO  time: compiled root in 1.58s
2024.04.04 15:25:54 INFO  compiling root (1 scala source)
2024.04.04 15:25:56 INFO  time: compiled root in 2.58s
2024.04.04 15:27:32 INFO  compiling root (1 scala source)
2024.04.04 15:27:33 INFO  time: compiled root in 1.78s
2024.04.04 15:27:33 INFO  compiling root (1 scala source)
2024.04.04 15:27:35 INFO  time: compiled root in 1.49s
2024.04.04 15:27:37 INFO  compiling root (1 scala source)
2024.04.04 15:27:39 INFO  time: compiled root in 1.66s
2024.04.04 15:27:45 INFO  compiling root (1 scala source)
2024.04.04 15:27:47 INFO  time: compiled root in 2.69s
Apr 04, 2024 3:28:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19633
2024.04.04 15:28:12 INFO  compiling root (1 scala source)
2024.04.04 15:28:14 INFO  time: compiled root in 1.52s
2024.04.04 15:28:14 INFO  compiling root (1 scala source)
2024.04.04 15:28:15 INFO  time: compiled root in 1.37s
2024.04.04 15:29:03 INFO  compiling root (1 scala source)
2024.04.04 15:29:05 INFO  time: compiled root in 1.51s
2024.04.04 15:29:05 INFO  compiling root (1 scala source)
2024.04.04 15:29:07 INFO  time: compiled root in 1.75s
Apr 04, 2024 3:29:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19723
2024.04.04 15:31:48 INFO  compiling root (1 scala source)
2024.04.04 15:31:50 INFO  time: compiled root in 1.37s
2024.04.04 15:31:50 INFO  compiling root (1 scala source)
2024.04.04 15:31:51 INFO  time: compiled root in 1.15s
2024.04.04 15:32:39 INFO  compiling root (1 scala source)
2024.04.04 15:32:41 INFO  time: compiled root in 1.24s
2024.04.04 15:32:41 INFO  compiling root (1 scala source)
2024.04.04 15:32:43 INFO  time: compiled root in 1.35s
2024.04.04 15:32:43 INFO  compiling root (1 scala source)
2024.04.04 15:32:44 INFO  time: compiled root in 1.44s
2024.04.04 15:33:17 INFO  compiling root (1 scala source)
2024.04.04 15:33:18 INFO  time: compiled root in 1.27s
2024.04.04 15:33:18 INFO  compiling root (1 scala source)
2024.04.04 15:33:19 INFO  time: compiled root in 1.12s
2024.04.04 15:33:46 INFO  compiling root (1 scala source)
2024.04.04 15:33:48 INFO  time: compiled root in 1.29s
2024.04.04 21:08:19 INFO  compiling root (1 scala source)
2024.04.04 21:08:26 INFO  time: compiled root in 6.95s
2024.04.04 21:08:58 INFO  compiling root (1 scala source)
2024.04.04 21:09:01 INFO  time: compiled root in 2.53s
2024.04.04 21:09:01 INFO  compiling root (1 scala source)
2024.04.04 21:09:04 INFO  time: compiled root in 2.5s
2024.04.04 21:09:04 INFO  compiling root (1 scala source)
2024.04.04 21:09:06 INFO  time: compiled root in 2.45s
2024.04.04 21:09:21 INFO  compiling root (1 scala source)
2024.04.04 21:09:24 INFO  time: compiled root in 3.02s
2024.04.04 21:09:24 INFO  compiling root (1 scala source)
2024.04.04 21:09:27 INFO  time: compiled root in 2.96s
Apr 04, 2024 9:09:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20046
2024.04.04 21:09:57 INFO  compiling root (1 scala source)
2024.04.04 21:10:00 INFO  time: compiled root in 2.29s
2024.04.04 21:10:00 INFO  compiling root (1 scala source)
2024.04.04 21:10:04 INFO  time: compiled root in 3.88s
2024.04.04 21:10:14 INFO  compiling root (1 scala source)
2024.04.04 21:10:16 INFO  time: compiled root in 2.39s
2024.04.04 21:10:16 INFO  compiling root (1 scala source)
2024.04.04 21:10:19 INFO  time: compiled root in 2.68s
2024.04.04 21:10:19 INFO  compiling root (1 scala source)
2024.04.04 21:10:23 INFO  time: compiled root in 2.62s
2024.04.04 21:10:34 INFO  compiling root (1 scala source)
2024.04.04 21:10:38 INFO  time: compiled root in 3.14s
2024.04.04 21:10:38 INFO  compiling root (1 scala source)
2024.04.04 21:10:41 INFO  time: compiled root in 2.57s
2024.04.04 21:10:45 INFO  compiling root (1 scala source)
2024.04.04 21:10:46 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 21:10:46 INFO  time: compiled root in 2.02s
2024.04.04 21:12:17 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 32h 24m 11.725s)
2024.04.04 21:12:17 INFO  compiling root (1 scala source)
2024.04.04 21:12:17 INFO  compiling root (1 scala source)
2024.04.04 21:12:21 INFO  time: compiled root in 3.38s
2024.04.04 21:12:21 INFO  compiling root (1 scala source)
2024.04.04 21:12:23 INFO  time: compiled root in 2.12s
2024.04.04 21:12:23 INFO  compiling root (1 scala source)
2024.04.04 21:12:25 INFO  time: compiled root in 2.17s
2024.04.04 21:12:25 INFO  {
  "jsonrpc": "2.0",
  "id": "1986",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 21:12:25 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 21:13:31 INFO  compiling root (1 scala source)
2024.04.04 21:13:33 INFO  time: compiled root in 2.43s
2024.04.04 21:13:33 INFO  compiling root (1 scala source)
2024.04.04 21:13:37 INFO  time: compiled root in 3.44s
Apr 04, 2024 9:13:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20335
2024.04.04 21:13:54 INFO  compiling root (1 scala source)
2024.04.04 21:13:55 INFO  time: compiled root in 1.44s
2024.04.04 21:13:55 INFO  compiling root (1 scala source)
2024.04.04 21:13:57 INFO  time: compiled root in 1.17s
2024.04.04 21:14:22 INFO  compiling root (1 scala source)
2024.04.04 21:14:26 INFO  time: compiled root in 3.72s
2024.04.04 21:14:26 INFO  compiling root (1 scala source)
2024.04.04 21:14:29 INFO  time: compiled root in 2.36s
2024.04.04 21:15:14 INFO  compiling root (1 scala source)
2024.04.04 21:15:16 INFO  time: compiled root in 1.98s
2024.04.04 21:15:16 INFO  compiling root (1 scala source)
2024.04.04 21:15:18 INFO  time: compiled root in 1.61s
2024.04.04 21:15:19 INFO  compiling root (1 scala source)
2024.04.04 21:15:21 INFO  time: compiled root in 1.93s
2024.04.04 21:15:34 INFO  compiling root (1 scala source)
2024.04.04 21:15:36 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 21:15:36 INFO  time: compiled root in 2.18s
2024.04.04 21:18:11 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 32h 30m 5.194s)
2024.04.04 21:18:11 INFO  compiling root (1 scala source)
2024.04.04 21:18:11 INFO  compiling root (1 scala source)
2024.04.04 21:18:13 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 21:18:13 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 21:18:13 INFO  time: compiled root in 1.93s
2024.04.04 21:18:13 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 21:18:13 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 21:18:13 INFO  Starting debug proxy for [Dashboard]
2024.04.04 21:18:13 INFO  Loaded expression compiler in 8 milliseconds
2024.04.04 21:18:13 INFO  Loaded step filter in 0 milliseconds
2024.04.04 21:18:13 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 21:18:16 INFO  Loaded all sources and classes in 2 seconds
2024.04.04 21:18:17 INFO  Trying to attach to remote debuggee VM localhost:59277 .
2024.04.04 21:18:17 INFO  Attaching to debuggee VM succeeded.
2024.04.04 21:20:22 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 21:20:22 INFO  Closing debug server tcp://0.0.0.0:59274
2024.04.04 21:35:41 INFO  compiling root (1 scala source)
2024.04.04 21:35:43 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 21:35:43 INFO  time: compiled root in 1.78s
2024.04.04 21:36:15 INFO  compiling root (1 scala source)
2024.04.04 21:36:16 INFO  time: compiled root in 1.45s
2024.04.04 21:42:19 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 32h 54m 13.222s)
2024.04.04 21:42:19 INFO  compiling root (1 scala source)
2024.04.04 21:42:19 INFO  compiling root (1 scala source)
2024.04.04 21:42:20 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 21:42:20 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 21:42:20 INFO  time: compiled root in 1.54s
2024.04.04 21:42:20 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 32h 54m 14.844s)
2024.04.04 21:42:20 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 21:42:20 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 21:42:21 INFO  Starting debug proxy for [Dashboard]
2024.04.04 21:42:20 INFO  Loaded expression compiler in 9 milliseconds
2024.04.04 21:42:20 INFO  Loaded step filter in 1 millisecond
2024.04.04 21:42:20 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 21:42:25 INFO  Loaded all sources and classes in 3 seconds
2024.04.04 21:42:26 INFO  Trying to attach to remote debuggee VM localhost:59709 .
2024.04.04 21:42:26 INFO  Attaching to debuggee VM succeeded.
2024.04.04 21:44:37 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 21:44:37 INFO  Closing debug server tcp://0.0.0.0:59705
2024.04.04 21:46:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 21:46:51 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 32h 58m 45.355s)
2024.04.04 21:46:51 INFO  compiling root (1 scala source)
2024.04.04 21:46:51 INFO  compiling root (1 scala source)
2024.04.04 21:46:55 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 21:46:55 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 21:46:55 INFO  time: compiled root in 4.01s
2024.04.04 21:46:55 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 21:46:55 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 21:46:55 INFO  Starting debug proxy for [Dashboard]
2024.04.04 21:46:55 INFO  Loaded expression compiler in 14 milliseconds
2024.04.04 21:46:55 INFO  Loaded step filter in 0 milliseconds
2024.04.04 21:46:55 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 21:46:59 INFO  Loaded all sources and classes in 3 seconds
2024.04.04 21:47:00 INFO  Trying to attach to remote debuggee VM localhost:59785 .
2024.04.04 21:47:00 INFO  Attaching to debuggee VM succeeded.
Apr 04, 2024 10:01:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21346
Apr 04, 2024 10:08:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21853
2024.04.04 22:09:12 INFO  Canceling debug proxy for [Dashboard]
2024.04.04 22:09:12 INFO  Closing debug server tcp://0.0.0.0:59783
2024.04.04 22:09:12 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 33h 21m 7.646s)
2024.04.04 22:09:12 INFO  compiling root (1 scala source)
2024.04.04 22:09:12 INFO  compiling root (1 scala source)
2024.04.04 22:09:15 INFO  time: compiled root in 1.65s
2024.04.04 22:09:15 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 33h 21m 9.387s)
2024.04.04 22:09:15 INFO  compiling root (1 scala source)
2024.04.04 22:09:15 INFO  compiling root (1 scala source)
2024.04.04 22:09:16 INFO  time: compiled root in 1.16s
2024.04.04 22:09:16 INFO  {
  "jsonrpc": "2.0",
  "id": "2122",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.04 22:09:16 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 22:09:32 INFO  compiling root (1 scala source)
2024.04.04 22:09:35 INFO  time: compiled root in 3.45s
2024.04.04 22:09:35 INFO  compiling root (1 scala source)
2024.04.04 22:09:38 INFO  time: compiled root in 2.77s
2024.04.04 22:10:14 INFO  compiling root (1 scala source)
2024.04.04 22:10:17 INFO  time: compiled root in 2.63s
2024.04.04 22:10:37 INFO  compiling root (1 scala source)
2024.04.04 22:10:38 INFO  time: compiled root in 1.06s
2024.04.04 22:10:38 INFO  compiling root (1 scala source)
2024.04.04 22:10:39 INFO  time: compiled root in 1.11s
2024.04.04 22:11:04 INFO  compiling root (1 scala source)
2024.04.04 22:11:05 INFO  time: compiled root in 1.06s
2024.04.04 22:11:05 INFO  compiling root (1 scala source)
2024.04.04 22:11:05 INFO  time: compiled root in 0.9s
2024.04.04 22:11:13 INFO  compiling root (1 scala source)
2024.04.04 22:11:14 INFO  time: compiled root in 1.5s
2024.04.04 22:11:14 INFO  compiling root (1 scala source)
2024.04.04 22:11:14 INFO  time: compiled root in 0.85s
2024.04.04 22:13:00 INFO  compiling root (1 scala source)
2024.04.04 22:13:01 INFO  time: compiled root in 0.97s
2024.04.04 22:13:01 INFO  compiling root (1 scala source)
2024.04.04 22:13:02 INFO  time: compiled root in 1.02s
2024.04.04 22:13:08 INFO  compiling root (1 scala source)
2024.04.04 22:13:09 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 22:13:09 INFO  time: compiled root in 1.74s
2024.04.04 22:14:41 INFO  compiling root (1 scala source)
2024.04.04 22:14:41 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 33h 26m 36.118s)
2024.04.04 22:14:41 INFO  compiling root (1 scala source)
2024.04.04 22:14:43 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 22:14:43 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.04 22:14:43 INFO  time: compiled root in 1.48s
2024.04.04 22:14:43 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.04 22:14:43 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.04 22:14:43 INFO  Starting debug proxy for [Dashboard]
2024.04.04 22:14:43 INFO  Loaded expression compiler in 6 milliseconds
2024.04.04 22:14:43 INFO  Loaded step filter in 0 milliseconds
2024.04.04 22:14:43 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.04 22:14:46 INFO  Loaded all sources and classes in 2 seconds
2024.04.04 22:14:47 INFO  Trying to attach to remote debuggee VM localhost:60132 .
2024.04.04 22:14:47 INFO  Attaching to debuggee VM succeeded.
2024.04.04 22:18:16 INFO  Closing debug server tcp://0.0.0.0:60127
2024.04.04 22:18:16 INFO  Canceling debug proxy for [Dashboard]
Apr 04, 2024 10:22:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22329
Exception in thread "pool-7-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.04 22:26:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:26:24 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 33h 38m 18.11s)
2024.04.04 22:26:24 INFO  compiling root (2 scala sources)
2024.04.04 22:26:24 INFO  compiling root (2 scala sources)
2024.04.04 22:26:30 INFO  time: compiled root in 6.56s
2024.04.04 22:26:30 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 33h 38m 25.056s)
2024.04.04 22:26:30 INFO  compiling root (2 scala sources)
2024.04.04 22:26:30 INFO  compiling root (2 scala sources)
2024.04.04 22:26:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:26:35 INFO  time: compiled root in 4s
2024.04.04 22:26:35 INFO  {
  "jsonrpc": "2.0",
  "id": "2214",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
Apr 04, 2024 10:26:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22538
2024.04.04 22:26:35 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.04 22:26:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:26:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:26:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:26:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:27:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:27:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:27:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:28:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:28:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:28:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:28:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:28:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:28:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:07 INFO  compiling root (2 scala sources)
2024.04.04 22:29:09 INFO  time: compiled root in 1.76s
2024.04.04 22:29:09 INFO  compiling root (2 scala sources)
2024.04.04 22:29:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:10 INFO  time: compiled root in 1.09s
2024.04.04 22:29:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:11 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:20 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 04, 2024 10:29:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22675
2024.04.04 22:29:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:27 INFO  compiling root (2 scala sources)
2024.04.04 22:29:29 INFO  time: compiled root in 2.24s
2024.04.04 22:29:29 INFO  compiling root (2 scala sources)
2024.04.04 22:29:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:31 INFO  time: compiled root in 2.08s
2024.04.04 22:29:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:29:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:29 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:31 INFO  compiling root (2 scala sources)
2024.04.04 22:32:34 INFO  time: compiled root in 2.44s
2024.04.04 22:32:34 INFO  compiling root (2 scala sources)
2024.04.04 22:32:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:36 INFO  time: compiled root in 2.42s
2024.04.04 22:32:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:32:50 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:33:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:33:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:33:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:33:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:33:13 INFO  compiling root (2 scala sources)
2024.04.04 22:33:15 INFO  time: compiled root in 1.97s
2024.04.04 22:33:15 INFO  compiling root (2 scala sources)
2024.04.04 22:33:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:33:17 INFO  time: compiled root in 2.27s
2024.04.04 22:33:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:33:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:33:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:33 INFO  compiling root (2 scala sources)
2024.04.04 22:34:34 INFO  time: compiled root in 1.33s
2024.04.04 22:34:34 INFO  compiling root (2 scala sources)
2024.04.04 22:34:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.04 22:34:36 INFO  time: compiled root in 1.08s
2024.04.04 22:34:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:51:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:52:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:52:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:52:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:52:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:52:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:52:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:52:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:52:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:53:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 09:53:05 INFO  compiling root (2 scala sources)
2024.04.05 09:53:07 INFO  time: compiled root in 1.39s
2024.04.05 09:53:07 INFO  compiling root (2 scala sources)
2024.04.05 09:53:08 INFO  time: compiled root in 1.25s
2024.04.05 09:53:16 INFO  compiling root (2 scala sources)
2024.04.05 09:53:17 INFO  time: compiled root in 1.34s
2024.04.05 09:53:17 INFO  compiling root (2 scala sources)
2024.04.05 09:53:19 INFO  time: compiled root in 1.05s
2024.04.05 09:53:43 INFO  compiling root (2 scala sources)
2024.04.05 09:53:46 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 09:53:46 INFO  time: compiled root in 2.85s
2024.04.05 09:54:38 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:174: error: Invalid literal number
      if metricCount == 0t
                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 09:55:02 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 45h 6m 56.58s)
2024.04.05 09:55:02 INFO  compiling root (1 scala source)
2024.04.05 09:55:02 INFO  compiling root (1 scala source)
2024.04.05 09:55:03 INFO  time: compiled root in 1.43s
2024.04.05 09:55:03 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 45h 6m 58.105s)
2024.04.05 09:55:03 INFO  compiling root (1 scala source)
2024.04.05 09:55:03 INFO  compiling root (1 scala source)
2024.04.05 09:55:05 INFO  time: compiled root in 1.37s
2024.04.05 09:55:05 INFO  {
  "jsonrpc": "2.0",
  "id": "2301",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.05 09:55:05 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 05, 2024 9:55:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23519
2024.04.05 09:55:18 INFO  compiling root (1 scala source)
2024.04.05 09:55:20 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 09:55:20 INFO  time: compiled root in 1.88s
Apr 05, 2024 10:00:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23808
Apr 05, 2024 10:01:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23855
Apr 05, 2024 10:01:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23866
2024.04.05 10:01:27 INFO  compiling root (1 scala source)
2024.04.05 10:01:27 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 45h 13m 21.175s)
2024.04.05 10:01:27 INFO  compiling root (1 scala source)
2024.04.05 10:01:28 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:01:28 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:01:28 INFO  time: compiled root in 1.87s
2024.04.05 10:01:29 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 10:01:29 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 10:01:29 INFO  Starting debug proxy for [Dashboard]
2024.04.05 10:01:28 INFO  Loaded expression compiler in 9 milliseconds
2024.04.05 10:01:28 INFO  Loaded step filter in 0 milliseconds
2024.04.05 10:01:28 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 10:01:32 INFO  Loaded all sources and classes in 3 seconds
2024.04.05 10:01:37 INFO  Trying to attach to remote debuggee VM localhost:64043 .
2024.04.05 10:01:37 INFO  Attaching to debuggee VM succeeded.
2024.04.05 10:03:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:03:33 INFO  compiling root (1 scala source)
2024.04.05 10:03:37 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:03:37 INFO  time: compiled root in 4.63s
Apr 05, 2024 10:03:47 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.04.05 10:04:27 INFO  compiling root (1 scala source)
2024.04.05 10:04:29 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:04:29 INFO  time: compiled root in 2.72s
2024.04.05 10:06:55 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:321: error: unclosed string interpolation
        val newestMetric = metric.makeMetric(getMetricData("s, depArrData)._2, getMetricData("Amount", depArrData)._1)
                                                                                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 10:07:25 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 45h 19m 19.588s)
2024.04.05 10:07:25 INFO  compiling root (1 scala source)
2024.04.05 10:07:25 INFO  compiling root (1 scala source)
2024.04.05 10:07:27 INFO  time: compiled root in 1.54s
2024.04.05 10:07:27 INFO  compiling root (1 scala source)
2024.04.05 10:07:28 INFO  time: compiled root in 1.02s
2024.04.05 10:07:28 INFO  {
  "jsonrpc": "2.0",
  "id": "2354",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.05 10:07:28 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 05, 2024 10:07:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 24264
Apr 05, 2024 10:08:11 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.04.05 10:08:14 INFO  compiling root (1 scala source)
2024.04.05 10:08:18 INFO  time: compiled root in 3.1s
2024.04.05 10:08:18 INFO  compiling root (1 scala source)
2024.04.05 10:08:25 INFO  time: compiled root in 7.29s
2024.04.05 10:11:00 INFO  compiling root (1 scala source)
2024.04.05 10:11:03 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:11:03 INFO  time: compiled root in 3.11s
Apr 05, 2024 10:14:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 24520
2024.04.05 10:14:51 INFO  compiling root (1 scala source)
2024.04.05 10:15:06 INFO  time: compiled root in 14s
2024.04.05 10:15:12 INFO  compiling root (1 scala source)
2024.04.05 10:15:23 INFO  time: compiled root in 11s
2024.04.05 10:15:39 INFO  compiling root (1 scala source)
2024.04.05 10:15:42 INFO  time: compiled root in 3.46s
2024.04.05 10:16:24 INFO  compiling root (1 scala source)
2024.04.05 10:16:31 INFO  time: compiled root in 7.27s
2024.04.05 10:16:31 INFO  compiling root (1 scala source)
2024.04.05 10:16:35 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 45h 28m 29.424s)
2024.04.05 10:16:35 INFO  compiling root (1 scala source)
2024.04.05 10:16:41 INFO  time: compiled root in 5.87s
error while checking  extends JFXApp3.PrimaryStage {
  title = "Helsinki Airport Dashboard"
  width = 1500
  height = 1000
  initStyle(StageStyle.DECORATED)
  color = null
}
error while checking new JFXApp3.PrimaryStage {
  title = "Helsinki Airport Dashboard"
  width = 1500
  height = 1000
  initStyle(StageStyle.DECORATED)
  color = null
}
error while checking stage =
  new JFXApp3.PrimaryStage {
    title = "Helsinki Airport Dashboard"
    width = 1500
    height = 1000
    initStyle(StageStyle.DECORATED)
    color = null
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
      color = null
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val colorItem = new MenuItem("Color")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(colorItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = viewComboBox
      border.bottom = visible
      def updateChart(): Unit =
        {
          var selectedDepArrC = deparrComboBoxC.value.value
          var selectedDatasetC = datasetComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          var selectedGraph = graphComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrC match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          val newChart =
            new VBox(
              makeChart(selectedGraph,
                getChartData(selectedDatasetC, depArrData)._1,
                getChartData(selectedDatasetC, depArrData)._2,
                getChartData(selectedDatasetC, depArrData)._3,
                getChartData(selectedDatasetC, depArrData)._4)
            )
          if selectedGraph == "Scatter" then
            {
              val chart =
                makeChart(selectedGraph,
                  getChartData(selectedDatasetC, depArrData)._1,
                  getChartData(selectedDatasetC, depArrData)._2,
                  getChartData(selectedDatasetC, depArrData)._3,
                  getChartData(selectedDatasetC, depArrData)._4)
              <empty>
            }
          newCBoxes.children.clear()
          newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
            deparrComboBoxC)
          visible = newChart
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
        }
      def updateMetrics(): Unit =
        {
          var selectedDatasetM = datasetComboBoxM.value.value
          var selectedDepArrM = deparrComboBoxC.value.value
          var selectedView = viewComboBox.value.value
          if loaded == 0 then
            depArrData =
              selectedDepArrM match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          if loaded == 0 then
            depArrData =
              selectedDepArrM match
                {
                  case "All" =>
                    getAllFlightData()
                  case "Departing" =>
                    getDepFlightData()
                  case "Arriving" =>
                    getArrFlightData()
                }
          val newestMetric =
            metric.makeMetric(getMetricData(selectedDatasetM, depArrData)._2,
              getMetricData(selectedDatasetM, depArrData)._1)
          val newMetric =
            if removeAdd == 1 then new VBox(addMetric(newestMetric)) else
              new VBox(removeMetric())
          newCBoxes.children.clear()
          newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
            removeButton, addButton)
          visible = newMetric
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
        }
      graphComboBox.onAction = () => updateChart()
      datasetComboBoxC.onAction = () => updateChart()
      datasetComboBoxM.onAction = () => updateMetrics()
      deparrComboBoxC.onAction = () => updateChart()
      deparrComboBoxM.onAction = () => updateMetrics()
      viewComboBox.onAction =
        () =>
          if (viewComboBox.value.value == "Graph View") updateChart() else
            updateMetrics()
      removeButton.onAction =
        (e: ActionEvent) =>
          {
            removeAdd = 0
            updateMetrics()
          }
      addButton.onAction =
        (e: ActionEvent) =>
          {
            println("dke")
            removeAdd = 1
            updateMetrics()
          }
      exitItem.onAction = (e: ActionEvent) => sys.exit(0)
      saveItem.onAction =
        (e: ActionEvent) =>
          {
            val fileChooser = new FileChooser()
            val selectedFile = fileChooser.showSaveDialog(stage)
            if (selectedFile != null)
              {
                val writer = new java.io.PrintWriter(selectedFile)
                writer.write(xmlFlightData())
                writer.close()
              }
          }
      openItem.onAction =
        (e: ActionEvent) =>
          {
            val fileChooser = new FileChooser()
            val selectedFile = fileChooser.showOpenDialog(stage)
            if (selectedFile != null)
              {
                try
                  {
                    val fileContent =
                      scala.io.Source.fromFile(selectedFile).mkString
                    depArrData = getLoadedFlightData("all", fileContent)
                    loaded = 1
                    updateChart()
                  }
                 catch {
                  {
                    case ex:Exception =>
                      ex.printStackTrace()
                  }
                }
              }
          }
      if loaded == 0 then
        {
          val timer = new Timer(true)
          val interval = 1.minute.toMillis
          timer.scheduleAtFixedRate(
            new TimerTask {
              def run(): Unit =
                {
                  Platform.runLater(
                    () =>
                      if viewComboBox.value.value == "Graph View" then
                        updateChart() else updateMetrics()
                  )
                }
            },
          0, interval)
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
        }
      new VBox(border)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
        color = null
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val colorItem = new MenuItem("Color")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(colorItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = viewComboBox
        border.bottom = visible
        def updateChart(): Unit =
          {
            var selectedDepArrC = deparrComboBoxC.value.value
            var selectedDatasetC = datasetComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            var selectedGraph = graphComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrC match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            val newChart =
              new VBox(
                makeChart(selectedGraph,
                  getChartData(selectedDatasetC, depArrData)._1,
                  getChartData(selectedDatasetC, depArrData)._2,
                  getChartData(selectedDatasetC, depArrData)._3,
                  getChartData(selectedDatasetC, depArrData)._4)
              )
            if selectedGraph == "Scatter" then
              {
                val chart =
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                <empty>
              }
            newCBoxes.children.clear()
            newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
              deparrComboBoxC)
            visible = newChart
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
          }
        def updateMetrics(): Unit =
          {
            var selectedDatasetM = datasetComboBoxM.value.value
            var selectedDepArrM = deparrComboBoxC.value.value
            var selectedView = viewComboBox.value.value
            if loaded == 0 then
              depArrData =
                selectedDepArrM match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            if loaded == 0 then
              depArrData =
                selectedDepArrM match
                  {
                    case "All" =>
                      getAllFlightData()
                    case "Departing" =>
                      getDepFlightData()
                    case "Arriving" =>
                      getArrFlightData()
                  }
            val newestMetric =
              metric.makeMetric(getMetricData(selectedDatasetM, depArrData)._2,
                getMetricData(selectedDatasetM, depArrData)._1)
            val newMetric =
              if removeAdd == 1 then new VBox(addMetric(newestMetric)) else
                new VBox(removeMetric())
            newCBoxes.children.clear()
            newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
              removeButton, addButton)
            visible = newMetric
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
          }
        graphComboBox.onAction = () => updateChart()
        datasetComboBoxC.onAction = () => updateChart()
        datasetComboBoxM.onAction = () => updateMetrics()
        deparrComboBoxC.onAction = () => updateChart()
        deparrComboBoxM.onAction = () => updateMetrics()
        viewComboBox.onAction =
          () =>
            if (viewComboBox.value.value == "Graph View") updateChart() else
              updateMetrics()
        removeButton.onAction =
          (e: ActionEvent) =>
            {
              removeAdd = 0
              updateMetrics()
            }
        addButton.onAction =
          (e: ActionEvent) =>
            {
              println("dke")
              removeAdd = 1
              updateMetrics()
            }
        exitItem.onAction = (e: ActionEvent) => sys.exit(0)
        saveItem.onAction =
          (e: ActionEvent) =>
            {
              val fileChooser = new FileChooser()
              val selectedFile = fileChooser.showSaveDialog(stage)
              if (selectedFile != null)
                {
                  val writer = new java.io.PrintWriter(selectedFile)
                  writer.write(xmlFlightData())
                  writer.close()
                }
            }
        openItem.onAction =
          (e: ActionEvent) =>
            {
              val fileChooser = new FileChooser()
              val selectedFile = fileChooser.showOpenDialog(stage)
              if (selectedFile != null)
                {
                  try
                    {
                      val fileContent =
                        scala.io.Source.fromFile(selectedFile).mkString
                      depArrData = getLoadedFlightData("all", fileContent)
                      loaded = 1
                      updateChart()
                    }
                   catch {
                    {
                      case ex:Exception =>
                        ex.printStackTrace()
                    }
                  }
                }
            }
        if loaded == 0 then
          {
            val timer = new Timer(true)
            val interval = 1.minute.toMillis
            timer.scheduleAtFixedRate(
              new TimerTask {
                def run(): Unit =
                  {
                    Platform.runLater(
                      () =>
                        if viewComboBox.value.value == "Graph View" then
                          updateChart() else updateMetrics()
                    )
                  }
              },
            0, interval)
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
          }
        new VBox(border)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
          color = null
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                new VBox(
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                )
              if selectedGraph == "Scatter" then
                {
                  val chart =
                    makeChart(selectedGraph,
                      getChartData(selectedDatasetC, depArrData)._1,
                      getChartData(selectedDatasetC, depArrData)._2,
                      getChartData(selectedDatasetC, depArrData)._3,
                      getChartData(selectedDatasetC, depArrData)._4)
                  <empty>
                }
              newCBoxes.children.clear()
              newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                deparrComboBoxC)
              visible = newChart
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newestMetric =
                metric.makeMetric(
                  getMetricData(selectedDatasetM, depArrData)._2,
                  getMetricData(selectedDatasetM, depArrData)._1)
              val newMetric =
                if removeAdd == 1 then new VBox(addMetric(newestMetric)) else
                  new VBox(removeMetric())
              newCBoxes.children.clear()
              newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
                removeButton, addButton)
              visible = newMetric
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          graphComboBox.onAction = () => updateChart()
          datasetComboBoxC.onAction = () => updateChart()
          datasetComboBoxM.onAction = () => updateMetrics()
          deparrComboBoxC.onAction = () => updateChart()
          deparrComboBoxM.onAction = () => updateMetrics()
          viewComboBox.onAction =
            () =>
              if (viewComboBox.value.value == "Graph View") updateChart() else
                updateMetrics()
          removeButton.onAction =
            (e: ActionEvent) =>
              {
                removeAdd = 0
                updateMetrics()
              }
          addButton.onAction =
            (e: ActionEvent) =>
              {
                println("dke")
                removeAdd = 1
                updateMetrics()
              }
          exitItem.onAction = (e: ActionEvent) => sys.exit(0)
          saveItem.onAction =
            (e: ActionEvent) =>
              {
                val fileChooser = new FileChooser()
                val selectedFile = fileChooser.showSaveDialog(stage)
                if (selectedFile != null)
                  {
                    val writer = new java.io.PrintWriter(selectedFile)
                    writer.write(xmlFlightData())
                    writer.close()
                  }
              }
          openItem.onAction =
            (e: ActionEvent) =>
              {
                val fileChooser = new FileChooser()
                val selectedFile = fileChooser.showOpenDialog(stage)
                if (selectedFile != null)
                  {
                    try
                      {
                        val fileContent =
                          scala.io.Source.fromFile(selectedFile).mkString
                        depArrData = getLoadedFlightData("all", fileContent)
                        loaded = 1
                        updateChart()
                      }
                     catch {
                      {
                        case ex:Exception =>
                          ex.printStackTrace()
                      }
                    }
                  }
              }
          if loaded == 0 then
            {
              val timer = new Timer(true)
              val interval = 1.minute.toMillis
              timer.scheduleAtFixedRate(
                new TimerTask {
                  def run(): Unit =
                    {
                      Platform.runLater(
                        () =>
                          if viewComboBox.value.value == "Graph View" then
                            updateChart() else updateMetrics()
                      )
                    }
                },
              0, interval)
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          new VBox(border)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
          color = null
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val colorItem = new MenuItem("Color")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(colorItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = viewComboBox
          border.bottom = visible
          def updateChart(): Unit =
            {
              var selectedDepArrC = deparrComboBoxC.value.value
              var selectedDatasetC = datasetComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              var selectedGraph = graphComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrC match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newChart =
                new VBox(
                  makeChart(selectedGraph,
                    getChartData(selectedDatasetC, depArrData)._1,
                    getChartData(selectedDatasetC, depArrData)._2,
                    getChartData(selectedDatasetC, depArrData)._3,
                    getChartData(selectedDatasetC, depArrData)._4)
                )
              if selectedGraph == "Scatter" then
                {
                  val chart =
                    makeChart(selectedGraph,
                      getChartData(selectedDatasetC, depArrData)._1,
                      getChartData(selectedDatasetC, depArrData)._2,
                      getChartData(selectedDatasetC, depArrData)._3,
                      getChartData(selectedDatasetC, depArrData)._4)
                  <empty>
                }
              newCBoxes.children.clear()
              newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                deparrComboBoxC)
              visible = newChart
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          def updateMetrics(): Unit =
            {
              var selectedDatasetM = datasetComboBoxM.value.value
              var selectedDepArrM = deparrComboBoxC.value.value
              var selectedView = viewComboBox.value.value
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              if loaded == 0 then
                depArrData =
                  selectedDepArrM match
                    {
                      case "All" =>
                        getAllFlightData()
                      case "Departing" =>
                        getDepFlightData()
                      case "Arriving" =>
                        getArrFlightData()
                    }
              val newestMetric =
                metric.makeMetric(
                  getMetricData(selectedDatasetM, depArrData)._2,
                  getMetricData(selectedDatasetM, depArrData)._1)
              val newMetric =
                if removeAdd == 1 then new VBox(addMetric(newestMetric)) else
                  new VBox(removeMetric())
              newCBoxes.children.clear()
              newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
                removeButton, addButton)
              visible = newMetric
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          graphComboBox.onAction = () => updateChart()
          datasetComboBoxC.onAction = () => updateChart()
          datasetComboBoxM.onAction = () => updateMetrics()
          deparrComboBoxC.onAction = () => updateChart()
          deparrComboBoxM.onAction = () => updateMetrics()
          viewComboBox.onAction =
            () =>
              if (viewComboBox.value.value == "Graph View") updateChart() else
                updateMetrics()
          removeButton.onAction =
            (e: ActionEvent) =>
              {
                removeAdd = 0
                updateMetrics()
              }
          addButton.onAction =
            (e: ActionEvent) =>
              {
                println("dke")
                removeAdd = 1
                updateMetrics()
              }
          exitItem.onAction = (e: ActionEvent) => sys.exit(0)
          saveItem.onAction =
            (e: ActionEvent) =>
              {
                val fileChooser = new FileChooser()
                val selectedFile = fileChooser.showSaveDialog(stage)
                if (selectedFile != null)
                  {
                    val writer = new java.io.PrintWriter(selectedFile)
                    writer.write(xmlFlightData())
                    writer.close()
                  }
              }
          openItem.onAction =
            (e: ActionEvent) =>
              {
                val fileChooser = new FileChooser()
                val selectedFile = fileChooser.showOpenDialog(stage)
                if (selectedFile != null)
                  {
                    try
                      {
                        val fileContent =
                          scala.io.Source.fromFile(selectedFile).mkString
                        depArrData = getLoadedFlightData("all", fileContent)
                        loaded = 1
                        updateChart()
                      }
                     catch {
                      {
                        case ex:Exception =>
                          ex.printStackTrace()
                      }
                    }
                  }
              }
          if loaded == 0 then
            {
              val timer = new Timer(true)
              val interval = 1.minute.toMillis
              timer.scheduleAtFixedRate(
                new TimerTask {
                  def run(): Unit =
                    {
                      Platform.runLater(
                        () =>
                          if viewComboBox.value.value == "Graph View" then
                            updateChart() else updateMetrics()
                      )
                    }
                },
              0, interval)
              border.center = newCBoxes
              border.right = viewComboBox
              border.bottom = visible
            }
          new VBox(border)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
            color = null
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val colorItem = new MenuItem("Color")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(colorItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = viewComboBox
            border.bottom = visible
            def updateChart(): Unit =
              {
                var selectedDepArrC = deparrComboBoxC.value.value
                var selectedDatasetC = datasetComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                var selectedGraph = graphComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrC match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                val newChart =
                  new VBox(
                    makeChart(selectedGraph,
                      getChartData(selectedDatasetC, depArrData)._1,
                      getChartData(selectedDatasetC, depArrData)._2,
                      getChartData(selectedDatasetC, depArrData)._3,
                      getChartData(selectedDatasetC, depArrData)._4)
                  )
                if selectedGraph == "Scatter" then
                  {
                    val chart =
                      makeChart(selectedGraph,
                        getChartData(selectedDatasetC, depArrData)._1,
                        getChartData(selectedDatasetC, depArrData)._2,
                        getChartData(selectedDatasetC, depArrData)._3,
                        getChartData(selectedDatasetC, depArrData)._4)
                    <empty>
                  }
                newCBoxes.children.clear()
                newCBoxes.children.addAll(graphComboBox, datasetComboBoxC,
                  deparrComboBoxC)
                visible = newChart
                border.center = newCBoxes
                border.right = viewComboBox
                border.bottom = visible
              }
            def updateMetrics(): Unit =
              {
                var selectedDatasetM = datasetComboBoxM.value.value
                var selectedDepArrM = deparrComboBoxC.value.value
                var selectedView = viewComboBox.value.value
                if loaded == 0 then
                  depArrData =
                    selectedDepArrM match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                if loaded == 0 then
                  depArrData =
                    selectedDepArrM match
                      {
                        case "All" =>
                          getAllFlightData()
                        case "Departing" =>
                          getDepFlightData()
                        case "Arriving" =>
                          getArrFlightData()
                      }
                val newestMetric =
                  metric.makeMetric(
                    getMetricData(selectedDatasetM, depArrData)._2,
                    getMetricData(selectedDatasetM, depArrData)._1)
                val newMetric =
                  if removeAdd == 1 then new VBox(addMetric(newestMetric)) else
                    new VBox(removeMetric())
                newCBoxes.children.clear()
                newCBoxes.children.addAll(datasetComboBoxM, deparrComboBoxM,
                  removeButton, addButton)
                visible = newMetric
                border.center = newCBoxes
                border.right = viewComboBox
                border.bottom = visible
              }
            graphComboBox.onAction = () => updateChart()
            datasetComboBoxC.onAction = () => updateChart()
            datasetComboBoxM.onAction = () => updateMetrics()
            deparrComboBoxC.onAction = () => updateChart()
            deparrComboBoxM.onAction = () => updateMetrics()
            viewComboBox.onAction =
              () =>
                if (viewComboBox.value.value == "Graph View") updateChart()
                   else updateMetrics()
            removeButton.onAction =
              (e: ActionEvent) =>
                {
                  removeAdd = 0
                  updateMetrics()
                }
            addButton.onAction =
              (e: ActionEvent) =>
                {
                  println("dke")
                  removeAdd = 1
                  updateMetrics()
                }
            exitItem.onAction = (e: ActionEvent) => sys.exit(0)
            saveItem.onAction =
              (e: ActionEvent) =>
                {
                  val fileChooser = new FileChooser()
                  val selectedFile = fileChooser.showSaveDialog(stage)
                  if (selectedFile != null)
                    {
                      val writer = new java.io.PrintWriter(selectedFile)
                      writer.write(xmlFlightData())
                      writer.close()
                    }
                }
            openItem.onAction =
              (e: ActionEvent) =>
                {
                  val fileChooser = new FileChooser()
                  val selectedFile = fileChooser.showOpenDialog(stage)
                  if (selectedFile != null)
                    {
                      try
                        {
                          val fileContent =
                            scala.io.Source.fromFile(selectedFile).mkString
                          depArrData = getLoadedFlightData("all", fileContent)
                          loaded = 1
                          updateChart()
                        }
                       catch {
                        {
                          case ex:Exception =>
                            ex.printStackTrace()
                        }
                      }
                    }
                }
            if loaded == 0 then
              {
                val timer = new Timer(true)
                val interval = 1.minute.toMillis
                timer.scheduleAtFixedRate(
                  new TimerTask {
                    def run(): Unit =
                      {
                        Platform.runLater(
                          () =>
                            if viewComboBox.value.value == "Graph View" then
                              updateChart() else updateMetrics()
                        )
                      }
                  },
                0, interval)
                border.center = newCBoxes
                border.right = viewComboBox
                border.bottom = visible
              }
            new VBox(border)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:17:44 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-17-44-726.md
2024.04.05 10:17:44 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:17:58 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 45h 29m 52.18s)
2024.04.05 10:17:58 INFO  compiling root (1 scala source)
2024.04.05 10:17:58 INFO  compiling root (1 scala source)
2024.04.05 10:18:01 INFO  time: compiled root in 3.04s
2024.04.05 10:18:01 INFO  compiling root (1 scala source)
2024.04.05 10:18:02 INFO  time: compiled root in 1.32s
2024.04.05 10:18:02 INFO  {
  "jsonrpc": "2.0",
  "id": "2411",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.05 10:18:02 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 05, 2024 10:18:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 24857
2024.04.05 10:18:45 INFO  compiling root (1 scala source)
2024.04.05 10:18:49 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:18:49 INFO  time: compiled root in 4.46s
2024.04.05 10:19:06 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 10:19:06 INFO  Closing debug server tcp://0.0.0.0:64040
2024.04.05 10:20:22 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 45h 32m 17.028s)
2024.04.05 10:20:22 INFO  compiling root (1 scala source)
2024.04.05 10:20:22 INFO  compiling root (1 scala source)
2024.04.05 10:20:30 INFO  time: compiled root in 7.55s
2024.04.05 10:20:30 INFO  compiling root (1 scala source)
2024.04.05 10:20:38 INFO  time: compiled root in 7.11s
2024.04.05 10:20:38 INFO  {
  "jsonrpc": "2.0",
  "id": "2428",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.05 10:20:38 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 05, 2024 10:21:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25219
2024.04.05 10:22:00 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:81: error: illegal character '\u00a8'
    settingsMenu.items = List(theme¨)
                                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 05, 2024 10:22:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25262
Apr 05, 2024 10:22:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25268
2024.04.05 10:23:16 INFO  time: code lens generation in 2.98s
Apr 05, 2024 10:23:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25373
2024.04.05 10:24:08 INFO  compiling root (1 scala source)
2024.04.05 10:24:10 INFO  time: compiled root in 2.02s
2024.04.05 10:24:10 INFO  compiling root (1 scala source)
2024.04.05 10:24:15 INFO  time: compiled root in 4.43s
2024.04.05 10:24:36 INFO  compiling root (1 scala source)
2024.04.05 10:24:39 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:24:39 INFO  time: compiled root in 3.06s
Apr 05, 2024 10:33:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25594
error while checking new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null
        )
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:21 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-21-377.md
error while checking new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null
        )
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:21 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-21-784.md
2024.04.05 10:34:21 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null
        )
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:21 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-21-934.md
error while checking new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null
        )
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:22 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-22-199.md
error while checking new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null
        )
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:22 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-22-774.md
error while checking new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null
        )
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:23 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-23-415.md
error while checking new HBox(null)
error while checking val viewComboBox = new HBox(null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new HBox(null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new HBox(null)
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new HBox(null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new HBox(null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new HBox(null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new HBox(null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new HBox(null)
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:24 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-24-039.md
2024.04.05 10:34:24 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(new ComboBox(List("Graph View", "Metric View")) viewComboBox null
        )
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:25 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-25-011.md
2024.04.05 10:34:25 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(
  hCURSORnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(
    hCURSORnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(
      hCURSORnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(
        hCURSORnew ComboBox (List("Graph View", "Metric View")) viewComboBox
          null
      )
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          hCURSORnew ComboBox (List("Graph View", "Metric View")) viewComboBox
            null
        )
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            hCURSORnew ComboBox (List("Graph View", "Metric View")) viewComboBox
               null
          )
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hCURSORnew ComboBox (List("Graph View", "Metric View"))
                viewComboBox null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hCURSORnew ComboBox (List("Graph View", "Metric View"))
                viewComboBox null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                hCURSORnew ComboBox (List("Graph View", "Metric View"))
                  viewComboBox null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:25 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-25-355.md
error while checking new HBox(hidnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(hidnew ComboBox (List("Graph View", "Metric View")) viewComboBox null
    )
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(
      hidnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(
        hidnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          hidnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            hidnew ComboBox (List("Graph View", "Metric View")) viewComboBox
              null
          )
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hidnew ComboBox (List("Graph View", "Metric View")) viewComboBox
                null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hidnew ComboBox (List("Graph View", "Metric View")) viewComboBox
                null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                hidnew ComboBox (List("Graph View", "Metric View")) viewComboBox
                   null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:25 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-25-803.md
2024.04.05 10:34:25 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(hidernew ComboBox (List("Graph View", "Metric View")) viewComboBox null
  )
error while checking val viewComboBox =
  new HBox(
    hidernew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(
      hidernew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(
        hidernew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          hidernew ComboBox (List("Graph View", "Metric View")) viewComboBox
            null
        )
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            hidernew ComboBox (List("Graph View", "Metric View")) viewComboBox
              null
          )
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hidernew ComboBox (List("Graph View", "Metric View")) viewComboBox
                 null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hidernew ComboBox (List("Graph View", "Metric View")) viewComboBox
                 null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                hidernew ComboBox (List("Graph View", "Metric View"))
                  viewComboBox null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:26 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-26-286.md
2024.04.05 10:34:26 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(hideBnew ComboBox (List("Graph View", "Metric View")) viewComboBox null
  )
error while checking val viewComboBox =
  new HBox(
    hideBnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(
      hideBnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(
        hideBnew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          hideBnew ComboBox (List("Graph View", "Metric View")) viewComboBox
            null
        )
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            hideBnew ComboBox (List("Graph View", "Metric View")) viewComboBox
              null
          )
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hideBnew ComboBox (List("Graph View", "Metric View")) viewComboBox
                 null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hideBnew ComboBox (List("Graph View", "Metric View")) viewComboBox
                 null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                hideBnew ComboBox (List("Graph View", "Metric View"))
                  viewComboBox null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:27 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-27-143.md
2024.04.05 10:34:27 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(
  hideButtonew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(
    hideButtonew ComboBox (List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(
      hideButtonew ComboBox (List("Graph View", "Metric View")) viewComboBox
        null
    )
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(
        hideButtonew ComboBox (List("Graph View", "Metric View")) viewComboBox
          null
      )
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(
          hideButtonew ComboBox (List("Graph View", "Metric View")) viewComboBox
             null
        )
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(
            hideButtonew ComboBox (List("Graph View", "Metric View"))
              viewComboBox null
          )
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hideButtonew ComboBox (List("Graph View", "Metric View"))
                viewComboBox null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(
              hideButtonew ComboBox (List("Graph View", "Metric View"))
                viewComboBox null
            )
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(
                hideButtonew ComboBox (List("Graph View", "Metric View"))
                  viewComboBox null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:27 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-27-629.md
2024.04.05 10:34:27 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(hideButton,
  new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(hideButton,
    new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(hideButton,
      new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(hideButton,
        new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(hideButton,
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(hideButton,
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(hideButton,
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(hideButton,
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(hideButton,
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:28 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-28-126.md
error while checking new HBox(hideButton,
  new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(hideButton,
    new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(hideButton,
      new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(hideButton,
        new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(hideButton,
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(hideButton,
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(hideButton,
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(hideButton,
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(hideButton,
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:28 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-28-216.md
2024.04.05 10:34:28 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(hideButton,
  new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking val viewComboBox =
  new HBox(hideButton,
    new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox =
    new HBox(hideButton,
      new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
  <empty>
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox =
      new HBox(hideButton,
        new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
    <empty>
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox =
        new HBox(hideButton,
          new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
      <empty>
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox =
          new HBox(hideButton,
            new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
        <empty>
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(hideButton,
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox =
            new HBox(hideButton,
              new ComboBox(List("Graph View", "Metric View")) viewComboBox null)
          <empty>
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox =
              new HBox(hideButton,
                new ComboBox(List("Graph View", "Metric View")) viewComboBox
                  null
              )
            <empty>
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:34:29 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-34-29-132.md
2024.04.05 10:34:29 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:34:35 INFO  compiling root (1 scala source)
2024.04.05 10:34:39 INFO  time: compiled root in 4.02s
Apr 05, 2024 10:35:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25843
error while checking new HBox(viewComboBox border null)
error while checking border.right = new HBox(viewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(viewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(viewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(viewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(viewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(viewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:10 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-10-336.md
error while checking new HBox(viewComboBox border null)
error while checking border.right = new HBox(viewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(viewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(viewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(viewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(viewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(viewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:10 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-10-561.md
2024.04.05 10:35:10 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(viewComboBox border null)
error while checking border.right = new HBox(viewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(viewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(viewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(viewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(viewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(viewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:11 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-11-015.md
2024.04.05 10:35:11 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(viewComboBox border null)
error while checking border.right = new HBox(viewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(viewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(viewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(viewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(viewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(viewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:11 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-11-156.md
error while checking new HBox(hCURSORviewComboBox border null)
error while checking border.right = new HBox(hCURSORviewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(hCURSORviewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(hCURSORviewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(hCURSORviewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(hCURSORviewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hCURSORviewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hCURSORviewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(hCURSORviewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:11 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-11-571.md
error while checking new HBox(hidviewComboBox border null)
error while checking border.right = new HBox(hidviewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(hidviewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(hidviewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(hidviewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(hidviewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hidviewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hidviewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(hidviewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:12 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-12-252.md
2024.04.05 10:35:12 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(hideButton, viewComboBox border null)
error while checking border.right = new HBox(hideButton, viewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(hideButton, viewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(hideButton, viewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(hideButton, viewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(hideButton, viewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hideButton, viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hideButton, viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(hideButton, viewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:13 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-13-172.md
error while checking new HBox(hideButton, viewComboBox border null)
error while checking border.right = new HBox(hideButton, viewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(hideButton, viewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(hideButton, viewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(hideButton, viewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(hideButton, viewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hideButton, viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hideButton, viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(hideButton, viewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:13 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-13-268.md
2024.04.05 10:35:13 WARN  Could not find semantic tokens for: file:///Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error while checking new HBox(hideButton, viewComboBox border null)
error while checking border.right = new HBox(hideButton, viewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(hideButton, viewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(hideButton, viewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(hideButton, viewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(hideButton, viewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hideButton, viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hideButton, viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(hideButton, viewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:13 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-13-764.md
error while checking new HBox(hideButton, viewComboBox border null)
error while checking border.right = new HBox(hideButton, viewComboBox border null)
error while checking {
  val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxC.value = "All"
  val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
  deparrComboBoxM.value = "All"
  val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
  viewComboBox.value = "Graph View"
  val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
  graphComboBox.value = "Column"
  val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
  datasetComboBoxC.value = "Time"
  val datasetComboBoxM = new ComboBox(List("Amount"))
  datasetComboBoxM.value = "Amount"
  val removeButton = new Button("Remove")
  val addButton = new Button("Add")
  val comboBoxHBox1 =
    new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
  val comboBoxHBox2 =
    new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
  chart.getData.foreach(
    series =>
      {
        series.getData.foreach(
          d =>
            {
              val pointNode: scalafx.scene.Node = d.getNode
              val pointValue = d.getYValue.toString
              val pointTime = d.getXValue.toString
              val roundedValue =
                BigDecimal(pointValue).setScale(1,
                  BigDecimal.RoundingMode.HALF_UP)
              val tooltip = new Tooltip()
              tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
              tooltip.setStyle(
                "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
              Tooltip.install(pointNode, tooltip)
            }
        )
      }
  )
  var newCBoxes = comboBoxHBox1
  var loaded = 0
  val border = new BorderPane()
  border.center = newCBoxes
  border.right = new HBox(hideButton, viewComboBox border null)
}
error while checking def initializeGraph(): VBox =
  {
    val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxC.value = "All"
    val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
    deparrComboBoxM.value = "All"
    val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
    viewComboBox.value = "Graph View"
    val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
    graphComboBox.value = "Column"
    val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
    datasetComboBoxC.value = "Time"
    val datasetComboBoxM = new ComboBox(List("Amount"))
    datasetComboBoxM.value = "Amount"
    val removeButton = new Button("Remove")
    val addButton = new Button("Add")
    val comboBoxHBox1 =
      new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
    val comboBoxHBox2 =
      new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
    chart.getData.foreach(
      series =>
        {
          series.getData.foreach(
            d =>
              {
                val pointNode: scalafx.scene.Node = d.getNode
                val pointValue = d.getYValue.toString
                val pointTime = d.getXValue.toString
                val roundedValue =
                  BigDecimal(pointValue).setScale(1,
                    BigDecimal.RoundingMode.HALF_UP)
                val tooltip = new Tooltip()
                tooltip.setText(pointTime + ": " + "$" + roundedValue.toString)
                tooltip.setStyle(
                  "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                Tooltip.install(pointNode, tooltip)
              }
          )
        }
    )
    var newCBoxes = comboBoxHBox1
    var loaded = 0
    val border = new BorderPane()
    border.center = newCBoxes
    border.right = new HBox(hideButton, viewComboBox border null)
  }
error while checking {
  stage =
    new JFXApp3.PrimaryStage {
      title = "Helsinki Airport Dashboard"
      width = 1500
      height = 1000
      initStyle(StageStyle.DECORATED)
    }
  val root = Pane()
  val scene = Scene(parent = root)
  stage.scene = scene
  val menuBar = new MenuBar()
  val fileMenu = new Menu("File")
  val settingsMenu = new Menu("Settings")
  val saveItem = new MenuItem("Save")
  val openItem = new MenuItem("Open")
  val exitItem = new MenuItem("Exit")
  val themeItem = new MenuItem("Theme")
  fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
  settingsMenu.items = List(themeItem)
  menuBar.menus = List(fileMenu, settingsMenu)
  menuBar.prefWidth = 1500
  openItem.accelerator =
    new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
  saveItem.accelerator =
    new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
  exitItem.accelerator =
    new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
  val hideButton = new Button("Hide")
  hideButton.onAction =
    () =>
      {
        visible.visible = ! visible.visible.value
      }
  var isDarkMode = true
  themeItem.onAction = (e: ActionEvent) => toggleTheme()
  def toggleTheme(): Unit =
    {
      isDarkMode = ! isDarkMode
      if (isDarkMode)
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/dark-theme.css").toExternalForm)
        }
       else
        {
          stage.scene.value.stylesheets =
            List(getClass.getResource("/light-theme.css").toExternalForm)
        }
    }
  val tabPane = new TabPane()
  val homeTab = new Tab()
  homeTab.text = "Home"
  val dataTab = new Tab()
  dataTab.text = "Data"
  tabPane.layoutY = 30
  tabPane.minWidth = 1500
  tabPane.tabs = List(homeTab, dataTab)
  val tabPane1 = new TabPane()
  val depTab = new Tab()
  val arrTab = new Tab()
  val allTab = new Tab()
  depTab.text = "Departing"
  arrTab.text = "Arriving"
  allTab.text = "All"
  tabPane1.layoutY = 30
  tabPane1.minWidth = 1500
  tabPane1.tabs = List(allTab, depTab, arrTab)
  val tables = new Tables()
  allTab.content = tables.createFlightTableAll()
  depTab.content = tables.createFlightTableDep()
  arrTab.content = tables.createFlightTableArr()
  def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): BarChart[String, Number] =
    {
      val columnChart = new ColumnChart()
      val chart = columnChart.createColumnChart(graphDataType, x, y, label)
      chart
    }
  def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
    y: String, label: String): ScatterChart[String, Number] =
    {
      val scatterChart = new ScatterPlot()
      val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
      chart
    }
  def makeLineChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): LineChart[String, Number] =
    {
      val lineChart = new LinePlot()
      val chart = lineChart.createLineChart(graphDataType, x, y, label)
      chart
    }
  def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
    label: String): PieChart =
    {
      val pieChart = new PieGraph()
      val chart = pieChart.createPieChart(graphDataType, x, y, label)
      chart
    }
  def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
    y: String, label: String) =
    graphType match
      {
        case "Column" =>
          makeColumnGraph(dataType, x, y, label)
        case "Scatter" =>
          makeScatterChart(dataType, x, y, label)
        case "Line" =>
          makeLineChart(dataType, x, y, label)
        case "Pie" =>
          makePieChart(dataType, x, y, label)
        case _ =>
          throw new IllegalArgumentException("Invalid graph type")
      }
  val card = new Metric()
  val graphData = new GraphData()
  val metricData = new MetricData()
  var depArrData = getAllFlightData()
  def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple4[Array[(String, Int)], String, String, String] =
    dataset match
      {
        case "Time" =>
          Tuple4(graphData.flightPerHourData(depArr), "Time",
            "Airplanes flown", "Airplanes flown each hour")
        case "Carrier" =>
          Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
            "Airplanes flown", "Amount of planes flown by carrier")
        case _ =>
          throw new IllegalArgumentException("Invalid dataset")
      }
  def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
    Tuple2[String, String] =
    dataset match
      {
        case "Amount" =>
          Tuple2(metricData.totalFlights(depArr), "Planes")
      }
  var visible: VBox = new VBox(0)
  val metric = new Metric()
  var removeAdd = 0
  var metricCount = 0
  var parentPane: Pane = new Pane()
  def addMetric(card: StackPane): Pane =
    {
      if metricCount == 0 then
        {
          parentPane.getChildren().addAll(card)
          metricCount = 1
          parentPane
        }
       else parentPane
    }
  def removeMetric(): Pane =
    {
      parentPane.getChildren().clear()
      metricCount = 0
      parentPane
    }
  var chart: ScatterChart[String, Number] =
    makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
  def initializeGraph(): VBox =
    {
      val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxC.value = "All"
      val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
      deparrComboBoxM.value = "All"
      val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
      viewComboBox.value = "Graph View"
      val graphComboBox = new ComboBox(List("Column", "Scatter", "Line", "Pie"))
      graphComboBox.value = "Column"
      val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
      datasetComboBoxC.value = "Time"
      val datasetComboBoxM = new ComboBox(List("Amount"))
      datasetComboBoxM.value = "Amount"
      val removeButton = new Button("Remove")
      val addButton = new Button("Add")
      val comboBoxHBox1 =
        new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
      val comboBoxHBox2 =
        new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton, addButton)
      chart.getData.foreach(
        series =>
          {
            series.getData.foreach(
              d =>
                {
                  val pointNode: scalafx.scene.Node = d.getNode
                  val pointValue = d.getYValue.toString
                  val pointTime = d.getXValue.toString
                  val roundedValue =
                    BigDecimal(pointValue).setScale(1,
                      BigDecimal.RoundingMode.HALF_UP)
                  val tooltip = new Tooltip()
                  tooltip.setText(pointTime + ": " + "$" + roundedValue.toString
                    )
                  tooltip.setStyle(
                    "-fx-background-color: yellow; " + "-fx-text-fill: black; ")
                  Tooltip.install(pointNode, tooltip)
                }
            )
          }
      )
      var newCBoxes = comboBoxHBox1
      var loaded = 0
      val border = new BorderPane()
      border.center = newCBoxes
      border.right = new HBox(hideButton, viewComboBox border null)
    }
  val VBox1 = initializeGraph()
  val VBox2 = initializeGraph()
  val VBox3 = initializeGraph()
  val VBox4 = initializeGraph()
  val split = new SplitPane()
  split.orientation = Orientation.Horizontal
  val split1 = new SplitPane()
  split1.orientation = Orientation.Vertical
  split1.items.addAll(VBox1, VBox3)
  val split2 = new SplitPane()
  split2.orientation = Orientation.Vertical
  split2.items.addAll(VBox2, VBox4)
  split.items.addAll(split1, split2)
  homeTab.content = split
  dataTab.content = tabPane1
  root.children += (menuBar, tabPane)
}
error while checking def start() =
  {
    stage =
      new JFXApp3.PrimaryStage {
        title = "Helsinki Airport Dashboard"
        width = 1500
        height = 1000
        initStyle(StageStyle.DECORATED)
      }
    val root = Pane()
    val scene = Scene(parent = root)
    stage.scene = scene
    val menuBar = new MenuBar()
    val fileMenu = new Menu("File")
    val settingsMenu = new Menu("Settings")
    val saveItem = new MenuItem("Save")
    val openItem = new MenuItem("Open")
    val exitItem = new MenuItem("Exit")
    val themeItem = new MenuItem("Theme")
    fileMenu.items = List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
    settingsMenu.items = List(themeItem)
    menuBar.menus = List(fileMenu, settingsMenu)
    menuBar.prefWidth = 1500
    openItem.accelerator =
      new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
    saveItem.accelerator =
      new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
    exitItem.accelerator =
      new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
    val hideButton = new Button("Hide")
    hideButton.onAction =
      () =>
        {
          visible.visible = ! visible.visible.value
        }
    var isDarkMode = true
    themeItem.onAction = (e: ActionEvent) => toggleTheme()
    def toggleTheme(): Unit =
      {
        isDarkMode = ! isDarkMode
        if (isDarkMode)
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/dark-theme.css").toExternalForm)
          }
         else
          {
            stage.scene.value.stylesheets =
              List(getClass.getResource("/light-theme.css").toExternalForm)
          }
      }
    val tabPane = new TabPane()
    val homeTab = new Tab()
    homeTab.text = "Home"
    val dataTab = new Tab()
    dataTab.text = "Data"
    tabPane.layoutY = 30
    tabPane.minWidth = 1500
    tabPane.tabs = List(homeTab, dataTab)
    val tabPane1 = new TabPane()
    val depTab = new Tab()
    val arrTab = new Tab()
    val allTab = new Tab()
    depTab.text = "Departing"
    arrTab.text = "Arriving"
    allTab.text = "All"
    tabPane1.layoutY = 30
    tabPane1.minWidth = 1500
    tabPane1.tabs = List(allTab, depTab, arrTab)
    val tables = new Tables()
    allTab.content = tables.createFlightTableAll()
    depTab.content = tables.createFlightTableDep()
    arrTab.content = tables.createFlightTableArr()
    def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): BarChart[String, Number] =
      {
        val columnChart = new ColumnChart()
        val chart = columnChart.createColumnChart(graphDataType, x, y, label)
        chart
      }
    def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): ScatterChart[String, Number] =
      {
        val scatterChart = new ScatterPlot()
        val chart = scatterChart.createScatterChart(graphDataType, x, y, label)
        chart
      }
    def makeLineChart(graphDataType: Array[(String, Int)], x: String,
      y: String, label: String): LineChart[String, Number] =
      {
        val lineChart = new LinePlot()
        val chart = lineChart.createLineChart(graphDataType, x, y, label)
        chart
      }
    def makePieChart(graphDataType: Array[(String, Int)], x: String, y: String,
      label: String): PieChart =
      {
        val pieChart = new PieGraph()
        val chart = pieChart.createPieChart(graphDataType, x, y, label)
        chart
      }
    def makeChart(graphType: String, dataType: Array[(String, Int)], x: String,
      y: String, label: String) =
      graphType match
        {
          case "Column" =>
            makeColumnGraph(dataType, x, y, label)
          case "Scatter" =>
            makeScatterChart(dataType, x, y, label)
          case "Line" =>
            makeLineChart(dataType, x, y, label)
          case "Pie" =>
            makePieChart(dataType, x, y, label)
          case _ =>
            throw new IllegalArgumentException("Invalid graph type")
        }
    val card = new Metric()
    val graphData = new GraphData()
    val metricData = new MetricData()
    var depArrData = getAllFlightData()
    def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple4[Array[(String, Int)], String, String, String] =
      dataset match
        {
          case "Time" =>
            Tuple4(graphData.flightPerHourData(depArr), "Time",
              "Airplanes flown", "Airplanes flown each hour")
          case "Carrier" =>
            Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
              "Airplanes flown", "Amount of planes flown by carrier")
          case _ =>
            throw new IllegalArgumentException("Invalid dataset")
        }
    def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
      Tuple2[String, String] =
      dataset match
        {
          case "Amount" =>
            Tuple2(metricData.totalFlights(depArr), "Planes")
        }
    var visible: VBox = new VBox(0)
    val metric = new Metric()
    var removeAdd = 0
    var metricCount = 0
    var parentPane: Pane = new Pane()
    def addMetric(card: StackPane): Pane =
      {
        if metricCount == 0 then
          {
            parentPane.getChildren().addAll(card)
            metricCount = 1
            parentPane
          }
         else parentPane
      }
    def removeMetric(): Pane =
      {
        parentPane.getChildren().clear()
        metricCount = 0
        parentPane
      }
    var chart: ScatterChart[String, Number] =
      makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre")
    def initializeGraph(): VBox =
      {
        val deparrComboBoxC = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxC.value = "All"
        val deparrComboBoxM = new ComboBox(List("All", "Departing", "Arriving"))
        deparrComboBoxM.value = "All"
        val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
        viewComboBox.value = "Graph View"
        val graphComboBox =
          new ComboBox(List("Column", "Scatter", "Line", "Pie"))
        graphComboBox.value = "Column"
        val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
        datasetComboBoxC.value = "Time"
        val datasetComboBoxM = new ComboBox(List("Amount"))
        datasetComboBoxM.value = "Amount"
        val removeButton = new Button("Remove")
        val addButton = new Button("Add")
        val comboBoxHBox1 =
          new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
        val comboBoxHBox2 =
          new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
            addButton)
        chart.getData.foreach(
          series =>
            {
              series.getData.foreach(
                d =>
                  {
                    val pointNode: scalafx.scene.Node = d.getNode
                    val pointValue = d.getYValue.toString
                    val pointTime = d.getXValue.toString
                    val roundedValue =
                      BigDecimal(pointValue).setScale(1,
                        BigDecimal.RoundingMode.HALF_UP)
                    val tooltip = new Tooltip()
                    tooltip.setText(
                      pointTime + ": " + "$" + roundedValue.toString)
                    tooltip.setStyle(
                      "-fx-background-color: yellow; " +
                        "-fx-text-fill: black; "
                    )
                    Tooltip.install(pointNode, tooltip)
                  }
              )
            }
        )
        var newCBoxes = comboBoxHBox1
        var loaded = 0
        val border = new BorderPane()
        border.center = newCBoxes
        border.right = new HBox(hideButton, viewComboBox border null)
      }
    val VBox1 = initializeGraph()
    val VBox2 = initializeGraph()
    val VBox3 = initializeGraph()
    val VBox4 = initializeGraph()
    val split = new SplitPane()
    split.orientation = Orientation.Horizontal
    val split1 = new SplitPane()
    split1.orientation = Orientation.Vertical
    split1.items.addAll(VBox1, VBox3)
    val split2 = new SplitPane()
    split2.orientation = Orientation.Vertical
    split2.items.addAll(VBox2, VBox4)
    split.items.addAll(split1, split2)
    homeTab.content = split
    dataTab.content = tabPane1
    root.children += (menuBar, tabPane)
  }
error while checking  extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hideButton, viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking module object Dashboard extends JFXApp3 {
  def start() =
    {
      stage =
        new JFXApp3.PrimaryStage {
          title = "Helsinki Airport Dashboard"
          width = 1500
          height = 1000
          initStyle(StageStyle.DECORATED)
        }
      val root = Pane()
      val scene = Scene(parent = root)
      stage.scene = scene
      val menuBar = new MenuBar()
      val fileMenu = new Menu("File")
      val settingsMenu = new Menu("Settings")
      val saveItem = new MenuItem("Save")
      val openItem = new MenuItem("Open")
      val exitItem = new MenuItem("Exit")
      val themeItem = new MenuItem("Theme")
      fileMenu.items =
        List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
      settingsMenu.items = List(themeItem)
      menuBar.menus = List(fileMenu, settingsMenu)
      menuBar.prefWidth = 1500
      openItem.accelerator =
        new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
      saveItem.accelerator =
        new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
      exitItem.accelerator =
        new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
      val hideButton = new Button("Hide")
      hideButton.onAction =
        () =>
          {
            visible.visible = ! visible.visible.value
          }
      var isDarkMode = true
      themeItem.onAction = (e: ActionEvent) => toggleTheme()
      def toggleTheme(): Unit =
        {
          isDarkMode = ! isDarkMode
          if (isDarkMode)
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/dark-theme.css").toExternalForm)
            }
           else
            {
              stage.scene.value.stylesheets =
                List(getClass.getResource("/light-theme.css").toExternalForm)
            }
        }
      val tabPane = new TabPane()
      val homeTab = new Tab()
      homeTab.text = "Home"
      val dataTab = new Tab()
      dataTab.text = "Data"
      tabPane.layoutY = 30
      tabPane.minWidth = 1500
      tabPane.tabs = List(homeTab, dataTab)
      val tabPane1 = new TabPane()
      val depTab = new Tab()
      val arrTab = new Tab()
      val allTab = new Tab()
      depTab.text = "Departing"
      arrTab.text = "Arriving"
      allTab.text = "All"
      tabPane1.layoutY = 30
      tabPane1.minWidth = 1500
      tabPane1.tabs = List(allTab, depTab, arrTab)
      val tables = new Tables()
      allTab.content = tables.createFlightTableAll()
      depTab.content = tables.createFlightTableDep()
      arrTab.content = tables.createFlightTableArr()
      def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): BarChart[String, Number] =
        {
          val columnChart = new ColumnChart()
          val chart = columnChart.createColumnChart(graphDataType, x, y, label)
          chart
        }
      def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): ScatterChart[String, Number] =
        {
          val scatterChart = new ScatterPlot()
          val chart =
            scatterChart.createScatterChart(graphDataType, x, y, label)
          chart
        }
      def makeLineChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): LineChart[String, Number] =
        {
          val lineChart = new LinePlot()
          val chart = lineChart.createLineChart(graphDataType, x, y, label)
          chart
        }
      def makePieChart(graphDataType: Array[(String, Int)], x: String,
        y: String, label: String): PieChart =
        {
          val pieChart = new PieGraph()
          val chart = pieChart.createPieChart(graphDataType, x, y, label)
          chart
        }
      def makeChart(graphType: String, dataType: Array[(String, Int)],
        x: String, y: String, label: String) =
        graphType match
          {
            case "Column" =>
              makeColumnGraph(dataType, x, y, label)
            case "Scatter" =>
              makeScatterChart(dataType, x, y, label)
            case "Line" =>
              makeLineChart(dataType, x, y, label)
            case "Pie" =>
              makePieChart(dataType, x, y, label)
            case _ =>
              throw new IllegalArgumentException("Invalid graph type")
          }
      val card = new Metric()
      val graphData = new GraphData()
      val metricData = new MetricData()
      var depArrData = getAllFlightData()
      def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple4[Array[(String, Int)], String, String, String] =
        dataset match
          {
            case "Time" =>
              Tuple4(graphData.flightPerHourData(depArr), "Time",
                "Airplanes flown", "Airplanes flown each hour")
            case "Carrier" =>
              Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                "Airplanes flown", "Amount of planes flown by carrier")
            case _ =>
              throw new IllegalArgumentException("Invalid dataset")
          }
      def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
        Tuple2[String, String] =
        dataset match
          {
            case "Amount" =>
              Tuple2(metricData.totalFlights(depArr), "Planes")
          }
      var visible: VBox = new VBox(0)
      val metric = new Metric()
      var removeAdd = 0
      var metricCount = 0
      var parentPane: Pane = new Pane()
      def addMetric(card: StackPane): Pane =
        {
          if metricCount == 0 then
            {
              parentPane.getChildren().addAll(card)
              metricCount = 1
              parentPane
            }
           else parentPane
        }
      def removeMetric(): Pane =
        {
          parentPane.getChildren().clear()
          metricCount = 0
          parentPane
        }
      var chart: ScatterChart[String, Number] =
        makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr", "rre"
          )
      def initializeGraph(): VBox =
        {
          val deparrComboBoxC =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxC.value = "All"
          val deparrComboBoxM =
            new ComboBox(List("All", "Departing", "Arriving"))
          deparrComboBoxM.value = "All"
          val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
          viewComboBox.value = "Graph View"
          val graphComboBox =
            new ComboBox(List("Column", "Scatter", "Line", "Pie"))
          graphComboBox.value = "Column"
          val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
          datasetComboBoxC.value = "Time"
          val datasetComboBoxM = new ComboBox(List("Amount"))
          datasetComboBoxM.value = "Amount"
          val removeButton = new Button("Remove")
          val addButton = new Button("Add")
          val comboBoxHBox1 =
            new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
          val comboBoxHBox2 =
            new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
              addButton)
          chart.getData.foreach(
            series =>
              {
                series.getData.foreach(
                  d =>
                    {
                      val pointNode: scalafx.scene.Node = d.getNode
                      val pointValue = d.getYValue.toString
                      val pointTime = d.getXValue.toString
                      val roundedValue =
                        BigDecimal(pointValue).setScale(1,
                          BigDecimal.RoundingMode.HALF_UP)
                      val tooltip = new Tooltip()
                      tooltip.setText(
                        pointTime + ": " + "$" + roundedValue.toString)
                      tooltip.setStyle(
                        "-fx-background-color: yellow; " +
                          "-fx-text-fill: black; "
                      )
                      Tooltip.install(pointNode, tooltip)
                    }
                )
              }
          )
          var newCBoxes = comboBoxHBox1
          var loaded = 0
          val border = new BorderPane()
          border.center = newCBoxes
          border.right = new HBox(hideButton, viewComboBox border null)
        }
      val VBox1 = initializeGraph()
      val VBox2 = initializeGraph()
      val VBox3 = initializeGraph()
      val VBox4 = initializeGraph()
      val split = new SplitPane()
      split.orientation = Orientation.Horizontal
      val split1 = new SplitPane()
      split1.orientation = Orientation.Vertical
      split1.items.addAll(VBox1, VBox3)
      val split2 = new SplitPane()
      split2.orientation = Orientation.Vertical
      split2.items.addAll(VBox2, VBox4)
      split.items.addAll(split1, split2)
      homeTab.content = split
      dataTab.content = tabPane1
      root.children += (menuBar, tabPane)
    }
}
error while checking package <empty> {
  import scalafx.application.JFXApp3
  import scalafx.scene.Scene
  import scalafx.scene.layout.Pane
  import scalafx.scene.shape.Rectangle
  import scalafx.scene.input.{KeyCodeCombination, KeyCode, KeyCombination}
  import scalafx.scene.paint.Color.*
  import Data.DataParser.*
  import scalafx.scene.control.*
  import scalafx.Includes.*
  import scalafx.event.ActionEvent
  import javafx.scene.layout.VBox
  import java.awt.Graphics
  import scalafx.stage.StageStyle.Unified
  import javafx.stage.StageStyle
  import scalafx.beans.property.StringProperty
  import scalafx.collections.ObservableBuffer
  import scalafx.beans.property.StringProperty
  import Data.Flight
  import Visual.*
  import Visual.LinePlot
  import scalafx.scene.chart.*
  import java.util.Locale.Category
  import scalafx.stage.FileChooser
  import cats.conversions.all
  import Visual.Tables
  import cats.instances.list
  import Visual.ScatterPlot
  import Data.DataParser
  import scala.annotation.meta.field
  import cats.instances.map
  import javafx.scene.layout.BorderPane
  import scalafx.scene.layout.HBox
  import scalafx.geometry.Orientation
  import scalafx.scene.layout.Priority
  import scalafx.scene.control.ComboBox
  import scalafx.geometry.Pos.{TopRight, TopCenter}
  import scalafx.geometry.Pos
  import scalafx.scene.layout.StackPane
  import finaviaAPI.*
  import java.util.Timer
  import java.util.TimerTask
  import scala.concurrent.duration.*
  import scalafx.application.Platform
  import scalafx.scene.input.MouseEvent
  import javafx.scene.Node
  import scala.math.*
  import cats.conversions.all.autoNarrowContravariant
  import cats.conversions.variance.autoNarrowContravariant
  import cats.conversions.all.autoWidenFunctor
  import cats.conversions.variance.autoWidenFunctor
  module object Dashboard extends JFXApp3 {
    def start() =
      {
        stage =
          new JFXApp3.PrimaryStage {
            title = "Helsinki Airport Dashboard"
            width = 1500
            height = 1000
            initStyle(StageStyle.DECORATED)
          }
        val root = Pane()
        val scene = Scene(parent = root)
        stage.scene = scene
        val menuBar = new MenuBar()
        val fileMenu = new Menu("File")
        val settingsMenu = new Menu("Settings")
        val saveItem = new MenuItem("Save")
        val openItem = new MenuItem("Open")
        val exitItem = new MenuItem("Exit")
        val themeItem = new MenuItem("Theme")
        fileMenu.items =
          List(openItem, saveItem, new SeparatorMenuItem(), exitItem)
        settingsMenu.items = List(themeItem)
        menuBar.menus = List(fileMenu, settingsMenu)
        menuBar.prefWidth = 1500
        openItem.accelerator =
          new KeyCodeCombination(KeyCode.O, KeyCombination.ControlDown)
        saveItem.accelerator =
          new KeyCodeCombination(KeyCode.S, KeyCombination.ControlDown)
        exitItem.accelerator =
          new KeyCodeCombination(KeyCode.X, KeyCombination.ControlDown)
        val hideButton = new Button("Hide")
        hideButton.onAction =
          () =>
            {
              visible.visible = ! visible.visible.value
            }
        var isDarkMode = true
        themeItem.onAction = (e: ActionEvent) => toggleTheme()
        def toggleTheme(): Unit =
          {
            isDarkMode = ! isDarkMode
            if (isDarkMode)
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/dark-theme.css").toExternalForm)
              }
             else
              {
                stage.scene.value.stylesheets =
                  List(getClass.getResource("/light-theme.css").toExternalForm)
              }
          }
        val tabPane = new TabPane()
        val homeTab = new Tab()
        homeTab.text = "Home"
        val dataTab = new Tab()
        dataTab.text = "Data"
        tabPane.layoutY = 30
        tabPane.minWidth = 1500
        tabPane.tabs = List(homeTab, dataTab)
        val tabPane1 = new TabPane()
        val depTab = new Tab()
        val arrTab = new Tab()
        val allTab = new Tab()
        depTab.text = "Departing"
        arrTab.text = "Arriving"
        allTab.text = "All"
        tabPane1.layoutY = 30
        tabPane1.minWidth = 1500
        tabPane1.tabs = List(allTab, depTab, arrTab)
        val tables = new Tables()
        allTab.content = tables.createFlightTableAll()
        depTab.content = tables.createFlightTableDep()
        arrTab.content = tables.createFlightTableArr()
        def makeColumnGraph(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): BarChart[String, Number] =
          {
            val columnChart = new ColumnChart()
            val chart =
              columnChart.createColumnChart(graphDataType, x, y, label)
            chart
          }
        def makeScatterChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): ScatterChart[String, Number] =
          {
            val scatterChart = new ScatterPlot()
            val chart =
              scatterChart.createScatterChart(graphDataType, x, y, label)
            chart
          }
        def makeLineChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): LineChart[String, Number] =
          {
            val lineChart = new LinePlot()
            val chart = lineChart.createLineChart(graphDataType, x, y, label)
            chart
          }
        def makePieChart(graphDataType: Array[(String, Int)], x: String,
          y: String, label: String): PieChart =
          {
            val pieChart = new PieGraph()
            val chart = pieChart.createPieChart(graphDataType, x, y, label)
            chart
          }
        def makeChart(graphType: String, dataType: Array[(String, Int)],
          x: String, y: String, label: String) =
          graphType match
            {
              case "Column" =>
                makeColumnGraph(dataType, x, y, label)
              case "Scatter" =>
                makeScatterChart(dataType, x, y, label)
              case "Line" =>
                makeLineChart(dataType, x, y, label)
              case "Pie" =>
                makePieChart(dataType, x, y, label)
              case _ =>
                throw new IllegalArgumentException("Invalid graph type")
            }
        val card = new Metric()
        val graphData = new GraphData()
        val metricData = new MetricData()
        var depArrData = getAllFlightData()
        def getChartData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple4[Array[(String, Int)], String, String, String] =
          dataset match
            {
              case "Time" =>
                Tuple4(graphData.flightPerHourData(depArr), "Time",
                  "Airplanes flown", "Airplanes flown each hour")
              case "Carrier" =>
                Tuple4(graphData.flightPerCarrierData(depArr), "Carrier",
                  "Airplanes flown", "Amount of planes flown by carrier")
              case _ =>
                throw new IllegalArgumentException("Invalid dataset")
            }
        def getMetricData(dataset: String, depArr: ObservableBuffer[Flight]):
          Tuple2[String, String] =
          dataset match
            {
              case "Amount" =>
                Tuple2(metricData.totalFlights(depArr), "Planes")
            }
        var visible: VBox = new VBox(0)
        val metric = new Metric()
        var removeAdd = 0
        var metricCount = 0
        var parentPane: Pane = new Pane()
        def addMetric(card: StackPane): Pane =
          {
            if metricCount == 0 then
              {
                parentPane.getChildren().addAll(card)
                metricCount = 1
                parentPane
              }
             else parentPane
          }
        def removeMetric(): Pane =
          {
            parentPane.getChildren().clear()
            metricCount = 0
            parentPane
          }
        var chart: ScatterChart[String, Number] =
          makeScatterChart(getChartData("Time", depArrData)._1, "dfe", "fr",
            "rre")
        def initializeGraph(): VBox =
          {
            val deparrComboBoxC =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxC.value = "All"
            val deparrComboBoxM =
              new ComboBox(List("All", "Departing", "Arriving"))
            deparrComboBoxM.value = "All"
            val viewComboBox = new ComboBox(List("Graph View", "Metric View"))
            viewComboBox.value = "Graph View"
            val graphComboBox =
              new ComboBox(List("Column", "Scatter", "Line", "Pie"))
            graphComboBox.value = "Column"
            val datasetComboBoxC = new ComboBox(List("Carrier", "Time"))
            datasetComboBoxC.value = "Time"
            val datasetComboBoxM = new ComboBox(List("Amount"))
            datasetComboBoxM.value = "Amount"
            val removeButton = new Button("Remove")
            val addButton = new Button("Add")
            val comboBoxHBox1 =
              new HBox(10, graphComboBox, datasetComboBoxC, deparrComboBoxC)
            val comboBoxHBox2 =
              new HBox(10, datasetComboBoxM, deparrComboBoxM, removeButton,
                addButton)
            chart.getData.foreach(
              series =>
                {
                  series.getData.foreach(
                    d =>
                      {
                        val pointNode: scalafx.scene.Node = d.getNode
                        val pointValue = d.getYValue.toString
                        val pointTime = d.getXValue.toString
                        val roundedValue =
                          BigDecimal(pointValue).setScale(1,
                            BigDecimal.RoundingMode.HALF_UP)
                        val tooltip = new Tooltip()
                        tooltip.setText(
                          pointTime + ": " + "$" + roundedValue.toString)
                        tooltip.setStyle(
                          "-fx-background-color: yellow; " +
                            "-fx-text-fill: black; "
                        )
                        Tooltip.install(pointNode, tooltip)
                      }
                  )
                }
            )
            var newCBoxes = comboBoxHBox1
            var loaded = 0
            val border = new BorderPane()
            border.center = newCBoxes
            border.right = new HBox(hideButton, viewComboBox border null)
          }
        val VBox1 = initializeGraph()
        val VBox2 = initializeGraph()
        val VBox3 = initializeGraph()
        val VBox4 = initializeGraph()
        val split = new SplitPane()
        split.orientation = Orientation.Horizontal
        val split1 = new SplitPane()
        split1.orientation = Orientation.Vertical
        split1.items.addAll(VBox1, VBox3)
        val split2 = new SplitPane()
        split2.orientation = Orientation.Vertical
        split2.items.addAll(VBox2, VBox4)
        split.items.addAll(split1, split2)
        homeTab.content = split
        dataTab.content = tabPane1
        root.children += (menuBar, tabPane)
      }
  }
}
Apr 05, 2024 10:35:14 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-35-14-104.md
2024.04.05 10:36:02 INFO  compiling root (1 scala source)
2024.04.05 10:36:08 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:36:08 INFO  time: compiled root in 5.3s
2024.04.05 10:36:52 INFO  compiling root (1 scala source)
2024.04.05 10:36:56 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:36:56 INFO  time: compiled root in 4.02s
Exception in thread "pool-7-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.05 10:41:32 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 45h 53m 26.692s)
2024.04.05 10:41:32 INFO  compiling root (1 scala source)
2024.04.05 10:41:32 INFO  compiling root (1 scala source)
2024.04.05 10:41:36 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:41:36 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 10:41:36 INFO  time: compiled root in 4.31s
2024.04.05 10:41:37 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 10:41:37 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 10:41:37 INFO  Starting debug proxy for [Dashboard]
2024.04.05 10:41:36 INFO  Loaded expression compiler in 11 milliseconds
2024.04.05 10:41:36 INFO  Loaded step filter in 0 milliseconds
2024.04.05 10:41:36 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 10:41:45 INFO  Loaded all sources and classes in 8 seconds
2024.04.05 10:41:50 INFO  Trying to attach to remote debuggee VM localhost:64436 .
2024.04.05 10:41:50 INFO  Attaching to debuggee VM succeeded.
Apr 05, 2024 10:43:27 AM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.actor.type.ExtendedActorSystem
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.actor.type.ExtendedActorSystem
the classfile defining the type might be missing from the classpath

Apr 05, 2024 10:43:27 AM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.actor.type.ActorSystem
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.actor.type.ActorSystem
the classfile defining the type might be missing from the classpath

Apr 05, 2024 10:43:28 AM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.actor.type.ExtendedActorSystem
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.actor.type.ExtendedActorSystem
the classfile defining the type might be missing from the classpath

Apr 05, 2024 10:43:28 AM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type akka.actor.type.ActorSystem
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type akka.actor.type.ActorSystem
the classfile defining the type might be missing from the classpath

Apr 05, 2024 10:44:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26429
Apr 05, 2024 10:44:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26464
Apr 05, 2024 10:48:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26511
Apr 05, 2024 10:52:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27273
2024.04.05 10:53:01 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 46h 4m 55.855s)
2024.04.05 10:53:01 INFO  compiling root (1 scala source)
2024.04.05 10:53:01 INFO  compiling root (1 scala source)
2024.04.05 10:53:06 INFO  time: compiled root in 4.04s
2024.04.05 10:53:08 INFO  compiling root (1 scala source)
2024.04.05 10:53:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:53:12 INFO  time: compiled root in 4.5s
2024.04.05 10:53:12 INFO  {
  "jsonrpc": "2.0",
  "id": "2513",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.05 10:53:12 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 10:53:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:53:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:53:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:53:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:53:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:53:49 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:53:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:53:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:53:59 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:54:02 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 10:54:02 INFO  Closing debug server tcp://0.0.0.0:64433
2024.04.05 10:54:04 INFO  compiling root (1 scala source)
2024.04.05 10:54:20 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 05, 2024 10:54:30 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.04.05 10:54:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:54:40 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:54:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:55:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:55:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:55:46 INFO  running '/Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home/bin/java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar /var/folders/_k/74l7m8q96c70qsmn56rqh_zc0000gq/T/metals6287671867236016873/sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.05 10:55:51 INFO  [info] welcome to sbt 1.9.8 (Amazon.com Inc. Java 17.0.8.1)
2024.04.05 10:55:55 INFO  [info] loading global plugins from /Users/alvin/.sbt/1.0/plugins
2024.04.05 10:55:58 INFO  [info] loading settings for project os2projekti-build-build from metals.sbt ...
2024.04.05 10:55:58 INFO  Shutting down server
2024.04.05 10:55:58 INFO  shutting down Metals
2024.04.05 10:55:59 INFO  Shut down connection with build server.
2024.04.05 10:55:59 INFO  Shut down connection with build server.
Apr 05, 2024 10:55:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFO: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.AsynchronousCloseException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.$anonfun$cancel$1(FutureWithTimeout.scala:37)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.cancel(FutureWithTimeout.scala:37)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:396)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:171)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:163)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.nio.channels.AsynchronousCloseException
	at java.base/java.nio.channels.spi.AbstractInterruptibleChannel.end(AbstractInterruptibleChannel.java:202)
	at java.base/sun.nio.ch.SinkChannelImpl.endWrite(SinkChannelImpl.java:263)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:285)
	at java.base/java.nio.channels.Channels.writeFullyImpl(Channels.java:74)
	at java.base/java.nio.channels.Channels.writeFully(Channels.java:93)
	at java.base/java.nio.channels.Channels$1.write(Channels.java:171)
	at java.base/java.io.OutputStream.write(OutputStream.java:127)
	at java.base/java.nio.channels.Channels$1.write(Channels.java:151)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:137)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:108)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 20 more

2024.04.05 10:55:59 INFO  Cancelling compilation on Bloop server
2024.04.05 10:56:00 INFO  Exiting server
2024.04.05 10:56:24 INFO  Started: Metals version 1.2.2 in folders '/Users/alvin/VScode/OS2Projekti' for client Visual Studio Code 1.87.2.
10:56:28.467 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
10:56:28.473 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
10:56:28.474 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
10:56:28.478 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
10:56:28.478 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@531d72ca ...
10:56:28.478 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
10:56:28.478 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
10:56:28.478 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@531d72ca ...
10:56:28.482 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/Users/alvin/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
10:56:28.486 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
10:56:28.486 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
10:56:28.486 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
10:56:28.486 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
10:56:28.486 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
10:56:28.486 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
10:56:28.491 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:56:28.491 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
10:56:28.493 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
10:56:28.493 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
10:56:28.493 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
10:56:28.667 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:/Users/alvin/VScode/OS2Projekti/.metals/metals (H2 2.2)
10:56:28.669 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
10:56:28.670 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
10:56:28.671 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
10:56:28.671 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
10:56:28.678 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
10:56:28.679 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
10:56:28.680 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:56:28.690 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
10:56:28.693 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:56:28.705 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:56:28.706 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:56:28.706 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:56:28.706 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:56:28.706 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:56:28.708 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:56:28.708 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:56:28.709 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:56:28.709 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:56:28.709 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:56:28.735 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.044s)
10:56:28.737 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
10:56:28.746 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
10:56:28.751 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
10:56:29.066 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 92 of 243M
2024.04.05 10:56:29 INFO  skipping build import with status 'Started'
2024.04.05 10:56:29 INFO  Attempting to connect to the build server...
2024.04.05 10:56:29 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.05 10:56:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.05 10:56:30 INFO  Attempting to connect to the build server...
2024.04.05 10:56:30 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.05 10:56:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/project/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.05 10:56:30 INFO  time: Connected to build server in 1.65s
2024.04.05 10:56:30 INFO  Connected to Build server: Bloop v1.5.15
2024.04.05 10:56:32 INFO  time: Imported build in 0.64s
Apr 05, 2024 10:56:39 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
Apr 05, 2024 10:56:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11
2024.04.05 10:56:42 INFO  running '/Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home/bin/java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar /var/folders/_k/74l7m8q96c70qsmn56rqh_zc0000gq/T/metals12649647232661829422/sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.05 10:56:47 INFO  [info] welcome to sbt 1.9.8 (Amazon.com Inc. Java 17.0.8.1)
2024.04.05 10:56:52 INFO  [info] loading global plugins from /Users/alvin/.sbt/1.0/plugins
2024.04.05 10:56:55 INFO  [info] loading settings for project os2projekti-build-build from metals.sbt ...
2024.04.05 10:56:57 INFO  [info] loading project definition from /Users/alvin/VScode/OS2Projekti/project/project
2024.04.05 10:56:58 INFO  time: indexed workspace in 26s
2024.04.05 10:56:59 INFO  [info] loading settings for project os2projekti-build from metals.sbt ...
2024.04.05 10:56:59 INFO  compiling root (1 scala source)
2024.04.05 10:56:59 INFO  [info] loading project definition from /Users/alvin/VScode/OS2Projekti/project
2024.04.05 10:57:09 INFO  [success] Generated .bloop/os2projekti-build.json
2024.04.05 10:57:09 INFO  [success] Total time: 9 s, completed 5 Apr 2024, 10.57.09
2024.04.05 10:57:09 INFO  [info] loading settings for project root from build.sbt ...
2024.04.05 10:57:10 INFO  [info] set current project to OS2Projekti (in build file:/Users/alvin/VScode/OS2Projekti/)
2024.04.05 10:57:11 INFO  [success] Generated .bloop/root.json
2024.04.05 10:57:11 INFO  [success] Generated .bloop/root-test.json
2024.04.05 10:57:11 INFO  [success] Total time: 1 s, completed 5 Apr 2024, 10.57.11
2024.04.05 10:57:11 INFO  time: ran 'sbt bloopInstall' in 29s
2024.04.05 10:57:11 INFO  Disconnecting from Bloop session...
2024.04.05 10:57:11 INFO  Cancelling compilation on Bloop server
2024.04.05 10:57:11 INFO  Shut down connection with build server.
2024.04.05 10:57:13 ERROR timeout: build server 'bloop' during shutdown
2024.04.05 10:57:13 INFO  Attempting to connect to the build server...
2024.04.05 10:57:13 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.05 10:57:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.05 10:57:13 INFO  Attempting to connect to the build server...
2024.04.05 10:57:13 INFO  Bloop uses /Library/Java/JavaVirtualMachines/amazon-corretto-17.jdk/Contents/Home defined at /Users/alvin/.bloop/bloop.json
2024.04.05 10:57:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/project/.metals/bsp.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/bsp.trace.json
2024.04.05 10:57:13 INFO  time: Connected to build server in 0.3s
2024.04.05 10:57:13 INFO  Connected to Build server: Bloop v1.5.15
2024.04.05 10:57:15 INFO  time: compiled root in 15s
2024.04.05 10:57:15 INFO  compiling root (1 scala source)
Apr 05, 2024 10:57:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37
Apr 05, 2024 10:57:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23
2024.04.05 10:57:18 INFO  time: compiled root in 2.52s
2024.04.05 10:57:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:57:27 INFO  time: indexed workspace in 12s
2024.04.05 10:57:28 INFO  compiling root (1 scala source)
2024.04.05 10:57:34 INFO  time: compiled root in 6.63s
Apr 05, 2024 10:57:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 61
2024.04.05 10:57:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
error: /Users/alvin/VScode/OS2Projekti/.metals/.tmp/.metals/.tmp/Main6044206682939582058.scala is not a file
Apr 05, 2024 10:57:44 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report /Users/alvin/VScode/OS2Projekti/.metals/.reports/metals-full/2024-04-05/r_compiler-error_(root)_10-57-44-636.md
2024.04.05 10:57:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:57:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:57:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:57:48 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:57:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:57:52 INFO  compiling root (1 scala source)
2024.04.05 10:57:53 INFO  time: compiled root in 1.43s
2024.04.05 10:57:53 INFO  compiling root (1 scala source)
2024.04.05 10:57:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:57:54 INFO  time: compiled root in 1s
2024.04.05 10:57:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:05 INFO  compiling root (1 scala source)
2024.04.05 10:58:06 INFO  time: compiled root in 1.13s
2024.04.05 10:58:06 INFO  compiling root (1 scala source)
2024.04.05 10:58:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:06 INFO  time: compiled root in 0.89s
2024.04.05 10:58:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:22 INFO  compiling root (1 scala source)
2024.04.05 10:58:23 INFO  time: compiled root in 1.05s
2024.04.05 10:58:23 INFO  compiling root (1 scala source)
2024.04.05 10:58:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:23 INFO  time: compiled root in 0.9s
2024.04.05 10:58:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:42 INFO  compiling root (1 scala source)
2024.04.05 10:58:44 INFO  time: compiled root in 1.19s
2024.04.05 10:58:44 INFO  compiling root (1 scala source)
2024.04.05 10:58:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:58:44 INFO  time: compiled root in 0.85s
2024.04.05 10:58:45 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:00 INFO  compiling root (1 scala source)
2024.04.05 10:59:01 INFO  time: compiled root in 1.12s
2024.04.05 10:59:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:03 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:33 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 05, 2024 10:59:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 310
2024.04.05 10:59:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:37 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:52 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 10:59:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:00 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:13 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:15 INFO  compiling root (1 scala source)
2024.04.05 11:00:17 INFO  time: compiled root in 1.36s
2024.04.05 11:00:17 INFO  compiling root (1 scala source)
2024.04.05 11:00:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:18 INFO  time: compiled root in 1.25s
2024.04.05 11:00:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 05, 2024 11:00:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 442
2024.04.05 11:00:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:33 INFO  compiling root (1 scala source)
2024.04.05 11:00:34 INFO  time: compiled root in 1.15s
2024.04.05 11:00:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:38 INFO  compiling root (1 scala source)
2024.04.05 11:00:39 INFO  time: compiled root in 1.18s
2024.04.05 11:00:39 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:50 INFO  compiling root (1 scala source)
2024.04.05 11:00:51 INFO  time: compiled root in 1.06s
2024.04.05 11:00:51 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:00:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:01 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:02 INFO  compiling root (1 scala source)
2024.04.05 11:01:04 INFO  time: compiled root in 1.17s
2024.04.05 11:01:04 INFO  compiling root (1 scala source)
2024.04.05 11:01:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:04 INFO  time: compiled root in 0.87s
2024.04.05 11:01:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:05 INFO  compiling root (1 scala source)
2024.04.05 11:01:07 INFO  time: compiled root in 1.32s
2024.04.05 11:01:07 INFO  compiling root (1 scala source)
2024.04.05 11:01:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:08 INFO  time: compiled root in 1.68s
2024.04.05 11:01:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:14 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:30 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:31 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:32 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:01:33 INFO  compiling root (1 scala source)
2024.04.05 11:01:35 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:01:35 INFO  time: compiled root in 2.11s
2024.04.05 11:03:05 INFO  compiling root (1 scala source)
2024.04.05 11:03:05 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 5m 51.856s)
2024.04.05 11:03:05 INFO  compiling root (1 scala source)
2024.04.05 11:03:07 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:03:07 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:03:07 INFO  time: compiled root in 1.7s
2024.04.05 11:03:07 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 5m 53.657s)
2024.04.05 11:03:07 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 11:03:07 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 11:03:07 INFO  Starting debug proxy for [Dashboard]
2024.04.05 11:03:07 INFO  Loaded expression compiler in 9 milliseconds
2024.04.05 11:03:07 INFO  Loaded step filter in 0 milliseconds
2024.04.05 11:03:07 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 11:03:11 INFO  Loaded all sources and classes in 3 seconds
2024.04.05 11:03:12 INFO  Trying to attach to remote debuggee VM localhost:64622 .
2024.04.05 11:03:12 INFO  Attaching to debuggee VM succeeded.
2024.04.05 11:03:35 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 11:03:35 INFO  Closing debug server tcp://0.0.0.0:64619
2024.04.05 11:03:52 INFO  compiling root (1 scala source)
2024.04.05 11:03:53 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:03:53 INFO  time: compiled root in 1.72s
2024.04.05 11:07:24 INFO  compiling root (1 scala source)
2024.04.05 11:07:24 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 10m 10.583s)
2024.04.05 11:07:24 INFO  compiling root (1 scala source)
2024.04.05 11:07:25 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:07:25 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:07:25 INFO  time: compiled root in 1.53s
2024.04.05 11:07:26 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 11:07:26 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 11:07:26 INFO  Starting debug proxy for [Dashboard]
2024.04.05 11:07:25 INFO  Loaded expression compiler in 2 milliseconds
2024.04.05 11:07:25 INFO  Loaded step filter in 0 milliseconds
2024.04.05 11:07:25 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 11:07:30 INFO  Loaded all sources and classes in 3 seconds
2024.04.05 11:07:31 INFO  Trying to attach to remote debuggee VM localhost:64668 .
2024.04.05 11:07:31 INFO  Attaching to debuggee VM succeeded.
2024.04.05 11:12:57 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:313: error: illegal character '\u00a7'
          if hideShow == §
                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:469)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:474)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 11:15:16 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 18m 2.293s)
2024.04.05 11:15:16 INFO  compiling root (1 scala source)
2024.04.05 11:15:16 INFO  compiling root (1 scala source)
2024.04.05 11:15:17 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:15:17 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:15:17 INFO  time: compiled root in 1.96s
2024.04.05 11:15:18 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 11:15:18 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 11:15:18 INFO  Starting debug proxy for [Dashboard]
2024.04.05 11:15:17 INFO  Loaded expression compiler in 2 milliseconds
2024.04.05 11:15:17 INFO  Loaded step filter in 0 milliseconds
2024.04.05 11:15:17 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 11:15:21 INFO  Loaded all sources and classes in 3 seconds
2024.04.05 11:15:22 INFO  Trying to attach to remote debuggee VM localhost:64746 .
2024.04.05 11:15:22 INFO  Attaching to debuggee VM succeeded.
2024.04.05 11:15:24 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 11:15:24 INFO  Closing debug server tcp://0.0.0.0:64664
2024.04.05 11:15:26 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 11:15:26 INFO  Closing debug server tcp://0.0.0.0:64741
2024.04.05 11:15:27 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 18m 13.917s)
2024.04.05 11:15:27 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 11:15:27 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 11:15:28 INFO  Starting debug proxy for [Dashboard]
2024.04.05 11:15:27 INFO  Loaded expression compiler in 3 milliseconds
2024.04.05 11:15:27 INFO  Loaded step filter in 0 milliseconds
2024.04.05 11:15:27 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 11:15:31 INFO  Loaded all sources and classes in 3 seconds
2024.04.05 11:15:33 INFO  Trying to attach to remote debuggee VM localhost:64757 .
2024.04.05 11:15:33 INFO  Attaching to debuggee VM succeeded.
2024.04.05 11:16:51 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 19m 37.196s)
2024.04.05 11:16:51 INFO  compiling root (1 scala source)
2024.04.05 11:16:51 INFO  compiling root (1 scala source)
2024.04.05 11:16:53 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 11:16:53 INFO  Closing debug server tcp://0.0.0.0:64754
2024.04.05 11:16:54 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:16:54 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:16:54 INFO  time: compiled root in 3.4s
2024.04.05 11:16:54 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 11:16:54 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 11:16:54 INFO  Starting debug proxy for [Dashboard]
2024.04.05 11:16:54 INFO  Loaded expression compiler in 6 milliseconds
2024.04.05 11:16:54 INFO  Loaded step filter in 0 milliseconds
2024.04.05 11:16:54 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 11:16:56 INFO  Loaded all sources and classes in 2 seconds
2024.04.05 11:16:58 INFO  Trying to attach to remote debuggee VM localhost:64782 .
2024.04.05 11:16:58 INFO  Attaching to debuggee VM succeeded.
2024.04.05 11:17:44 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 11:17:44 INFO  Closing debug server tcp://0.0.0.0:64778
2024.04.05 11:18:56 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 11:18:56 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 11:18:56 INFO  Starting debug proxy for [Dashboard]
2024.04.05 11:18:56 INFO  Loaded expression compiler in 2 milliseconds
2024.04.05 11:18:56 INFO  Loaded step filter in 0 milliseconds
2024.04.05 11:18:56 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 11:18:59 INFO  Loaded all sources and classes in 2 seconds
2024.04.05 11:19:00 INFO  Trying to attach to remote debuggee VM localhost:64822 .
2024.04.05 11:19:00 INFO  Attaching to debuggee VM succeeded.
2024.04.05 11:20:38 INFO  Closing debug server tcp://0.0.0.0:64819
2024.04.05 11:20:38 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 11:20:40 INFO  compiling root (1 scala source)
2024.04.05 11:20:42 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:20:42 INFO  time: compiled root in 1.91s
2024.04.05 11:24:45 INFO  compiling root (1 scala source)
2024.04.05 11:24:47 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:24:47 INFO  time: compiled root in 1.91s
Apr 05, 2024 11:27:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1952
Apr 05, 2024 11:27:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1954
2024.04.05 11:27:42 INFO  compiling root (1 scala source)
2024.04.05 11:27:42 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 30m 28.583s)
2024.04.05 11:27:42 INFO  compiling root (1 scala source)
2024.04.05 11:27:43 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:27:43 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:27:43 INFO  time: compiled root in 1.62s
2024.04.05 11:27:44 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 11:27:44 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 11:27:44 INFO  Starting debug proxy for [Dashboard]
2024.04.05 11:27:43 INFO  Loaded expression compiler in 1 millisecond
2024.04.05 11:27:43 INFO  Loaded step filter in 0 milliseconds
2024.04.05 11:27:43 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 11:27:46 INFO  Loaded all sources and classes in 2 seconds
2024.04.05 11:27:48 INFO  Trying to attach to remote debuggee VM localhost:64899 .
2024.04.05 11:27:48 INFO  Attaching to debuggee VM succeeded.
2024.04.05 11:30:26 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 11:30:26 INFO  Closing debug server tcp://0.0.0.0:64896
Apr 05, 2024 11:30:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1986
2024.04.05 11:33:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 11:33:17 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 36m 3.906s)
2024.04.05 11:33:17 INFO  compiling root (1 scala source)
2024.04.05 11:33:17 INFO  compiling root (1 scala source)
2024.04.05 11:33:19 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:33:19 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:33:19 INFO  time: compiled root in 1.63s
2024.04.05 11:33:19 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 11:33:19 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 11:33:19 INFO  Starting debug proxy for [Dashboard]
2024.04.05 11:33:19 INFO  Loaded expression compiler in 1 millisecond
2024.04.05 11:33:19 INFO  Loaded step filter in 0 milliseconds
2024.04.05 11:33:19 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 11:33:21 INFO  Loaded all sources and classes in 2 seconds
2024.04.05 11:33:22 INFO  Trying to attach to remote debuggee VM localhost:64976 .
2024.04.05 11:33:22 INFO  Attaching to debuggee VM succeeded.
2024.04.05 11:34:56 INFO  compiling root (1 scala source)
2024.04.05 11:34:57 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:34:57 INFO  time: compiled root in 1.88s
2024.04.05 11:38:13 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 40m 59.592s)
2024.04.05 11:38:13 INFO  compiling root (1 scala source)
2024.04.05 11:38:13 INFO  compiling root (1 scala source)
2024.04.05 11:38:16 INFO  time: compiled root in 2.65s
2024.04.05 11:38:16 INFO  compiling root (1 scala source)
2024.04.05 11:38:18 INFO  time: compiled root in 2.33s
2024.04.05 11:38:18 INFO  {
  "jsonrpc": "2.0",
  "id": "237",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.05 11:38:18 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 11:39:14 INFO  compiling root (1 scala source)
2024.04.05 11:39:16 INFO  time: compiled root in 2.11s
2024.04.05 11:40:11 INFO  compiling root (1 scala source)
2024.04.05 11:40:15 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 11:40:15 INFO  time: compiled root in 4.55s
2024.04.05 11:40:15 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 43m 2.393s)
2024.04.05 11:40:16 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 11:40:16 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 11:40:16 INFO  Starting debug proxy for [Dashboard]
2024.04.05 11:40:15 INFO  Loaded expression compiler in 8 milliseconds
2024.04.05 11:40:15 INFO  Loaded step filter in 0 milliseconds
2024.04.05 11:40:15 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 11:40:19 INFO  Loaded all sources and classes in 3 seconds
2024.04.05 11:40:21 INFO  Trying to attach to remote debuggee VM localhost:65073 .
2024.04.05 11:40:21 INFO  Attaching to debuggee VM succeeded.
2024.04.05 12:20:57 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 12:20:57 INFO  Closing debug server tcp://0.0.0.0:65070
2024.04.05 12:20:57 INFO  Closing debug server tcp://0.0.0.0:64973
2024.04.05 12:20:58 INFO  Canceling debug proxy for [Dashboard]
Apr 05, 2024 12:27:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2765
Apr 05, 2024 12:27:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2786
2024.04.05 12:27:40 INFO  compiling root (1 scala source)
2024.04.05 12:27:43 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:27:43 INFO  time: compiled root in 3.31s
2024.04.05 12:28:18 INFO  compiling root (1 scala source)
2024.04.05 12:28:20 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:28:20 INFO  time: compiled root in 1.83s
2024.04.05 12:31:24 INFO  compiling root (1 scala source)
2024.04.05 12:31:24 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 34m 11.049s)
2024.04.05 12:31:24 INFO  compiling root (1 scala source)
2024.04.05 12:31:25 INFO  time: compiled root in 1.01s
2024.04.05 12:31:25 INFO  compiling root (1 scala source)
2024.04.05 12:31:25 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 34m 12.189s)
2024.04.05 12:31:25 INFO  compiling root (1 scala source)
2024.04.05 12:31:27 INFO  time: compiled root in 1.18s
2024.04.05 12:31:27 INFO  {
  "jsonrpc": "2.0",
  "id": "279",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.05 12:31:27 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Exception in thread "pool-10-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.05 12:31:35 INFO  compiling root (1 scala source)
2024.04.05 12:31:37 INFO  time: compiled root in 2.38s
2024.04.05 12:31:37 INFO  compiling root (1 scala source)
2024.04.05 12:31:40 INFO  time: compiled root in 2.77s
Apr 05, 2024 12:32:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3120
2024.04.05 12:35:09 INFO  compiling root (1 scala source)
2024.04.05 12:35:12 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:35:12 INFO  time: compiled root in 3.17s
2024.04.05 12:42:12 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 44m 58.34s)
2024.04.05 12:42:12 INFO  compiling root (1 scala source)
2024.04.05 12:42:12 INFO  compiling root (1 scala source)
2024.04.05 12:42:14 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:42:14 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:42:14 INFO  time: compiled root in 2.44s
2024.04.05 12:42:14 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 12:42:14 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 12:42:14 INFO  Starting debug proxy for [Dashboard]
2024.04.05 12:42:14 INFO  Loaded expression compiler in 7 milliseconds
2024.04.05 12:42:14 INFO  Loaded step filter in 0 milliseconds
2024.04.05 12:42:14 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 12:42:17 INFO  Loaded all sources and classes in 2 seconds
2024.04.05 12:42:19 INFO  Trying to attach to remote debuggee VM localhost:65374 .
2024.04.05 12:42:19 INFO  Attaching to debuggee VM succeeded.
2024.04.05 12:42:27 INFO  Closing debug server tcp://0.0.0.0:65371
2024.04.05 12:42:27 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 12:44:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:44:18 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 47m 5.035s)
2024.04.05 12:44:18 INFO  compiling root (1 scala source)
2024.04.05 12:44:18 INFO  compiling root (1 scala source)
2024.04.05 12:44:21 INFO  time: compiled root in 2.2s
2024.04.05 12:44:21 INFO  compiling root (1 scala source)
2024.04.05 12:44:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:44:23 INFO  time: compiled root in 1.86s
2024.04.05 12:44:23 INFO  {
  "jsonrpc": "2.0",
  "id": "328",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.04.05 12:44:23 INFO  compiling root (1 scala source)
2024.04.05 12:44:23 ERROR failed: Starting debug server
scala.meta.internal.metals.MetalsBspException: BSP connection failed in the attempt to get: DebugSessionAddress
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.$anonfun$applyOrElse$9(BuildServerConnection.scala:494)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:494)
	at scala.meta.internal.metals.BuildServerConnection$$anonfun$1.applyOrElse(BuildServerConnection.scala:469)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:490)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: org.eclipse.lsp4j.jsonrpc.MessageIssueException: Message could not be parsed.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponseIssues(RemoteEndpoint.java:358)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handle(RemoteEndpoint.java:317)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 12:44:24 INFO  time: compiled root in 1.66s
2024.04.05 12:44:25 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:44:36 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:44:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:44:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:44:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:44:45 INFO  compiling root (1 scala source)
2024.04.05 12:44:46 INFO  time: compiled root in 1.12s
2024.04.05 12:44:46 INFO  compiling root (1 scala source)
2024.04.05 12:44:46 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:44:47 INFO  time: compiled root in 1.05s
2024.04.05 12:44:47 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:17 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:18 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:20 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:20 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:21 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
Apr 05, 2024 12:45:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3649
2024.04.05 12:45:22 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:23 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:24 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:38 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:39 INFO  compiling root (1 scala source)
2024.04.05 12:45:41 INFO  time: compiled root in 2.05s
2024.04.05 12:45:41 INFO  compiling root (1 scala source)
2024.04.05 12:45:42 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:43 INFO  time: compiled root in 2.02s
2024.04.05 12:45:44 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:53 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:54 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:58 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:45:59 INFO  compiling root (1 scala source)
2024.04.05 12:46:02 INFO  time: compiled root in 2.2s
2024.04.05 12:46:02 INFO  compiling root (1 scala source)
2024.04.05 12:46:02 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:04 INFO  time: compiled root in 2.77s
2024.04.05 12:46:04 INFO  compiling root (1 scala source)
2024.04.05 12:46:05 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:07 INFO  time: compiled root in 1.98s
2024.04.05 12:46:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:10 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:12 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:13 INFO  compiling root (1 scala source)
2024.04.05 12:46:14 INFO  time: compiled root in 1.33s
2024.04.05 12:46:14 INFO  compiling root (1 scala source)
2024.04.05 12:46:15 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:15 INFO  time: compiled root in 0.96s
2024.04.05 12:46:16 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:19 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:26 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:28 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:31 INFO  compiling root (1 scala source)
2024.04.05 12:46:33 INFO  time: compiled root in 2.14s
2024.04.05 12:46:33 INFO  compiling root (1 scala source)
2024.04.05 12:46:34 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:35 INFO  time: compiled root in 1.87s
2024.04.05 12:46:35 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:43 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:54 INFO  compiling root (1 scala source)
2024.04.05 12:46:56 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:46:56 INFO  time: compiled root in 2.48s
2024.04.05 12:46:57 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:47:24 INFO  compiling root (1 scala source)
2024.04.05 12:47:26 INFO  time: compiled root in 2.01s
2024.04.05 12:47:27 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:47:55 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:48:07 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:48:08 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:48:09 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:48:10 INFO  compiling root (1 scala source)
2024.04.05 12:48:12 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:48:12 INFO  time: compiled root in 1.84s
2024.04.05 12:51:21 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 54m 7.352s)
2024.04.05 12:51:21 INFO  compiling root (1 scala source)
2024.04.05 12:51:21 INFO  compiling root (1 scala source)
2024.04.05 12:51:22 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:51:22 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:51:22 INFO  time: compiled root in 1.51s
2024.04.05 12:51:22 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 12:51:22 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 12:51:22 INFO  Starting debug proxy for [Dashboard]
2024.04.05 12:51:22 INFO  Loaded expression compiler in 19 milliseconds
2024.04.05 12:51:22 INFO  Loaded step filter in 0 milliseconds
2024.04.05 12:51:22 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 12:51:26 INFO  Loaded all sources and classes in 3 seconds
2024.04.05 12:51:29 INFO  Trying to attach to remote debuggee VM localhost:65495 .
2024.04.05 12:51:29 INFO  Attaching to debuggee VM succeeded.
2024.04.05 12:54:12 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 12:54:12 INFO  Closing debug server tcp://0.0.0.0:65492
Apr 05, 2024 12:54:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4062
2024.04.05 12:55:04 WARN  Could not load snapshot text for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
2024.04.05 12:55:04 INFO  compiling root (1 scala source)
2024.04.05 12:55:04 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 1h 57m 50.679s)
2024.04.05 12:55:04 INFO  compiling root (1 scala source)
2024.04.05 12:55:05 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:55:05 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:55:05 INFO  time: compiled root in 1.54s
2024.04.05 12:55:06 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 12:55:06 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 12:55:06 INFO  Starting debug proxy for [Dashboard]
2024.04.05 12:55:05 INFO  Loaded expression compiler in 2 milliseconds
2024.04.05 12:55:05 INFO  Loaded step filter in 0 milliseconds
2024.04.05 12:55:05 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 12:55:08 INFO  Loaded all sources and classes in 2 seconds
2024.04.05 12:55:09 INFO  Trying to attach to remote debuggee VM localhost:49222 .
2024.04.05 12:55:09 INFO  Attaching to debuggee VM succeeded.
2024.04.05 12:57:46 INFO  Closing debug server tcp://0.0.0.0:49219
2024.04.05 12:57:46 INFO  Canceling debug proxy for [Dashboard]
Apr 05, 2024 12:57:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4119
2024.04.05 12:58:49 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:273: error: unclosed comment
        /*  if selectedGraph == "Scatter" then
        ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 12:58:50 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Dashboard.scala
scala.meta.tokenizers.TokenizeException: <input>:273: error: unclosed comment
        /*  if selectedGraph == "Scatter" then
        ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.skipNestedComments(LegacyScanner.scala:52)
	at scala.meta.internal.tokenizers.LegacyScanner.skipToCommentEnd(LegacyScanner.scala:71)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:313)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 12:58:55 INFO  compiling root (2 scala sources)
2024.04.05 12:58:58 INFO  time: compiled root in 2.29s
2024.04.05 12:58:58 INFO  compiling root (2 scala sources)
2024.04.05 12:59:00 INFO  time: compiled root in 1.64s
2024.04.05 12:59:17 INFO  compiling root (2 scala sources)
2024.04.05 12:59:19 INFO  time: compiled root in 1.84s
2024.04.05 12:59:31 INFO  compiling root (2 scala sources)
2024.04.05 12:59:33 INFO  time: compiled root in 2.22s
2024.04.05 12:59:41 INFO  compiling root (2 scala sources)
2024.04.05 12:59:43 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 12:59:43 INFO  time: compiled root in 1.63s
Apr 05, 2024 12:59:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4378
Apr 05, 2024 12:59:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4390
Apr 05, 2024 1:01:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4402
2024.04.05 13:01:21 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
scala.meta.tokenizers.TokenizeException: <input>:55: error: unclosed string interpolation
                tooltip.setText("pointTime + ": " + "$" + roundedValue.toString)
                                                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 13:01:27 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
scala.meta.tokenizers.TokenizeException: <input>:55: error: unclosed string interpolation
                tooltip.setText("TimepointTime + ": " + "$" + roundedValue.toString)
                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 13:01:29 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
scala.meta.tokenizers.TokenizeException: <input>:55: error: unclosed string interpolation
                tooltip.setText("Time:pointTime + ": " + "$" + roundedValue.toString)
                                                            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 05, 2024 1:01:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4468
2024.04.05 13:02:05 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
scala.meta.tokenizers.TokenizeException: <input>:55: error: invalid escape character
                tooltip.setText(pointTime  + "\ " + "$" + roundedValue.toString)
                                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.invalidEscape(LegacyScanner.scala:744)
	at scala.meta.internal.tokenizers.LegacyScanner.getLitChar(LegacyScanner.scala:732)
	at scala.meta.internal.tokenizers.LegacyScanner.getLitChars(LegacyScanner.scala:753)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:546)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 13:02:07 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/ScatterPlot.scala
scala.meta.tokenizers.TokenizeException: <input>:55: error: invalid escape character
                tooltip.setText(pointTime  + "\ " + "$" + roundedValue.toString)
                                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.invalidEscape(LegacyScanner.scala:744)
	at scala.meta.internal.tokenizers.LegacyScanner.getLitChar(LegacyScanner.scala:732)
	at scala.meta.internal.tokenizers.LegacyScanner.getLitChars(LegacyScanner.scala:753)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:546)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

Apr 05, 2024 1:02:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4637
Apr 05, 2024 1:02:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4645
Apr 05, 2024 1:02:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4646
Apr 05, 2024 1:02:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4648
Apr 05, 2024 1:02:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.UnsupportedOperationException: tail of empty list
java.util.concurrent.CompletionException: java.lang.UnsupportedOperationException: tail of empty list
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.UnsupportedOperationException: tail of empty list
	at scala.collection.immutable.Nil$.tail(List.scala:664)
	at scala.collection.immutable.Nil$.tail(List.scala:661)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$endPosOfTree$1(CreateCompanionObjectCodeAction.scala:77)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.endPosOfTree(CreateCompanionObjectCodeAction.scala:75)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$5(CreateCompanionObjectCodeAction.scala:61)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$4(CreateCompanionObjectCodeAction.scala:58)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$2(CreateCompanionObjectCodeAction.scala:56)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$1(CreateCompanionObjectCodeAction.scala:55)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.05 13:03:04 WARN  Using indexes to guess the definition of Node
Apr 05, 2024 1:03:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4771
Apr 05, 2024 1:04:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4899
2024.04.05 13:04:18 ERROR Failed to tokenize input for semantic tokens for /Users/alvin/VScode/OS2Projekti/src/main/scala/Visual/PieGraph.scala
scala.meta.tokenizers.TokenizeException: <input>:38: error: Invalid literal number
    b = 0pieChart
        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.05 13:04:54 INFO  Deduplicating compilation of root from bsp client 'Metals 1.2.2' (since 2h 7m 40.751s)
2024.04.05 13:04:54 INFO  compiling root (1 scala source)
2024.04.05 13:04:54 INFO  compiling root (1 scala source)
2024.04.05 13:04:56 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 13:04:56 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 13:04:56 INFO  time: compiled root in 1.66s
2024.04.05 13:04:56 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-server.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-server.trace.json
2024.04.05 13:04:56 INFO  compiling root (4 scala sources)
2024.04.05 13:04:56 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/alvin/VScode/OS2Projekti/.metals/dap-client.trace.json or /Users/alvin/Library/Caches/org.scalameta.metals/dap-client.trace.json
2024.04.05 13:04:56 INFO  Starting debug proxy for [Dashboard]
2024.04.05 13:04:56 INFO  Loaded expression compiler in 7 milliseconds
2024.04.05 13:04:56 INFO  Loaded step filter in 0 milliseconds
2024.04.05 13:04:56 WARN  Found duplicate entry core_3 in debuggee MainClassDebugAdapter(root, Dashboard)
2024.04.05 13:05:00 INFO  Loaded all sources and classes in 3 seconds
2024.04.05 13:05:00 INFO  time: compiled root in 3.84s
2024.04.05 13:05:01 INFO  compiling root (4 scala sources)
2024.04.05 13:05:03 INFO  Trying to attach to remote debuggee VM localhost:49325 .
2024.04.05 13:05:03 INFO  Attaching to debuggee VM succeeded.
2024.04.05 13:05:09 INFO  time: compiled root in 8.03s
2024.04.05 13:05:38 INFO  Closing debug server tcp://0.0.0.0:49321
2024.04.05 13:05:38 INFO  Canceling debug proxy for [Dashboard]
2024.04.05 13:05:39 INFO  compiling root (5 scala sources)
2024.04.05 13:05:42 INFO  time: compiled root in 2.58s
2024.04.05 13:05:56 INFO  compiling root (5 scala sources)
2024.04.05 13:06:01 INFO  time: compiled root in 4.49s
2024.04.05 13:06:09 INFO  compiling root (5 scala sources)
2024.04.05 13:06:12 INFO  time: compiled root in 3s
2024.04.05 13:06:12 INFO  compiling root (5 scala sources)
2024.04.05 13:06:14 INFO  time: compiled root in 2.48s
2024.04.05 13:06:32 INFO  compiling root (5 scala sources)
2024.04.05 13:06:35 INFO  time: compiled root in 2.25s
2024.04.05 13:06:46 INFO  compiling root (5 scala sources)
2024.04.05 13:06:49 WARN  there were 2 deprecation warnings; re-run with -deprecation for details
2024.04.05 13:06:49 INFO  time: compiled root in 3.17s
Apr 05, 2024 1:06:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5243
Apr 05, 2024 1:06:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5254
Apr 05, 2024 1:06:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5256
Apr 05, 2024 1:08:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5277
Apr 05, 2024 1:09:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5384
Apr 05, 2024 1:09:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5390
Apr 05, 2024 1:09:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5432
Apr 05, 2024 1:09:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5441
2024.04.05 13:09:30 INFO  compiling root (4 scala sources)
2024.04.05 13:09:32 WARN  there was 1 deprecation warning; re-run with -deprecation for details
2024.04.05 13:09:32 INFO  time: compiled root in 2.86s
2024.04.05 13:12:11 INFO  compiling root (1 scala source)
2024.04.05 13:12:13 INFO  time: compiled root in 2.07s
Apr 05, 2024 1:12:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5504
Apr 05, 2024 1:12:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5521
2024.04.05 13:14:56 INFO  compiling root (1 scala source)
2024.04.05 13:14:58 INFO  time: compiled root in 1.52s
2024.04.05 13:14:58 INFO  compiling root (1 scala source)
2024.04.05 13:14:59 INFO  time: compiled root in 0.99s
2024.04.05 13:18:22 INFO  compiling root (1 scala source)
2024.04.05 13:18:22 INFO  time: compiled root in 0.48s
2024.04.05 13:18:22 INFO  compiling root (1 scala source)
2024.04.05 13:18:23 INFO  time: compiled root in 0.72s
2024.04.05 13:18:30 INFO  compiling root (1 scala source)
2024.04.05 13:18:31 INFO  time: compiled root in 1.14s
